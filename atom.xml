<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大树洞！</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-05T15:34:15.224Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xie yue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数</title>
    <link href="http://example.com/%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/%E5%87%BD%E6%95%B0/</id>
    <published>2021-06-05T04:08:37.000Z</published>
    <updated>2021-06-05T15:34:15.224Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>)</span></span>; <span class="hljs-comment">// error, 形参不能赋值</span><br><span class="hljs-comment">//cpp里可以给形参赋值，称为默认实参</span><br></code></pre></td></tr></table></figure></li><li><p>实参与形参的个数应相等，类型应匹配(相同或赋值兼容)。实参与形参按顺序对应，一对一地传递数据。</p></li><li><p>实参可以是常量、变量或表达式，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数的定义</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 函数的调用</span><br><span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>, q = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">test</span>(p, q);<span class="hljs-comment">// right</span><br><span class="hljs-built_in">test</span>(<span class="hljs-number">11</span>, <span class="hljs-number">30</span> - <span class="hljs-number">10</span>); <span class="hljs-comment">// right</span><br><span class="hljs-built_in">test</span>(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b); <span class="hljs-comment">// error, 不应该在圆括号里定义变量</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回值如果小于等于四个字节，则存在寄存器中；如果大于四个字节，则存在内存中。</p></li><li><p>如果使用用户自己定义的函数，而该函数与调用它的函数（即主调函数）不在同一文件中，或者函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数作声明。</p></li><li><p>所谓函数声明，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行。</p></li><li><p>注意：一个函数只能被定义一次，但可以声明多次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-comment">//函数的声明可以不加extern</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>; <span class="hljs-comment">// 函数的声明，分号不能省略</span><br><span class="hljs-comment">// int max(int, int); // 另一种方式</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">25</span>, num_max = <span class="hljs-number">0</span>;<br>num_max = <span class="hljs-built_in">max</span>(a, b); <span class="hljs-comment">// 函数的调用</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num_max = %d\n&quot;</span>, num_max);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数的定义</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x &gt; y ? x : y;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>return和exit函数的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在main函数中调用exit和return结果一样</span><br><span class="hljs-comment">//但在子函数中调用return只是代表子函数终止了，在子函数中调用exit，那么程序终止</span><br></code></pre></td></tr></table></figure></li><li><p>分文件编写函数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 把函数声明放在头文件xxx.h中，在主函数中包含相应头文件。<br><span class="hljs-bullet">2.</span> 在头文件对应的xxx.c中实现xxx.h声明的函数。<br><span class="hljs-bullet">3.</span> 每个.c文件是单独编译的，所以要有防止头文件多次包含的方法。<br></code></pre></td></tr></table></figure></li><li><p>防止头文件多次包含</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//头文件中不要定义，只声明，定义只在.c文件中定义</span><br><span class="hljs-comment">//因为重复声明没有问题，重复定义则会出现问题</span><br><span class="hljs-comment">//第一种方式，在.h文件中，注意宏的名字不能重复</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> 宏</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 宏</span><br><span class="hljs-comment">/*代码*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">//第二种方式，在头文件上方声明如下语句</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在定义函数时指定的形参，在未出现函数调用时，它们并不占内存中的存储单元，因此称它们是形式参数或虚拟参数，简称形参，表示它们并不是实际存在的数据，所以，形参里的变量不能赋值。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/%E6%95%B0%E7%BB%84/</id>
    <published>2021-06-05T04:08:29.000Z</published>
    <updated>2021-06-05T13:41:30.194Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li><p>数组就是在内存中连续的相同类型的变量空间。同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的。数组的最小单位是元素。</p></li><li><p>数组属于构造数据类型：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 一个数组可以分解为多个数组元素：这些数组元素可以是基本数据类型或构造类型。<br><span class="hljs-code">int a[10];  </span><br><span class="hljs-code">struct Stu boy[10];</span><br><span class="hljs-code">2. 按数组元素类型的不同，数组可分为：数值数组、字符数组、指针数组、结构数组等类别。</span><br><span class="hljs-code">int a[10];</span><br><span class="hljs-code">char s[10];</span><br><span class="hljs-code">char * p[10];</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><ol><li><p>定义数组时，[]里面的值不能为变量，只能为常量。使用数组时，[]里面的值可以为变量也可以为常量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">//数组中的元素的个数由[]里面的数值决定</span><br>        <span class="hljs-comment">//每个元素的类型由数组名前面的类型决定</span><br>        <span class="hljs-comment">//定义数组时,[]里面的值不能为变量,只能为常量</span><br>        <span class="hljs-comment">//使用时,[]里面的值可以为常量也可以是变量</span><br>        <span class="hljs-comment">//数值数组不能整体操作</span><br>        <span class="hljs-comment">//数组的每一个元素都是变量,可以被改变赋值</span><br>        <span class="hljs-keyword">int</span>  n = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span>  num[<span class="hljs-number">10</span>];<br>        <span class="hljs-comment">//num[0] = 100;</span><br>        <span class="hljs-comment">//printf(&quot;%d\n&quot;,num[0]);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num[i]);<br>        &#125;<br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><ol><li><p>作为局部变量的数组不会被默认初始化，此时如果访问数组，访问到的是一组与系统相关的未定义的值。如果显式地初始化数组部分元素，则其余的元素都被初始化为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//数组的初始化</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <br>        <span class="hljs-comment">//int  num[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br>        <span class="hljs-comment">//如果数组只初始化部分元素,其他元素被初始化为0</span><br>        <span class="hljs-comment">//int  num[10] = &#123; 1,2 &#125;;</span><br>        <span class="hljs-comment">//int  num[10] = &#123; 0 &#125;;//将数组所有元素初始化为0</span><br>        <span class="hljs-comment">//int  num[10] = &#123;[5]=5&#125;;</span><br>        <span class="hljs-comment">//int num[]; //err，定义时没有告知有几个元素</span><br>        <span class="hljs-keyword">int</span>  num[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-comment">//如果定义时,[]中没有值,这个数组的元素个数由&#123;&#125;里面的元素个数决定</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, num[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//数组的大小</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//num是数组名,代表这个数组</span><br>    <span class="hljs-keyword">int</span>  num[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num));<br>    <span class="hljs-comment">//求数组元素个数</span><br>    <span class="hljs-keyword">int</span> n = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n=%d\n&quot;</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num[<span class="hljs-number">0</span>]); i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, num[i]);<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h4><ol><li><p>数组在内存中如何存储：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 数据在内存中的地址，就是它在内存中的起始地址。<br><span class="hljs-bullet">2.</span> 数组名代表数组，也代表第0个元素的地址，所以说数组名是一个常量，是一个地址。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//num是数组名,代表这个数组</span><br>    <span class="hljs-keyword">int</span>  num[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>, num); <span class="hljs-comment">//0x5ef9d4</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>, &amp;num[<span class="hljs-number">0</span>]); <span class="hljs-comment">//0x5ef9d4</span><br>    <span class="hljs-comment">//数组名是一个右值，不能被赋值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>, &amp;num); <span class="hljs-comment">//0x5ef9d4</span><br>    <span class="hljs-comment">//在数值上 num == &amp;num[0] == &amp;num</span><br>    <span class="hljs-comment">//区别</span><br>    <span class="hljs-comment">//元素的地址加一跨过一个元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>, num + <span class="hljs-number">1</span>); <span class="hljs-comment">//0x5ef9d8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>, &amp;num[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>); <span class="hljs-comment">//0x5ef9d8 </span><br>    <span class="hljs-comment">//数组的地址加一跨过整个数组</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%#x\n&quot;</span>, &amp;num + <span class="hljs-number">1</span>); <span class="hljs-comment">//0x5ef9fc</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> num[<span class="hljs-number">10</span>];<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">int</span> n = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;原始数组为：&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>num[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">1000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, num[i]);<br>&#125;<br><span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//总共需要比较n - 1轮</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">//每次确定一个相对最大的数字</span><br><span class="hljs-keyword">if</span> (num[j] &gt; num[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">int</span> tmp = num[j];<br>num[j] = num[j + <span class="hljs-number">1</span>];<br>num[j + <span class="hljs-number">1</span>] = tmp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;冒泡排序之后的数组为：&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, num[i]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><ol><li><p>二维数组的概念</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 二维数组定义的一般形式是：类型说明符 数组名[<span class="hljs-string">常量表达式1</span>][<span class="hljs-symbol">常量表达式2</span>]<br><span class="hljs-bullet">2.</span> 二维数组在概念上是二维的：其下标在两个方向上变化，对其访问一般需要两个下标。<br><span class="hljs-bullet">3.</span> 在内存中并不存在二维数组，二维数组实际的硬件存储器是连续编址的，也就是说内存中只有一维数组，即放完一行之后顺次放入第二行，和一维数组存放方式是一样的。<br></code></pre></td></tr></table></figure></li><li><p>二维数组的定义和访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//定义了一个二维数组，名字叫a</span><br><span class="hljs-comment">//由3个一维数组组成，这个一维数组是int[4]</span><br><span class="hljs-comment">//这3个一维数组的数组名分别为a[0],a[1],a[2]</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//……</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">12</span>;<br><br><span class="hljs-comment">//给数组每个元素赋值</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>a[i][j] = num++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//遍历数组，并输出每个成员的值</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, &quot;</span>, a[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二维数组的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//分段赋值 int a[3][4] = &#123;&#123; 1, 2, 3, 4 &#125;,&#123; 5, 6, 7, 8, &#125;,&#123; 9, 10, 11, 12 &#125;&#125;;</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <br>&#123; <br>&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;,<br>&#123; <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, &#125;,<br>&#123; <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">//连续赋值</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> , <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>  &#125;;<br><br><span class="hljs-comment">//可以只给部分元素赋初值，未初始化则为0</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>  &#125;;<br><br><span class="hljs-comment">//所有的成员都设置为0</span><br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">//[]中不定义元素个数，定义时必须初始化列的下标，可以省略行的下标</span><br><span class="hljs-keyword">int</span> a[][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>求二维数组的行数、列数、元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">int</span> row = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">int</span> col = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a[<span class="hljs-number">0</span>]) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n = %d\nrow = %d\ncol = %d\n&quot;</span>, n, row, col);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二维数组数组名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">//代表第0行第0个元素</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);<span class="hljs-comment">//第0行第0个元素的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, a[<span class="hljs-number">0</span>]);    <span class="hljs-comment">//(1)第0行一维数组的数组名(2)等价于&amp;a[0][0]</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, &amp;a[<span class="hljs-number">0</span>]);   <span class="hljs-comment">//第0行的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, a);       <span class="hljs-comment">//二维数组的数组名，代表二维数组，代表首行地址&amp;a[0]</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, &amp;a);      <span class="hljs-comment">//二维数组的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]); <span class="hljs-comment">//代表第0行第0个元素</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, &amp;a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//第0行第0个元素的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, a[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);    <span class="hljs-comment">//(1)第0行一维数组的数组名(2)等价于&amp;a[0][0]</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, &amp;a[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);   <span class="hljs-comment">//第0行的地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, a + <span class="hljs-number">1</span>);       <span class="hljs-comment">//二维数组的数组名，代表二维数组，代表首行地址&amp;a[0]</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, &amp;a + <span class="hljs-number">1</span>);      <span class="hljs-comment">//二维数组的地址</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4><ol><li> 字符数组与字符串区别：</li></ol>   <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> C语言中没有字符串这种数据类型，可以通过char的数组来替代；<br><span class="hljs-bullet">2.</span> 字符串一定是一个char的数组，但char的数组未必是字符串；<br><span class="hljs-bullet">3.</span> 数字0(和字符‘\0’等价)结尾的char数组就是一个字符串，但如果char数组没有以数字0结尾，那么就不是一个字符串，只是普通字符数组，所以字符串是一种特殊的char的数组。<br></code></pre></td></tr></table></figure>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> c1[] = &#123; <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span> &#125;; <span class="hljs-comment">//普通字符数组</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c1 = %s\n&quot;</span>, c1); <span class="hljs-comment">//乱码，因为没有’\0’结束符</span><br><br><span class="hljs-comment">//以‘\0’(‘\0’就是数字0)结尾的字符数组是字符串</span><br><span class="hljs-keyword">char</span> c2[] = &#123; <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c2 = %s\n&quot;</span>, c2);<br><span class="hljs-comment">//等价于char c2[] = &quot;c prog&quot;;</span><br><span class="hljs-comment">//字符串处理以‘\0’(数字0)作为结束符，后面的&#x27;h&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;e&#x27;, &#x27;o&#x27;不会输出</span><br>    <span class="hljs-keyword">char</span> a[<span class="hljs-number">100</span>] = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//将全部的元素置为&#x27;\0&#x27;</span><br>  <span class="hljs-keyword">char</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">char</span> c3[] = &#123; <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c3 = %s\n&quot;</span>, c3);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>字符串的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// C语言没有字符串类型，通过字符数组模拟</span><br><span class="hljs-comment">// C语言字符串，以字符‘\0’（等价于数字0）结尾</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//不指定长度, 没有0结束符，有多少个元素就有多长</span><br><span class="hljs-keyword">char</span> buf[] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> &#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf = %s\n&quot;</span>, buf);<span class="hljs-comment">//乱码</span><br><br><span class="hljs-comment">//指定长度，后面没有赋值的元素，自动补0</span><br><span class="hljs-keyword">char</span> buf2[<span class="hljs-number">100</span>] = &#123; <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> &#125;;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">1000</span>]=&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf2 = %s\n&quot;</span>, buf2);<br><br><span class="hljs-comment">//所有元素赋值为0</span><br><span class="hljs-keyword">char</span> buf3[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">//char buf4[2] = &#123; &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27; &#125;;//数组越界</span><br><br><span class="hljs-keyword">char</span> buf5[<span class="hljs-number">50</span>] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span> &#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf5 = %s\n&quot;</span>, buf5);<br><br><span class="hljs-keyword">char</span> buf6[<span class="hljs-number">50</span>] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;7&#x27;</span> &#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf6 = %s\n&quot;</span>, buf6);<br><br><span class="hljs-keyword">char</span> buf7[<span class="hljs-number">50</span>] = &#123; <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span> &#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf7 = %s\n&quot;</span>, buf7);<br><br><span class="hljs-comment">//使用字符串初始化，编译器自动在后面补0，常用</span><br><span class="hljs-keyword">char</span> buf8[] = <span class="hljs-string">&quot;agjdslgjlsdjg&quot;</span>;<br><br><span class="hljs-comment">//&#x27;\0&#x27;后面最好不要连着数字，有可能几个数字连起来刚好是一个转义字符</span><br><span class="hljs-comment">//&#x27;\ddd&#x27;八进制转义字符，&#x27;\xdd&#x27;十六进制转义字符</span><br><span class="hljs-comment">// \012相当于\n</span><br><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">&quot;\012abc&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str == %s\n&quot;</span>, str);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>字符串的输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> num[<span class="hljs-number">128</span>];<br><span class="hljs-comment">//%s从键盘读取一个字符串，遇到\n结束（遇到空格也会结束）</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, num);<br><span class="hljs-comment">//printf的第二个参数要的是打印字符数组的首元素地址</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//scanf的缺点：遇到空格就会提前结束读取，如果存放读取字符的空间不足，会造成缓冲区溢出的问题</span><br><span class="hljs-comment">//gets()是一个库函数，可以读取空格，但是也存在缓冲区溢出的问题</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> num[<span class="hljs-number">128</span>] = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-built_in">gets</span>(num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//fgets()</span><br><span class="hljs-comment">//从键盘读取一个字符串</span><br><span class="hljs-comment">//char *fgets(char *s, int size, FILE *stream);</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> num[<span class="hljs-number">128</span>] = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">//注意fgets会把回车键读取</span><br><span class="hljs-built_in">fgets</span>(num, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(num), stdin);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, num);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//fgets()在读取一个用户通过键盘输入的字符串的时候，同时把用户输入的回车也做为字符串的一部分。</span><br><span class="hljs-comment">//通过scanf和gets输入一个字符串的时候，不包含结尾的“\n”，但通过fgets结尾多了“\n”。</span><br><span class="hljs-comment">//fgets()函数是安全的，不存在缓冲区溢出的问题。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如何去掉fgets中的&#x27;\n&#x27;</span><br>i = <span class="hljs-built_in">strlen</span>(buf); <span class="hljs-comment">//strlen()测字符数组中有效字符的个数</span><br>buf[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//字符数组的输出函数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;helloworld&quot;</span>;<br><span class="hljs-built_in">puts</span>(buf); <span class="hljs-comment">//标准设备输出s字符串，在输出完成后自动输出一个&#x27;\n&#x27;。</span><br><span class="hljs-built_in">fputs</span>(buf, stdout); <br>    <span class="hljs-comment">//将str所指定的字符串写入到stream指定的文件中， 字符串结束符 &#x27;\0&#x27;  不写入文件。</span><br>    <span class="hljs-comment">//如果把字符串输出到屏幕，固定写为stdout</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数组就是在内存中连续的相同类型的变量空间。同一个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的。数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>运算符与程序结构</title>
    <link href="http://example.com/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</id>
    <published>2021-06-05T04:08:08.000Z</published>
    <updated>2021-06-05T06:54:20.300Z</updated>
    
    <content type="html"><![CDATA[<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ol><li>在这里不整理了，最重要的一点就是，不确定就加括号。</li></ol><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li><p>数据有不同的类型，不同类型数据之间进行混合运算时必然涉及到类型的转换问题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 转换的方法有两种：<br><span class="hljs-code">（1）自动转换(隐式转换)：遵循一定的规则,由编译系统自动完成。</span><br><span class="hljs-code">（2）强制类型转换：把表达式的运算结果强制转换成所需的数据类型。</span><br><span class="hljs-code">2. 类型转换的原则：占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换，以保证精度不降低。</span><br></code></pre></td></tr></table></figure><p><img src="%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.assets/clip_image002.jpg" alt="2016-06-02_202741"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//隐式转换的例子</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s1=%d\n&quot;</span>, num / <span class="hljs-number">2</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s2=%lf\n&quot;</span>, num / <span class="hljs-number">2.0</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//强制转换的例子</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">float</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>x = <span class="hljs-number">3.6f</span>;<br><br>i = x;<span class="hljs-comment">//x为实型, i为整型，直接赋值会有警告</span><br>i = (<span class="hljs-keyword">int</span>)x;<span class="hljs-comment">//使用强制类型转换</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%f, i=%d\n&quot;</span>, x, i);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;优先级&quot;&gt;&lt;a href=&quot;#优先级&quot; class=&quot;headerlink&quot; title=&quot;优先级&quot;&gt;&lt;/a&gt;优先级&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;在这里不整理了，最重要的一点就是，不确定就加括号。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;类型转换&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="http://example.com/c/"/>
    <id>http://example.com/c/</id>
    <published>2021-06-04T01:30:40.000Z</published>
    <updated>2021-06-05T02:51:57.523Z</updated>
    
    <content type="html"><![CDATA[<h4 id="C程序编译步骤"><a href="#C程序编译步骤" class="headerlink" title="C程序编译步骤"></a>C程序编译步骤</h4><ol><li><p>预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -E hello.c -o hello.i;<br><span class="hljs-comment">//.i文件就是预处理文件</span><br><span class="hljs-comment">//带#的语句就是预处理指令</span><br><span class="hljs-comment">//#include &lt;stdio.h&gt; 包含文件stdio.h，预处理时将stdio.h文件拷贝至预处理文件中--&gt;头文件展开</span><br><span class="hljs-comment">//预处理的时候还会删除注释</span><br><span class="hljs-comment">//宏替换： #define声明一个宏，在预处理时会将宏替代</span><br><span class="hljs-comment">//预处理的时候不会检查语法错误</span><br><span class="hljs-comment">//条件编译：gcc -E hello.c -o hello.i -Dabc</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> abc</span><br><span class="hljs-comment">/*这部分不会被编译*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>编译：检查语法，将预处理后文件编译生成汇编文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -S hello.i -o hello.s;<br></code></pre></td></tr></table></figure></li><li><p>汇编：将汇编文件生成目标文件(二进制文件)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c hello.s -o hello.o;<br></code></pre></td></tr></table></figure></li><li><p>链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc    hello.o -o hello;<br></code></pre></td></tr></table></figure><p><img src="C.assets/clip_image002.png" alt="图片5"></p></li></ol><h4 id="基本程序解释"><a href="#基本程序解释" class="headerlink" title="基本程序解释"></a>基本程序解释</h4><ol><li><p>HelloWorld</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//#预处理指令，在预编译时处理，#include &lt;stdio.h&gt;包含stdio.h文件</span><br><span class="hljs-comment">//main()：main函数也叫主函数，整个程序中只有一个main函数，程序从main函数开始执行</span><br><span class="hljs-comment">//int代表main函数结束之后的返回值类型</span><br><span class="hljs-comment">//return结束这个函数并且返回值，返回值的类型和函数定义时返回值类型一致</span><br><span class="hljs-comment">//printf是一个库函数，printf(params)就是函数调用</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<span class="hljs-comment">//打印到终端</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>system库函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//作用：在程序中启动另一个程序</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">//system在stdlib.h中声明</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">//syetem启动程序，如果这个程序系统可以找到，不用加路径</span><br>        <span class="hljs-comment">//如果环境变量找不到，需要加路径</span><br>        <span class="hljs-comment">//windows路径以 \\ 或 / 分割</span><br>        system(<span class="hljs-string">&quot;mspaint&quot;</span>);<span class="hljs-comment">//启动画图板</span><br>        <span class="hljs-comment">//system(&quot;C:\\Users\\Administrator\\Desktop\\c++13\\hello.exe&quot;);</span><br>        system(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c++13/hello.exe&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello worldfbahfoahfoooooooooooooooooooooo\n&quot;</span>);<span class="hljs-comment">//打印到终端</span><br>      system(<span class="hljs-string">&quot;pause&quot;</span>); <span class="hljs-comment">//pause的作用是等待用户输入任意按键</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="CPU内部结构与寄存器"><a href="#CPU内部结构与寄存器" class="headerlink" title="CPU内部结构与寄存器"></a>CPU内部结构与寄存器</h4><ol><li><p>64位和32位系统区别：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 寄存器是CPU内部最基本的存储单元。<br><span class="hljs-bullet">2.</span> CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，那么这个CPU就叫8位CPU。<br><span class="hljs-bullet">3.</span> 如果总线是32位，寄存器也是32位的，那么这个CPU就是32位CPU。<br><span class="hljs-bullet">4.</span> 有一种CPU内部的寄存器是32位的，但总线是16位，准32位CPU。<br><span class="hljs-bullet">5.</span> 所有的64位CPU兼容32位的指令，32位要兼容16位的指令，所以在64位的CPU上是可以识别32位的指令。<br><span class="hljs-bullet">6.</span> 在64位的CPU构架上运行了64位的软件操作系统，那么这个系统是64位。<br><span class="hljs-bullet">7.</span> 在64位的CPU构架上，运行了32位的软件操作系统，那么这个系统就是32位。<br><span class="hljs-bullet">8.</span> 64位的软件不能运行在32位的CPU之上。<br></code></pre></td></tr></table></figure></li><li><p> 寄存器、缓存、内存三者关系：</p></li></ol>   <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 按与CPU远近来分，离得最近的是寄存器，然后缓存(CPU缓存)，最后内存。<br><span class="hljs-bullet">2.</span> CPU计算时，预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是 CPU&lt;---&gt;寄存器&lt;---&gt;内存，这就是它们之间的信息交换。<br><span class="hljs-bullet">3.</span> 那为什么有缓存呢？内存的访问具有局部性原理，于是就在寄存器与内存之间设置一个缓存提升访问速度。<br></code></pre></td></tr></table></figure><h4 id="VS调试"><a href="#VS调试" class="headerlink" title="VS调试"></a>VS调试</h4><ol><li><p>VS中C语言嵌套汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//定义整型变量a, b, c</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><span class="hljs-keyword">int</span> c;<br><br>__asm<br>&#123;<br>mov a, <span class="hljs-number">3</span><span class="hljs-comment">//3的值放在a对应内存的位置</span><br>mov b, <span class="hljs-number">4</span><span class="hljs-comment">//4的值放在b对应内存的位置</span><br>mov eax, a<span class="hljs-comment">//把a内存的值放在eax寄存器</span><br>add eax, b<span class="hljs-comment">//eax和b相加，结果放在eax</span><br>mov c, eax<span class="hljs-comment">//eax的值放在c中</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,  c);<span class="hljs-comment">//把c的值输出</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//成功完成</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调试的时候设置断点，断点的意义在于使程序运行至断点时停止，使其认为可以控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//逐语句</span><br><span class="hljs-comment">//逐过程</span><br><span class="hljs-comment">//VS community版本少了好多调试窗口，有点可惜</span><br></code></pre></td></tr></table></figure></li><li><p>由于微软在VS2013中不建议再使用C的传统库函数scanf,strcpy,sprintf等，所以直接使用这些库函数会提示C4996错误，要想继续使用此函数，需要在源文件中添加以下指令就可以避免这个错误提示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS     <span class="hljs-comment">//这个宏定义最好要放到.c文件的第一行</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>(disable:4996)<span class="hljs-comment">//或者使用这个</span></span><br></code></pre></td></tr></table></figure></li><li><p>WinExec</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-comment">//在程序中去启动另一个程序并且做到避免终端窗口的弹出</span><br><span class="hljs-built_in">WinExec</span>(<span class="hljs-string">&quot;notepad&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ol><li><p>数据类型的作用：编译器预算对象（变量）分配的内存空间大小。</p><p><img src="C.assets/clip_image002.jpg" alt="2016-06-01_125610"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">数据类型  变量名<br>int    类型     在内存中占        4字节<br>short  类型                     2字节<br>long   类型                     在windows占4字节，Linux32位4字节，64位8字节<br>char   类型                     1字节<br>float  类型                     4字节，一般用来存小数<br>double 类型                     8字节，用来存小数<br></code></pre></td></tr></table></figure></li><li><p>常量：程序运行过程中不能改变的量。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 整型常量100，200，-100，0<br><span class="hljs-bullet">2.</span> 实型常量3.14，0.125，-3.123<br><span class="hljs-bullet">3.</span> 字符型常量 ‘a’,‘b’,‘1’,‘\n’<br><span class="hljs-bullet">4.</span> 字符串常量 “a”，“ab”，“12356”<br></code></pre></td></tr></table></figure></li><li><p>变量：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在程序运行过程中，其值可以改变。<br><span class="hljs-bullet">2.</span> 变量在使用前必须先定义，定义变量前必须有相应的数据类型。<br><span class="hljs-bullet">3.</span> 变量在编译时为其分配相应的内存空间。<br><span class="hljs-bullet">4.</span> 可以通过其名字和地址访问相应内存。<br></code></pre></td></tr></table></figure></li><li><p>变量声明和定义的区别：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 声明变量不需要建立存储空间，如：extern int a;<br><span class="hljs-bullet">2.</span> 定义变量需要建立存储空间，如：int b;<br><span class="hljs-bullet">3.</span> 从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义：<br><span class="hljs-code">（1）int b 它既是声明，同时又是定义。</span><br><span class="hljs-code">（2）对于extern int b来讲它只是声明不是定义。</span><br><span class="hljs-code">4. 一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//extern 关键字只做声明，不能做任何定义</span><br><span class="hljs-comment">//声明一个变量a，a在这里没有建立存储空间</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a;<br>a = <span class="hljs-number">10</span>;<span class="hljs-comment">//err, 没有空间，就不可以赋值</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<span class="hljs-comment">//定义一个变量b，b的类型为int，b赋值为10</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//定义：在内存开辟空间</span><br><span class="hljs-comment">//初始化：定义时赋值</span><br><span class="hljs-comment">//声明：extern告诉编译器有这个东西，但是这里不开辟空间</span><br></code></pre></td></tr></table></figure></li><li><p>const修饰的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//const修饰的变量</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">//const 修饰的变量不能被更改</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a;<span class="hljs-comment">//const修饰的变量a, 不能通过变量名a去修改变量a的内容，可以通过地址修改</span><br>         <span class="hljs-comment">// a = 10;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d\n&quot;</span>,a);<br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><ol><li><p>二进制：注意C语言中不能书写二进制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。</span><br></code></pre></td></tr></table></figure></li><li><p>十进制和二进制之间的转换</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 十进制转二进制：除二取余法。<br><span class="hljs-bullet">2.</span> 二进制转十进制：8421码<br></code></pre></td></tr></table></figure></li><li><p>八进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c语言中书写八进制</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0123</span>;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 十进制转八进制：除N取余法<br><span class="hljs-bullet">2.</span> 八进制转十进制<br><span class="hljs-bullet">3.</span> 八进制转二进制：一个八进制数字转换成三个二进制数字<br><span class="hljs-bullet">4.</span> 二进制转八进制：三个二进制数字转换成一个八进制数字<br></code></pre></td></tr></table></figure></li><li><p>十六进制</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 由0-9，A-F组成，字母不区分大小写。与10进制的对应关系是：0-9对应0-9，A-F对应10-15。<br><span class="hljs-bullet">2.</span> 十六进制的数和二进制数可以按位对应（十六进制一位对应二进制四位）。<br><span class="hljs-bullet">3.</span> 十进制转十六进制：除N取余。<br><span class="hljs-bullet">4.</span> 十六进制数和八进制数以二进制为媒介互相转换。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>;<span class="hljs-comment">//十进制方式赋值</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">0123</span>;<span class="hljs-comment">//八进制方式赋值， 以数字0开头</span><br><span class="hljs-keyword">int</span> c = <span class="hljs-number">0xABC</span>;    <span class="hljs-comment">//十六进制方式赋值</span><br><br><span class="hljs-comment">//如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;十进制：%d\n&quot;</span>,a );<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;八进制：%o\n&quot;</span>, b);<span class="hljs-comment">//%o,为字母o,不是数字</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;十六进制：%x\n&quot;</span>, c);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h4><ol><li><p>有符号数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有符号数是最高位为符号位，0代表正数，1代表负数。<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">-1089474374</span>; <span class="hljs-comment">//定义有符号整型变量a</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%X\n&quot;</span>, a); <span class="hljs-comment">//结果为 BF0FF0BA</span><br><span class="hljs-comment">//B    F    0    F    F    0    B A</span><br><span class="hljs-comment">//1011 1111 0000 1111 1111 0000 1011 1010</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>无符号数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。<br></code></pre></td></tr></table></figure><p><img src="C.assets/clip_image002-1622815397351.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">3236958022</span>; <span class="hljs-comment">//定义无符号整型变量a</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%X\n&quot;</span>, a); <span class="hljs-comment">//结果为 C0F00F46</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="原码、补码和反码"><a href="#原码、补码和反码" class="headerlink" title="原码、补码和反码"></a>原码、补码和反码</h4><ol><li><p>数的范围（其余数据类型同理，注意char也是一种整数类型）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">数据类型   占用空间            取值范围<br>char        1字节        -128到127(-2^7 ~ 2^7-1)<br>unsigned char1字节        0到255(0 ~ 2^8-1)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> ch;<br><span class="hljs-comment">//符号位溢出会导致数的正负发生改变</span><br>ch = <span class="hljs-number">0x7f</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">//127+2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ch);<br><span class="hljs-comment">//0111 1111</span><br><span class="hljs-comment">//+2后 1000 0001，这是负数补码，其原码为 1111 1111，结果为-127</span><br><br><span class="hljs-comment">//最高位的溢出会导致最高位丢失</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ch2;<br>ch2 = <span class="hljs-number">0xff</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">//255+1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, ch2);<br><span class="hljs-comment">//  1111 1111</span><br><span class="hljs-comment">//+1后 10000 0000， char只有8位最高位的溢出，结果为0000 0000，十进制为0</span><br><br>ch2 = <span class="hljs-number">0xff</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">//255+1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, ch2);<br><span class="hljs-comment">//  1111 1111</span><br><span class="hljs-comment">//+1后 10000 0001， char只有8位最高位的溢出，结果为0000 0001，十进制为1</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>原码</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 一个数的原码(原始的二进制码)有如下特点：<br><span class="hljs-code">(1)最高位做为符号位，0表示正，为1表示负。</span><br><span class="hljs-code">(2)其它数值部分就是数值本身绝对值的二进制数。</span><br><span class="hljs-code">(3)负数的原码是在其绝对值的基础上，最高位变为1。</span><br><span class="hljs-code">2. 原码表示法简单易懂，与带符号数本身转换方便，只要符号还原即可，但当两个正数相减或不同符号数相加时，必须比较两个数哪个绝对值大，才能决定谁减谁，才能确定结果是正还是负，所以原码不便于加减运算。</span><br><span class="hljs-code">3. </span><br><span class="hljs-code">-0：    1000 0000</span><br><span class="hljs-code">+0：    0000 0000</span><br><span class="hljs-code">-1：    1000 0001</span><br><span class="hljs-code">1：     0000 0001</span><br><span class="hljs-code">1 + -1？</span><br><span class="hljs-code">0000 0001</span><br><span class="hljs-code">1000 0001</span><br><span class="hljs-code">1000 0010   = -2</span><br><span class="hljs-code">注意：负数如果在计算机中用原码存，会导致两个问题（1）负数运算结果不正确（2）0的状态还有两种</span><br></code></pre></td></tr></table></figure></li><li><p>反码</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 对于正数，反码与原码相同。<br><span class="hljs-bullet">2.</span> 对于负数，符号位不变，其它部分取反(1变0，0变1)。<br><span class="hljs-bullet">3.</span> 反码运算也不方便，通常用来作为求补码的中间过渡。<br><span class="hljs-bullet">4.</span> <br>-0： 1111 1111<br>+0： 0000 0000<br>-1： 1111 1110<br>1：  0000 0001<br>1 + -1 =  1111 1111  = -0<br>如果计算机用反码去存，负数运算结果正确，但是0的状态还是有两种<br></code></pre></td></tr></table></figure></li><li><p>补码</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在计算机系统中，数值一律用补码来存储。<br><span class="hljs-bullet">2.</span> 补码特点：<br><span class="hljs-code">(1)对于正数，原码、反码、补码相同。</span><br><span class="hljs-code">(2)对于负数，其补码为它的反码加1。</span><br><span class="hljs-code">(3)补码符号位不动，其他位求反，最后整个数加1，得到原码。</span><br><span class="hljs-code">3. 补码的意义：</span><br><span class="hljs-code">(1)统一了零的编码。</span><br><span class="hljs-code">(2)将符号位和其它位统一处理。</span><br><span class="hljs-code">(3)将减法运算转变为加法运算。</span><br><span class="hljs-code">(4)两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span>  a = <span class="hljs-number">-15</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>, a);<br><span class="hljs-comment">//结果为 fffffff1</span><br><span class="hljs-comment">//fffffff1对应的二进制：1111 1111 1111 1111 1111 1111 1111 0001</span><br><span class="hljs-comment">//符号位不变，其它取反：1000 0000 0000 0000 0000 0000 0000 1110</span><br><span class="hljs-comment">//上面加1：1000 0000 0000 0000 0000 0000 0000 1111  最高位1代表负数，就是-15 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//赋值时（输入）</span><br><span class="hljs-comment">//赋的是十进制，给的是原码；如果赋值给的是八进制或者十六进制给的是补码</span><br><span class="hljs-comment">//打印时（输出）</span><br><span class="hljs-comment">//十进制打印要的是原码，如果是十六进制或者八进制要的是补码</span><br><span class="hljs-comment">//但是底层存储，用的都是补码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">char</span>  num = <span class="hljs-number">129</span>;<br>        <span class="hljs-comment">//129的原码=反码=补码 = 1000 0001</span><br>        <span class="hljs-comment">//但是num是有符号数，最高位为1，计算机认为这是一个负数的补码</span><br>        <span class="hljs-comment">// 补码如何求原码？</span><br>        <span class="hljs-comment">//补码  1000 0001</span><br>        <span class="hljs-comment">//反码：1111 1110</span><br>        <span class="hljs-comment">//原码： 1111 1111</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num=%d\n&quot;</span>,num);<span class="hljs-comment">//-127</span><br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//练习题</span><br><span class="hljs-keyword">char</span> ch = <span class="hljs-number">0x82</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ch);<br><span class="hljs-comment">//补码：  1000 0010</span><br><span class="hljs-comment">//反码：  1111 1101</span><br><span class="hljs-comment">//原码：  1111 1110  = -126</span><br><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0x80</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,num);<br><span class="hljs-comment">//补码： 1000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="hljs-comment">//反码： 1111 1111 1111 1111 1111 1111 1111 1110 </span><br><span class="hljs-comment">//原码： 1111 1111 1111 1111 1111 1111 1111 1111 = -7fffffff</span><br><br><span class="hljs-keyword">char</span> ch = <span class="hljs-number">-123</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ch);<br><br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0xffffffff</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,num);<br><span class="hljs-comment">//补码： 1111 1111 1111 1111 1111 1111 1111 1111</span><br><span class="hljs-comment">//反码： 1000 0000 0000 0000 0000 0000 0000 0000 </span><br><span class="hljs-comment">//原码:  1000 0000 0000 0000 0000 0000 0000 0001  = -1</span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0xffffffff</span><br></code></pre></td></tr></table></figure><h4 id="整数类型的打印"><a href="#整数类型的打印" class="headerlink" title="整数类型的打印"></a>整数类型的打印</h4></li><li><p>不同进制的输出和打印：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>  a = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">int</span>  b = <span class="hljs-number">056</span>;<br>    <span class="hljs-keyword">int</span>  c = <span class="hljs-number">0xab</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d\n&quot;</span>, a); <span class="hljs-comment">//a=123</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b=%o\n&quot;</span>, b); <span class="hljs-comment">//b=56</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%X\n&quot;</span>, c); <span class="hljs-comment">//c=AB</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c=%#X\n&quot;</span>, c);<span class="hljs-comment">//c=0XAB</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span>  b = <span class="hljs-number">056</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%o\n&quot;</span>, b); <span class="hljs-comment">//a=56</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%X\n&quot;</span>, b); <span class="hljs-comment">//a=2E</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d\n&quot;</span>, b); <span class="hljs-comment">//a=46</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>int类型打印：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">打印格式   含义<br>%d           输出一个有符号的10进制int类型，注意整型提升<br>%o(字母o) 输出8进制的int类型<br>%x  输出16进制的int类型，字母以小写输出<br>%X           输出16进制的int类型，字母以大写输出<br>%u           输出一个10进制的无符号数，注意整型提升<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">0xffffffff</span>; <span class="hljs-comment">//定义无符号int变量d，以16进制方式赋值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有符号方式打印：d = %d\n&quot;</span>, d);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无符号方式打印：d = %u\n&quot;</span>, d);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//有符号方式打印：d = -1</span><br>    <span class="hljs-comment">//无符号方式打印：d = 4294967295</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">char</span> num = <span class="hljs-number">0x81</span>;<br>    <span class="hljs-comment">//存在整型提升,char类型转换成int类型</span><br>    <span class="hljs-comment">//整型提升的过程加上符号扩展</span><br>    <span class="hljs-comment">//最后符号扩展的结果为0xffffff81</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num); <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\n&quot;</span>, num);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//其余类型的整数打印格式</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">short</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">long</span> c = <span class="hljs-number">10l</span>; <span class="hljs-comment">//或者10L</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d = <span class="hljs-number">10ll</span>; <span class="hljs-comment">//或者10LL</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(a) = %u\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(b) = %u\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(b));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(c) = %u\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(c));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(c) = %u\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(d));<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;short a = %hd\n&quot;</span>, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;int b = %d\n&quot;</span>, b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;long c = %ld\n&quot;</span>, c);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;long long d = %lld\n&quot;</span>, d);<br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> a2 = <span class="hljs-number">20u</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> b2 = <span class="hljs-number">20u</span>;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> c2= <span class="hljs-number">20ul</span>; <br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d2 = <span class="hljs-number">20ull</span>; <br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unsigned short a = %hu\n&quot;</span>, a2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unsigned int b = %u\n&quot;</span>, b2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unsigned long c = %lu\n&quot;</span>, c2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unsigned long long d = %llu\n&quot;</span>, d2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h4 id="整型变量的输入"><a href="#整型变量的输入" class="headerlink" title="整型变量的输入"></a>整型变量的输入</h4><ol><li><p>scanf()从键盘（标准输入）读取数据，使用scanf时注意4996的错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>(disable:4996)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入a b的值：&quot;</span>);<br><br><span class="hljs-comment">//不要加“\n”</span><br>    <span class="hljs-comment">//可以一次读取多个值，以空格作为分割</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a); <span class="hljs-comment">//打印a的值</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b); <span class="hljs-comment">//打印a的值</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scanf原理图：</p><p><img src="C.assets/image-20210604235442241.png" alt="image-20210604235442241"></p></li></ol><h4 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h4><ol><li>  short、int、long、long long</li></ol>   <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 需要注意的是，整型数据在内存中占的字节数与所选择的操作系统有关。虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型。<br><span class="hljs-bullet">2.</span> 一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能丢失高位。<br></code></pre></td></tr></table></figure>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> a;<br>    <span class="hljs-keyword">short</span> b;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-keyword">long</span> d;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> e;<br>    <span class="hljs-comment">//sizeof 用来测数据类型的大小</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;long = %d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(d));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(e));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><ol><li><p>字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(‘ ‘)把字符括起来。</p></li><li><p>字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。</p></li><li><p>字符变量的输入和输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//输出</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(ch) = %u\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ch));<br><span class="hljs-comment">//这里c和cpp的判断是不一样的，c是4字节而cpp是1字节</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(&#x27;a&#x27;) = %d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-string">&#x27;A&#x27;</span>));<br>    <span class="hljs-comment">//在c中等价于</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(&#x27;a&#x27;) = %d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-number">97</span>));<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ch[%%c] = %c\n&quot;</span>, ch); <span class="hljs-comment">//打印字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ch[%%d] = %d\n&quot;</span>, ch); <span class="hljs-comment">//打印‘a’ ASCII的值</span><br><br><span class="hljs-keyword">char</span> A = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-keyword">char</span> a = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<span class="hljs-comment">//97</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A = %d\n&quot;</span>, A);<span class="hljs-comment">//65</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A = %c\n&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">32</span>); <span class="hljs-comment">//小写a转大写A</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %c\n&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">32</span>); <span class="hljs-comment">//大写A转小写a</span><br><br>ch = <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;空字符：%d\n&quot;</span>, ch); <span class="hljs-comment">//空字符ASCII的值为32</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A = %c\n&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//小写a转大写A</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %c\n&quot;</span>, <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//大写A转小写a</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//字符转数字</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> ch = <span class="hljs-string">&#x27;8&#x27;</span>;<br><span class="hljs-keyword">int</span> a = ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//输入，从键盘读取多个字符也会有问题</span><br><span class="hljs-comment">//因为scanf会读取换行符</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> ch;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入值：&quot;</span>);<br><span class="hljs-keyword">char</span> c;<br><span class="hljs-comment">//不要加“\n”</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%c&quot;</span>, &amp;ch, &amp;c);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ch = %d\n&quot;</span>, ch); <span class="hljs-comment">//打印ch的字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c = %d\n&quot;</span>, c); <span class="hljs-comment">//打印c的字符</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ol><li><p>由于浮点型变量是由有限的存储单元组成的，因此只能提供有限的有效数字。在有效位以外的数字将被舍去，这样可能会产生一些误差。不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//传统方式赋值</span><br><span class="hljs-keyword">float</span> a = <span class="hljs-number">3.14f</span>; <span class="hljs-comment">//或3.14F</span><br><span class="hljs-keyword">double</span> b = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %f\n&quot;</span>, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %lf\n&quot;</span>, b);<br><br><span class="hljs-comment">//科学法赋值</span><br>a = <span class="hljs-number">3.2e3</span>f; <span class="hljs-comment">//3.2*1000 = 3200，e可以写E</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a1 = %f\n&quot;</span>, a);<br><br>a = <span class="hljs-number">100e-3</span>f; <span class="hljs-comment">//100*0.001 = 0.1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a2 = %f\n&quot;</span>, a);<br><br>a = <span class="hljs-number">3.1415926</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a3 = %f\n&quot;</span>, a); <span class="hljs-comment">//结果为3.141593</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-comment">//打印时,默认输出6位小数点</span><br>        <span class="hljs-comment">//float类型能够保证的精度是7位有效数字</span><br>        <span class="hljs-comment">//double  类型能够保证的精度是15位有效数字</span><br>        <span class="hljs-keyword">float</span> a = <span class="hljs-number">3.1415926456</span>;<br>        <span class="hljs-keyword">double</span> b = <span class="hljs-number">3.1415926456</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%.8f\n&quot;</span>,a);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%.8lf\n&quot;</span>, b);<br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><ol><li>volatile：防止编译器优化。</li><li>register：定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。</li></ol><h4 id="字符串格式化的输入与输出"><a href="#字符串格式化的输入与输出" class="headerlink" title="字符串格式化的输入与输出"></a>字符串格式化的输入与输出</h4><ol><li><p>字符串常量</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 字符串是内存中一段连续的char空间，以&#x27;\0&#x27;(数字0)结尾。<br><span class="hljs-bullet">2.</span> 字符串常量是由双引号括起来的字符序列，如&quot;china&quot;、&quot;C program&quot;，&quot;$12.5&quot;等都是合法的字符串常量。<br><span class="hljs-bullet">3.</span> 每个字符串的结尾，编译器会自动的添加一个结束标志位&#x27;\0&#x27;，即 &quot;a&quot; 包含两个字符&#x27;a&#x27;和&#x27;\0&#x27;。<br></code></pre></td></tr></table></figure></li><li><p>printf函数和putchar函数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> printf的格式字符如下：<br><span class="hljs-code">(1)%dint,接受整数值并将它表示为有符号的十进制整数(整型提升)</span><br><span class="hljs-code">(2)%hdshort int,短整数</span><br><span class="hljs-code">(3)%huunsigned short,无符号短整数</span><br><span class="hljs-code">(4)%ounsigned int,无符号8进制整数(输出对应补码)</span><br><span class="hljs-code">(5)%uunsigned int,无符号10进制整数</span><br><span class="hljs-code">(6)%xunsigned int,无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF(输出对应补码)</span><br><span class="hljs-code">(7)%ffloat,单精度浮点数</span><br><span class="hljs-code">(8)%lfdouble,双精度浮点数</span><br><span class="hljs-code">(9)%edouble,科学计数法表示的数，此处&quot;e&quot;的大小写代表在输出时用的&quot;e&quot;的大小写</span><br><span class="hljs-code">(10)%cchar,字符型,可以把输入的数字按照ASCII码相应转换为对应的字符</span><br><span class="hljs-code">(11)%schar \*,字符串。输出字符串中的字符直至字符串中的空字符（字符串以&#x27;\0‘结尾，这个&#x27;\0&#x27;即空字符）</span><br><span class="hljs-code">(12)%pvoid \*,以16进制形式输出指针</span><br><span class="hljs-code">(13)%%输出一个百分号</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//打印宽度问题</span><br><span class="hljs-comment">//m.n格式，m指的是宽度，n指的是小数点之后的位数</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> abc = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abc = &#x27;%6d&#x27;\n&quot;</span>, abc); <span class="hljs-comment">//abc = &#x27;    10&#x27;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abc = &#x27;%-6d&#x27;\n&quot;</span>, abc); <span class="hljs-comment">//abc = &#x27;10    &#x27;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;abc = &#x27;%06d&#x27;\n&quot;</span>, abc); <span class="hljs-comment">//abc = &#x27;000010&#x27;</span><br><span class="hljs-comment">//printf(&quot;abc = &#x27;%-06d&#x27;\n&quot;, abc); //abc = &#x27;10    &#x27;</span><br><span class="hljs-comment">//左对齐和补0不要一起用</span><br><span class="hljs-keyword">double</span> d = <span class="hljs-number">12.3</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d = \&#x27; %-10.3lf \&#x27;\n&quot;</span>, d); <span class="hljs-comment">//d = &#x27; 12.300     &#x27;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>scanf函数与getchar函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> ch1;<br><span class="hljs-keyword">char</span> ch2;<br><span class="hljs-keyword">char</span> ch3;<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入ch1的字符：&quot;</span>);<br>ch1 = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ch1 = %c\n&quot;</span>, ch1);<br><br><span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//测试此处getchar()的作用</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入ch2的字符：&quot;</span>);<br>ch2 = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\&#x27;ch2 = %ctest\&#x27;\n&quot;</span>, ch2);<br><br><span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//测试此处getchar()的作用</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入ch3的字符：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;ch3);<span class="hljs-comment">//这里第二个参数一定是变量的地址，而不是变量名</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ch3 = %c\n&quot;</span>, ch3);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入a的值：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入b的值：&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b = %d\n&quot;</span>, b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;C程序编译步骤&quot;&gt;&lt;a href=&quot;#C程序编译步骤&quot; class=&quot;headerlink&quot; title=&quot;C程序编译步骤&quot;&gt;&lt;/a&gt;C程序编译步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>进度说明</title>
    <link href="http://example.com/%E8%BF%9B%E5%BA%A6%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/%E8%BF%9B%E5%BA%A6%E8%AF%B4%E6%98%8E/</id>
    <published>2021-06-04T01:30:27.000Z</published>
    <updated>2021-06-04T01:32:33.736Z</updated>
    
    <content type="html"><![CDATA[<p>看书虽然收获比较多，但是进度太慢了，先整几个视频看看，后面继续进度补cpp primer</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看书虽然收获比较多，但是进度太慢了，先整几个视频看看，后面继续进度补cpp primer&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_11_40</title>
    <link href="http://example.com/cpp-primer-11-40/"/>
    <id>http://example.com/cpp-primer-11-40/</id>
    <published>2021-06-03T01:47:56.000Z</published>
    <updated>2021-06-03T03:09:31.419Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ol><li><p>函数指针指向的是函数而非对象。和其它指针一样，函数指针指向某种特定类型。函数的返回类型由它的返回类型和形参共同决定，与函数名无关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较两个string对象的长度</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;, <span class="hljs-keyword">const</span> string &amp;)</span></span>;<br><span class="hljs-comment">//对应的指针类型是</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span>(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;);<br><span class="hljs-comment">//想要声明一个指向函数的指针，只需要用指针替换函数名即可</span><br><span class="hljs-comment">//pf指向一个函数，该函数的参数是两个const string 的引用，返回值是bool类型</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*pf)(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;); <span class="hljs-comment">//未初始化</span><br><span class="hljs-comment">//注意与如下写法做区分</span><br><span class="hljs-comment">//声明一个名为pf的函数，该函数返回bool*</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> *<span class="hljs-title">pf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;, <span class="hljs-keyword">const</span> string &amp;)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>当我们把函数名作为一个值使用的时候，该函数自动的转换成指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//例如，按照如下格式，可以将lengthCompare的地址赋给pf</span><br>pf = lengthCompare; <span class="hljs-comment">//pf指向名为lengthCompare的语句</span><br>pf = &amp;lengthCompare; <span class="hljs-comment">//等价的赋值语句：取地址符是可选的</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//此外，还能直接使用指向函数的指针调用该函数，无须提前解引用指针</span><br><span class="hljs-keyword">bool</span> b1 = <span class="hljs-built_in">pf</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-keyword">bool</span> b2 = (*pf)(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">//一个等价的调用</span><br><span class="hljs-keyword">bool</span> b3 = <span class="hljs-built_in">lengthCompare</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">//另一个等价的调用</span><br></code></pre></td></tr></table></figure></li><li><p>在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个常数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string::size_type <span class="hljs-title">sumLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cstringCompare</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span>*)</span></span>;<br>pf = <span class="hljs-number">0</span>; <span class="hljs-comment">//正确，pf不指向任何函数</span><br>pf = sumLength; <span class="hljs-comment">//错误：返回类型不匹配</span><br>pf = cstringCompare; <span class="hljs-comment">//错误：形参类型不匹配</span><br></code></pre></td></tr></table></figure></li><li><p>当我们使用重载函数时，上下文必须清晰地定义到底应该选用哪个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果定义了指向重载函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)</span></span>;<br><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*pf1)(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) = ff; <span class="hljs-comment">//pf1指向ff(unsigned)</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*pf2)(<span class="hljs-keyword">int</span>) = ff; <span class="hljs-comment">//错误，没有任何一个ff与该形参列表匹配</span><br><span class="hljs-built_in"><span class="hljs-keyword">double</span></span> (*pf3)(<span class="hljs-keyword">int</span> *) = ff; <span class="hljs-comment">//错误，ff和pf3的返回类型不匹配</span><br></code></pre></td></tr></table></figure></li><li><p>函数指针形参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//和数组类似，虽然不能定义函数类型的形参</span><br><span class="hljs-comment">//但是形参可以是指向函数的指针</span><br><span class="hljs-comment">//此时，形参看起来是函数类型，实际上却是当成指针来使用</span><br><span class="hljs-comment">//第三个参数是函数类型，它会自动转换成指向函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s1, <span class="hljs-keyword">const</span> string &amp;s2, <span class="hljs-keyword">bool</span> pf(<span class="hljs-keyword">const</span> string &amp;, <span class="hljs-keyword">const</span> string &amp;))</span></span>;<br><span class="hljs-comment">//等价的声明，显式的将形参定义成指向函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s1, <span class="hljs-keyword">const</span> string &amp;s2, <span class="hljs-keyword">bool</span> (*pf)(<span class="hljs-keyword">const</span> string &amp;, <span class="hljs-keyword">const</span> string &amp;))</span></span>;<br><span class="hljs-comment">//可以直接把函数作为实参使用，他会自动转换为指针</span><br><span class="hljs-built_in">useBigger</span>(s1, s2, lengthCompare);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//直接使用函数指针类型显得冗长而繁琐</span><br><span class="hljs-comment">//使用类型别名和decltype可以简化使用函数的代码</span><br><span class="hljs-comment">//Func和Func2是函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> Func2</span>; <span class="hljs-comment">//等价的类型</span><br><span class="hljs-comment">//FuncP和FuncP2是指向函数的指针</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*FuncP)</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(lengthCompare)</span> *Func2</span>; <span class="hljs-comment">//等价的类型</span><br><span class="hljs-comment">//需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换为指针类型</span><br><span class="hljs-comment">//decltype的结果是函数类型，所以只有在结果前面加上*才能得到指针</span><br><span class="hljs-comment">//可以使用如下形式重新声明useBigger</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;, Func)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">useBigger</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;, FuncP)</span></span>;<br><span class="hljs-comment">//这两个声明语句声明的是同一个函数，在第一条语句中</span><br><span class="hljs-comment">//编译器自动地将Func表示的函数转换成指针</span><br></code></pre></td></tr></table></figure></li><li><p>返回指向函数的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针</span><br><span class="hljs-comment">//必须把返回类型写成指针形式，编译器不会自动将函数返回类型当成对应的指针类型处理</span><br><span class="hljs-comment">//要想声明一个返回函数指针的函数，最简单的办法就是使用类型别名</span><br><span class="hljs-keyword">using</span> F = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">//F是函数类型，不是指针</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)(<span class="hljs-keyword">int</span> *, <span class="hljs-keyword">int</span>); <span class="hljs-comment">//PF是指针类型</span><br><span class="hljs-comment">//显式的将返回类型设定为指针</span><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">//正确：PF是指向函数的指针，f1返回指向函数的指针</span><br><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">//错误，F是函数类型，f1不能返回一个函数</span><br><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">//正确：显式的指定返回类型是指向函数的指针</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*<span class="hljs-built_in">f1</span>(<span class="hljs-keyword">int</span>))(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>);<br><span class="hljs-comment">//从内向外的顺序阅读</span><br><span class="hljs-comment">//f1有形参列表，所以f1是一个函数</span><br><span class="hljs-comment">//f1前面有*，所以f1返回一个指针</span><br><span class="hljs-comment">//指针类型本身也含形参列表，因此指针指向函数，该函数的返回类型是int，形参列表是(int*, int)</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//尾置返回类型声明一个返回函数指针的函数</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> -&gt; <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>将auto和decltype用于函数指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果我们明确知道返回的函数是哪个，就能使用decltype简化书写函数指针返回类型的过程</span><br><span class="hljs-comment">//假定有两个函数，它们的返回类型都是string::size_type，并各自有两个const string&amp;的形参</span><br><span class="hljs-comment">//此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个</span><br><span class="hljs-function">string::size_type <span class="hljs-title">sumLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;)</span></span>;<br><span class="hljs-function">string::size_type <span class="hljs-title">largerLength</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp;, <span class="hljs-keyword">const</span> string&amp;)</span></span>;<br><span class="hljs-comment">//根据其形参的取值，getFcn函数返回指向sumLength或者largerLength的指针</span><br><span class="hljs-keyword">decltype</span>(sumLength) *<span class="hljs-built_in">getFcn</span>(<span class="hljs-keyword">const</span> string&amp;);<br><span class="hljs-comment">//将decltype作用于某个函数时，它返回函数类型而非指针类型</span><br><span class="hljs-comment">//因此，显式地加上*以表明我们需要返回指针，而非函数本身</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.54 编写函数的声明，令其接受两个int形参并且返回类型也是int：然后声明一个vector对象，令其元素是指向该函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br>vector&lt;<span class="hljs-keyword">decltype</span>(func)*&gt; vF;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.55 编写四个函数，分别对两个int执行加、减、乘和除；在上一题创建的vector对象中保存指向这些函数的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">decltype</span>(func1) *p1 = func1, *p2 = func2, *p3 = func3, *p4 = func4;<br>    vector&lt;<span class="hljs-keyword">decltype</span>(func1) *&gt; vF = &#123;p1, p2, p3, p4&#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.56 调用上述vector对象中的每个元素并且输出其结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span>(*p)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>))</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">p</span>(a, b) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">decltype</span>(func1) *p1 = func1, *p2 = func2, *p3 = func3, *p4 = func4;<br>    vector&lt;<span class="hljs-keyword">decltype</span>(func1) *&gt; vF = &#123;p1, p2, p3, p4&#125;;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>, j = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p: vF)&#123;<br>        <span class="hljs-built_in">compute</span>(i, j, p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;函数指针指向的是函数而非对象。和其它指针一样，函数指针指向某种特定类型。函数的返回类型由它的返回类型和形参</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_10_40</title>
    <link href="http://example.com/cpp-primer-10-40/"/>
    <id>http://example.com/cpp-primer-10-40/</id>
    <published>2021-06-02T01:32:34.000Z</published>
    <updated>2021-06-02T13:33:46.984Z</updated>
    
    <content type="html"><![CDATA[<h4 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h4><ol><li><p>一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作用域和重载之间的关系，将暂时违反这一原则而使用局部函数说明。</p></li><li><p>重载对作用域的一般性质没有什么改变：如果我们在内层作用域中声明名字，它将隐藏作用域外边声明的同名实体。在不同的作用域中无法重载函数名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>; <span class="hljs-comment">//重载print函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fooBar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ival)</span></span>&#123;<br>    <span class="hljs-keyword">bool</span> read = <span class="hljs-literal">false</span>; <span class="hljs-comment">//新作用域，隐藏了外层的read</span><br>    string s = <span class="hljs-built_in">read</span>(); <span class="hljs-comment">//错误：read是一个布尔值，而非函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">//新作用域，隐藏了之前的print</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;value&quot;</span>);<span class="hljs-comment">//错误：print(const string &amp;)被隐藏掉了</span><br>    <span class="hljs-built_in">print</span>(ival); <span class="hljs-comment">//正确，当前print(int)可见</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">//正确，调用print(int)，print(double)被隐藏掉了</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在cpp语言中，名字查找发生在类型检查之前，当调用print函数时，编译器首先寻找对该函数名的声明，找的的是接受int值的那个局部声明。一旦在当前作用域中找到了所需的名字。编译器就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。</p></li></ol><h4 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h4><ol><li><p>某些函数有这样一种形参，在函数的很多次调用中它们都被赋予同一个值，此时我们把这个反复出现的值称为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用string对象表示窗口的内容</span><br><span class="hljs-comment">//一般情况下，我们希望该窗口的高、宽和背景字符都使用默认值</span><br><span class="hljs-comment">//同时我们也应该允许用户为这几个参数自由指定与默认值不同的数值</span><br><span class="hljs-comment">//为了使窗口既能接纳默认值，也能接受用户指定的值，我们把它定义成如下形式：</span><br><span class="hljs-keyword">typedef</span> string::size_type sz; <br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz ht = <span class="hljs-number">24</span>, sz wid = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span> backgrnd = <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>可以为一个或者多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p></li><li><p>使用默认实参调用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string window;<br>window = <span class="hljs-built_in">screen</span>(); <span class="hljs-comment">//等价于screen(24, 80, &#x27; &#x27;);</span><br>window = <span class="hljs-built_in">screen</span>(<span class="hljs-number">66</span>); <span class="hljs-comment">//screen(66, 80, &#x27; &#x27;);</span><br>window = <span class="hljs-built_in">screen</span>(<span class="hljs-number">66</span>, <span class="hljs-number">256</span>); <span class="hljs-comment">//screen(66, 256, &#x27; &#x27;);</span><br>window = <span class="hljs-built_in">screen</span>(<span class="hljs-number">66</span>, <span class="hljs-number">256</span>, <span class="hljs-string">&#x27;#&#x27;</span>); <span class="hljs-comment">//screen(66, 256, &#x27;#&#x27;);</span><br></code></pre></td></tr></table></figure></li><li><p>函数调用时，实参按照其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//例如要想覆盖backgrnd的默认值，必须为ht和wid提供实参</span><br>window = <span class="hljs-built_in">screen</span>(, , <span class="hljs-string">&#x27;?&#x27;</span>); <span class="hljs-comment">//错误，只能省略尾部的实参</span><br>window = <span class="hljs-built_in">screen</span>(<span class="hljs-string">&#x27;?&#x27;</span>); <span class="hljs-comment">//相当于调用screen(&#x27;?&#x27;, 80, &#x27; &#x27;);</span><br><span class="hljs-comment">//需要注意，第二个调用传递一个字符值，是合法的调用</span><br><span class="hljs-comment">//该调用之所以合法是因为&#x27;?&#x27;的类型char</span><br><span class="hljs-comment">//而函数最左侧形参的类型是string::size_type，是一种无符号整数类型</span><br><span class="hljs-comment">//所以char类型可以转换成函数最左侧形参的类型</span><br><span class="hljs-comment">//&#x27;?&#x27;对应的十六进制数是0x3F，也就是十进制数的63</span><br><span class="hljs-comment">//所以最终调用相当于screen(63, 80, &#x27; &#x27;);</span><br></code></pre></td></tr></table></figure></li><li><p>当设计含有默认实参的函数时，其中一项任务是合理的设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p></li><li><p>默认实参声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//通常习惯将函数的声明放在头文件中，并且一个函数只声明一次</span><br><span class="hljs-comment">//但是多次声明一个函数也是合法的，不过有一点需要注意</span><br><span class="hljs-comment">//在给定的作用域中一个形参只能被赋予一次默认实参</span><br><span class="hljs-comment">//换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参</span><br><span class="hljs-comment">//而且该形参右侧的所有形参必须有默认值</span><br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">&#x27;&#x27;); //表示高度和宽度的形参没有默认值</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">string screen(sz, sz, char = &#x27;</span>*<span class="hljs-string">&#x27;); //错误，重复声明，不能修改一个已经存在的默认值</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">string screen(sz = 24, sz = 80, char); //正确，添加默认实参</span></span></span><br></code></pre></td></tr></table></figure></li><li><p>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p></li><li><p>默认实参初始值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//局部变量不能做默认实参</span><br><span class="hljs-comment">//除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</span><br><span class="hljs-comment">//wd,def和ht的声明必须出现在函数之外</span><br>sz wd = <span class="hljs-number">80</span>;<br><span class="hljs-keyword">char</span> def = <span class="hljs-string">&#x27; &#x27;</span>;<br>sz = <span class="hljs-built_in">ht</span>();<br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz = ht(), sz = wd, <span class="hljs-keyword">char</span> = def)</span></span>;<br><span class="hljs-comment">//用作默认实参的名字在函数声明的作用域内解析，而这些名字的求值过程发生在函数调用时：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123;<br>    def = <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">//改变了默认实参的值</span><br>    sz wd = <span class="hljs-number">100</span>; <span class="hljs-comment">//隐藏了外层定义的wd，但是没有改变默认值</span><br>    string window = <span class="hljs-built_in">screen</span>(); <span class="hljs-comment">//调用screen(ht(), 80, &#x27;*&#x27;);</span><br>&#125;<br><span class="hljs-comment">//在函数f2内部改变了def的值，所以对screen的调用将会传递这个更新过的值</span><br><span class="hljs-comment">//另一方面，函数还声明了一个局部变量用于隐藏外层的wd</span><br><span class="hljs-comment">//但是该局部变量与传递给screen的默认实参没有任何关系</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.40 下面哪个声明是错误的？为什么？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">(a)int ff(int a, int b = 0, int c = 0);<br>(b)char <span class="hljs-emphasis">* init(int ht = 24, int wd, char bckgrnd);</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在上面的两个声明中，(a)是正确的而(b)是错误的</span><br><span class="hljs-comment">//它们都用到了默认实参，但是cpp规定一旦某个形参被赋予了默认实参</span><br><span class="hljs-comment">//则它后面的所有形参都必须有默认实参，这一规定是为了防范可能出现的二义性</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.41 下面哪个调用是非法的？为什么？哪个调用虽然合法但是与程序员的初衷不符？为什么？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">char <span class="hljs-emphasis">* init(int ht, int wd = 80, char bckgrnd = &#x27;&#x27;);</span><br><span class="hljs-emphasis">(a)init();</span><br><span class="hljs-emphasis">(b)init(24, 10);</span><br><span class="hljs-emphasis">(c)init(14, &#x27;*</span>&#x27;);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//要想使用默认实参，只需要在调用函数时忽略该实参就可以了</span><br><span class="hljs-comment">//实参按照其位置解析，默认实参负责填补函数调用缺少的尾部实参</span><br><span class="hljs-comment">//(a)是非法的，该函数有两个默认实参，但是总计有三个形参，其中第一个形参并未设定默认实参</span><br><span class="hljs-comment">//所以想要调用该函数，至少需要提供一个实参</span><br><span class="hljs-comment">//(b)是合法的，本次调用提供了两个实参</span><br><span class="hljs-comment">//第一个实参对应第一个形参ht，第二个实参对应第二个形参wd，wd的默认实参没有用到</span><br><span class="hljs-comment">//第三个形参bckgrnd使用它的默认实参</span><br><span class="hljs-comment">//(c)在语法上是合法的，但是与程序的原意不符</span><br><span class="hljs-comment">//第二个实参的类型为char，但是它可以自动转换为第二个形参wd所需的int类型，所以编译时可以通过</span><br><span class="hljs-comment">//但是这显然违背了程序的原意，正常情况下，字符*应该被用来构建背景</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.42 给make_plural函数的第二个形参赋予默认实参’s’，利用新版本的函数输出单词success和failure的单数和负数形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于英文单词来说，大多数名词的复数是在单词末尾加上&#x27;s&#x27;</span><br><span class="hljs-comment">//也有一部分名词在单数转变为复数时需要在末尾加上&#x27;es&#x27;</span><br><span class="hljs-comment">//可以把&#x27;s&#x27;作为默认实参，大多数情况下无需考虑这个参数</span><br><span class="hljs-comment">//只有遇到末尾是&#x27;es&#x27;的单词时才专门处理</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//最后一个形参赋予了默认实参</span><br><span class="hljs-function">string <span class="hljs-title">make_plural</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> ctr, <span class="hljs-keyword">const</span> string &amp;word, <span class="hljs-keyword">const</span> string &amp;ending = <span class="hljs-string">&quot;s&quot;</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (ctr &gt; <span class="hljs-number">1</span>) ? word + ending : word;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//一般情况下，调用该函数只需要两个实参</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;success的单数形式是：&quot;</span> &lt;&lt; <span class="hljs-built_in">make_plural</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;success&quot;</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;success的复数形式是：&quot;</span> &lt;&lt; <span class="hljs-built_in">make_plural</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-string">&quot;es&quot;</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;failure的单数形式是：&quot;</span> &lt;&lt; <span class="hljs-built_in">make_plural</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;failure&quot;</span>) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;failure的单数形式是：&quot;</span> &lt;&lt; <span class="hljs-built_in">make_plural</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;failure&quot;</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h4><ol><li><p>调用函数一般比求等价表达式的值慢一些。在大多数机器上，一次函数调用其实包含一系列的工作：调用前要先保存寄存器，并在返回时恢复；可能要拷贝实参；程序转向一个新的位置继续执行。</p></li><li><p>内联函数可以避免函数调用的开销，将函数指定为内联函数，通常是将它在每个调用点上“内联地”展开。假设我们把shorterString函数定义成内联函数，则如下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">shorterString</span>(s1, s2) &lt;&lt; endl;<br><span class="hljs-comment">//在编译过程中展开成类似如下的形式</span><br>cout &lt;&lt; (s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>() ? s1 : s2) &lt;&lt; endl; <span class="hljs-comment">//从而消除shorterString函数的运行时开销</span><br></code></pre></td></tr></table></figure></li><li><p>内联函数的声明方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> string&amp; <span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s1, <span class="hljs-keyword">const</span> string &amp;s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。一般来说，内联机制适用于优化规模比较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数。</p></li><li><p>constexpr函数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> constexpr函数是指能用在常量表达式中的函数。<br><span class="hljs-bullet">2.</span> 定义constexpr函数的方式与其他函数类似，不过要遵循几项规定：<br><span class="hljs-code">（1）函数的返回类型以及所有形参的类型都得是字面值类型。</span><br><span class="hljs-code">（2）函数体中必须有且只有一条return语句。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> foo = <span class="hljs-built_in">new_sz</span>(); <span class="hljs-comment">//正确：foo是一个常量表达式</span><br><span class="hljs-comment">//把new_sz定义成无参数的constexpr函数</span><br><span class="hljs-comment">//因为编译器能在程序编译时验证new_sz函数返回的是常量表达式</span><br><span class="hljs-comment">//所以可以用new_sz函数初始化constexpr类型的变量foo</span><br><span class="hljs-comment">//执行该初始化任务时，编译器把对constexpr函数的调用替换成了其结果值</span><br><span class="hljs-comment">//为了能在编译过程中随时展开，constexpr函数被隐式地指定为了内联函数</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//允许constexpr函数的返回值并非一个常量</span><br><span class="hljs-comment">//如果arg是一个常量表达式，则scale(arg)也是常量表达式</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> cnt * <span class="hljs-built_in">new_sz</span>();<br>&#125;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>)]; <span class="hljs-comment">//正确，scale(2)是常量表达式</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> arr[<span class="hljs-built_in">scale</span>(i)]; <span class="hljs-comment">//错误，scale(i)不是常量表达式</span><br><span class="hljs-comment">//如果我们用一个非常量表达式调用scale函数，比如int类型的对象i</span><br><span class="hljs-comment">//则返回值是一个非常量表达式</span><br><span class="hljs-comment">//当把scale函数用在需要常量表达式上下文中时</span><br><span class="hljs-comment">//由编译器负责检查函数的结果是否符合要求</span><br><span class="hljs-comment">//如果结果恰好不是常量表达式，编译器将发出错误信息</span><br></code></pre></td></tr></table></figure></li><li><p>constexpr函数不一定返回常量表达式。</p></li><li><p>和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器想要展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。</p></li><li><p>练习 6.43 你会把下面的哪个声明和定义放在头文件中？哪个放在源文件中？为什么？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">(a)inline bool eq(const BigInt&amp;, const BigInt&amp;)&#123;...&#125;;<br>(b)void putValues(int <span class="hljs-emphasis">*arr, int size);</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//(a)应该放在头文件中，因为内联函数的定义对编译器而言必须是可见的</span><br><span class="hljs-comment">//以便编译器能够在调用点内联展开该函数的代码，所以仅有函数的原型不够</span><br><span class="hljs-comment">//并且，与一般的函数不同，内联函数有可能在程序中定义不止一次，此时必须保证在所有的源文件中定义完全相同</span><br><span class="hljs-comment">//把内联函数的定义放在头文件中可以确保这一点</span><br><span class="hljs-comment">//(b)是函数声明，应该放在头文件中</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.44 将6.2.2节中的isShorter函数改写成内联函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s1, <span class="hljs-keyword">const</span> string &amp;s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.45 回顾在前面的练习中编写的那些函数，它们应该是内联函数吗？如果是，将他们改写成内联函数，如果不是，说明原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果函数的规模很大不利于展开</span><br><span class="hljs-comment">//或者函数只被调用了一两次，那么这样的函数没必要也不应该是内联函数</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.46 能把isShorter函数定义成constexpr函数吗？如果能，请改写；如果不能，说明原因。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> constexpr函数是指能用于常量表达式的函数，constexpr函数的返回类型和所有形参的类型都得是字面值类型，而且函数体中有且只有一条return语句。<br><span class="hljs-bullet">2.</span> 显然isShorter函数不符合constexpr的要求，它虽然只有一条return语句，但是返回的结果调用了标准库string类的size()函数和&lt;比较符，无法构成常量表达式，因此不能改写成constexpr类型的函数。<br></code></pre></td></tr></table></figure></li></ol><h4 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h4><ol><li><p>cpp程序员有时候会用到一种类似于头文件保护的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序的时候使用。当应用程序编写完成准备发布时，要先屏蔽调试代码。这种方法用到两种预处理功能：assert和NDEBUG。</p></li><li><p>assert预处理宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//assert是一种预处理宏</span><br><span class="hljs-comment">//所谓预处理宏是一种预处理变量，它的行为有点类似于内联函数</span><br><span class="hljs-comment">//assert宏使用一个表达式作为它的条件：</span><br><span class="hljs-built_in">assert</span>(expr);<br><span class="hljs-comment">//首先对表达式求值，如果表达式为假（即0），assert输出信息并终止程序的执行</span><br><span class="hljs-comment">//如果表达式为真（即非0），assert什么也不做</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//assert宏定义在cassert头文件中</span><br><span class="hljs-comment">//预处理名字由预处理器而非编译器管理</span><br><span class="hljs-comment">//因此我们可以直接使用预处理名字而无须提供using声明</span><br><span class="hljs-comment">//也就是说，我们应该使用assert而不是std::assert</span><br><span class="hljs-comment">//也不需要为assert提供using声明</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//和预处理变量一样，宏名字在程序内必须唯一</span><br><span class="hljs-comment">//含有cassert头文件的程序不能再定义名为assert的变量、函数或者其它实体</span><br></code></pre></td></tr></table></figure></li><li><p>assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">assert</span>(word.<span class="hljs-built_in">size</span>() &gt; threshold);<br></code></pre></td></tr></table></figure></li><li><p>NDEBUG预处理变量：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。<br><span class="hljs-bullet">2.</span> 可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：<br><span class="hljs-code">CC -D NDEBUG main.c #这条命令等价于在main.c文件的一开始写#define NDEBUG</span><br><span class="hljs-code">3. 定义NDEBUG能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，assert应该仅用于验证那些确实不可能发生的。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//除了用于assert之外，也可以使用NDEBUG编写自己的条件调试代码</span><br><span class="hljs-comment">//如果NDEBUG未定义，将执行#ifndef和#endif之间的代码</span><br><span class="hljs-comment">//如果定义了，这些代码将被忽略掉</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> sz)</span></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>    <span class="hljs-comment">//_ _func_ _是编译器定义的一个局部静态变量，用于存放函数的名字</span><br>    cout&lt;&lt;_ _func_ _&lt;&lt;<span class="hljs-string">&quot;：array size is &quot;</span> &lt;&lt; sz &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由编译器和预处理器定义的几个对调试程序有用的名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> _ _func_ _，是<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>的一个数组，用于存放函数名字;<br><span class="hljs-number">2.</span> _ _FILE_ _，存放文件名的字符串字面值;<br><span class="hljs-number">3.</span> _ _TIME_ _，存放文件编译时间的字符串字面值;<br><span class="hljs-number">4.</span> _ _DATE_ _，存放文件编译日期的字符串字面值<br></code></pre></td></tr></table></figure></li><li><p>练习 6.47 改写6.3.2练习中使用递归输出vector内容的程序，使其有条件的输出与执行过程有关的信息。例如，每次调用时输出vector对象的大小。分别在打开和关闭调试器的情况下编译并执行这个程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//递归输出vector&lt;int&gt;的内容</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; vInt, <span class="hljs-keyword">unsigned</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> sz = vInt.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//设置在此处输出调试信息</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NDEBUG</span><br>    cout &lt;&lt;<span class="hljs-string">&quot;vector对象的大小是：&quot;</span> &lt;&lt; sz &lt;&lt; endl;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span>(!vInt.<span class="hljs-built_in">empty</span>() &amp;&amp; sz != index)&#123;<br>        cout &lt;&lt; vInt[index] &lt;&lt;endl;<br>        <span class="hljs-built_in">print</span>(vInt, index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-built_in">print</span>(v, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//打开调试器时，每次递归调用print函数都会输出&quot;vector对象的大小是：6&quot;</span><br><span class="hljs-comment">//关闭调试器时，程序只输出vector对象的内容，不再输出其大小</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.48 说明下面这个循环的含义，它对assert的使用合理吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; s &amp;&amp; s != sought)&#123;<br>    <br>&#125;<br><span class="hljs-built_in">assert</span>(cin);<br><span class="hljs-comment">//该程序对assert的使用有不合理之处</span><br><span class="hljs-comment">//在调试器打开的情况下，当用户输入字符串s并且s的内容与sought不相等时，执行循环体</span><br><span class="hljs-comment">//否则继续执行assert(cin);语句</span><br><span class="hljs-comment">//程序执行到assert的原因可能为两种</span><br><span class="hljs-comment">//一是用户终止了输入，二是用户输入的内容正好与sought的内容一样</span><br><span class="hljs-comment">//如果用户尝试终止输入，则assert的条件为假，输出错误信息，这一程序的原意是不相符的</span><br><span class="hljs-comment">//当调试器关闭时，assert什么也不做</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="实参类型转换"><a href="#实参类型转换" class="headerlink" title="实参类型转换"></a>实参类型转换</h4><ol><li><p>在大多数情况下，我们容易确定某次调用应该选用哪个重载函数。然而，当几个重载函数的形参数量相等以及某些形参的类型可以由其它类型转换而来时，匹配正确的重载函数就会变的比较麻烦，如下例所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span> = <span class="hljs-number">3.14</span>)</span></span>;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">5.6</span>); <span class="hljs-comment">//调用void f(double, double)</span><br></code></pre></td></tr></table></figure></li><li><p>确定候选函数和可行函数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 函数匹配的第一步就是选定本次调用对应的重载函数集，集合中的函数称为候选函数。<br><span class="hljs-bullet">2.</span> 候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见，在上面的例子中，有4个名为f的候选函数。<br><span class="hljs-bullet">3.</span> 第二步是考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。<br><span class="hljs-bullet">4.</span> 可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。<br><span class="hljs-bullet">5.</span> 对于上面的例子而言，能根据实参的数量从候选函数中排除掉两个。不使用形参的函数和使用两个int形参的函数显然都不适合本次调用，这是因为调用只提供了一个实参，而它们分别有0个或者两个形参。<br><span class="hljs-bullet">6.</span> 使用一个int形参的函数和使用两个double形参的函数是可行的，它们都能用一个实参调用。需要注意的是，如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参的数量。<br><span class="hljs-bullet">7.</span> 如果没找到可行函数，编译器将报告无匹配函数的错误。<br></code></pre></td></tr></table></figure></li><li><p>寻找最佳匹配：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型和实参类型最匹配的那个可行函数。<br><span class="hljs-bullet">2.</span> “最匹配”的基本思想就是实参类型与形参类型越接近，它们匹配的越好。<br></code></pre></td></tr></table></figure></li><li><p>含有多个形参的函数匹配：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 当实参的数量有两个或者更多时，函数匹配就比较复杂了。假定分析的例子为f(42, 2.56)。<br><span class="hljs-bullet">2.</span> 选择可行函数的方法和只有一个实参时相同，编译器选择那些形参数量满足要求并且实参类型和形参类型能够匹配的函数。此例中，可匹配的函数包括f(int, int)和f(double, double)。接下来，编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且仅有一个函数满足下列条件，则匹配成功。<br><span class="hljs-code">（1）该函数的每个实参的匹配都不劣于其它可行函数需要的匹配。</span><br><span class="hljs-code">（2）至少有一个实参的匹配优于其他可行函数提供的匹配。</span><br><span class="hljs-code">3. 如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的消息。</span><br><span class="hljs-code">4. 对于上面的例子而言，f(int, int)在第一个实参上表现的更好；f(double, double)在第二个实参上表现的更好，编译器最终因为这个调用具有二义性而拒绝其请求。</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.49 什么是候选函数，什么是可行函数？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//见上文</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.50 已知有217页对函数f的声明，对于下面的每一个调用列出可行函数。其中哪个函数是最佳匹配？如果调用不合法，是因为没有可匹配的函数还是因为调用具有二义性？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a) <span class="hljs-built_in">f</span>(<span class="hljs-number">2.56</span>, <span class="hljs-number">42</span>);<br><span class="hljs-comment">//可行函数f(int, int)和f(double, double)</span><br><span class="hljs-comment">//由于调用具有二义性，不合法</span><br>(b) <span class="hljs-built_in">f</span>(<span class="hljs-number">42</span>);<br><span class="hljs-comment">//可行函数f(int)和f(double, double = 3.14)</span><br><span class="hljs-comment">//其中最佳匹配是void f(int)，因为参数无须进行任何转换</span><br>(c) <span class="hljs-built_in">f</span>(<span class="hljs-number">42</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//可行函数是f(int, int)和f(double, double)</span><br><span class="hljs-comment">//最佳匹配是f(int, int)</span><br>(d) <span class="hljs-built_in">f</span>(<span class="hljs-number">2.56</span>, <span class="hljs-number">3.14</span>);<br><span class="hljs-comment">//可行函数是f(int, int)和f(double, double)</span><br><span class="hljs-comment">//最佳匹配是f(double, double)</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.51 对6.50的答案进行验证。</p></li><li><p>为了确定最佳匹配，编辑器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 精确匹配，包括以下情况：<br><span class="hljs-code">（1）实参类型和形参类型一致</span><br><span class="hljs-code">（2）实参从数组类型或函数类型转换成对应的指针类型</span><br><span class="hljs-code">（3）向实参添加顶层const或者从实参删除顶层const</span><br><span class="hljs-code">2. 通过const转换实现的匹配。</span><br><span class="hljs-code">3. 通过类型提升实现的匹配。</span><br><span class="hljs-code">4. 通过算数类型转换或者指针转换实现的匹配。</span><br><span class="hljs-code">5. 通过类类型转换实现的匹配。</span><br></code></pre></td></tr></table></figure></li><li><p>通过类型提升和算数类型转换的匹配：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//小整型一般都会提升到int类型或者更大的整数类型</span><br><span class="hljs-comment">//假设有两个函数，一个接受int，另一个接受short</span><br><span class="hljs-comment">//则只有当函数调用提供的是short类型的值时才会选择short版本的函数</span><br><span class="hljs-comment">//有时候，即使实参是一个很小的整数值，也会直接将其提升成int类型</span><br><span class="hljs-comment">//此时使用short版本反而会导致类型转换</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ff</span><span class="hljs-params">(<span class="hljs-keyword">short</span>)</span></span>;<br><span class="hljs-built_in">ff</span>(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">//char提升成int；调用f(int)</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//所有算数类型转换的级别都一样</span><br><span class="hljs-comment">//从int向unsigned int的转换并不比从int向double转换的级别高</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">float</span>)</span></span>;<br><span class="hljs-built_in">manip</span>(<span class="hljs-number">3.14</span>); <span class="hljs-comment">//错误，二义性调用</span><br><span class="hljs-comment">//double技能转换成long也能转换成float</span><br><span class="hljs-comment">//因为存在两种可能的算数类型转换，所以该调用具有二义性</span><br></code></pre></td></tr></table></figure></li><li><p>函数匹配和const实参：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果重载函数的区别在于它们的引用类型的形参是否引用了const</span><br><span class="hljs-comment">//或者指针类型的形参是否指向const</span><br><span class="hljs-comment">//则当调用发生时编译器通过实参是否是常量来决定选择哪个函数</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>; <span class="hljs-comment">//函数的参数是Account的引用</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">//函数的参数是一个常量引用</span><br><span class="hljs-keyword">const</span> Account a;<br>Account b;<br><span class="hljs-built_in">lookup</span>(a); <span class="hljs-comment">//调用lookup(const Account&amp;)</span><br><span class="hljs-built_in">lookuo</span>(b); <span class="hljs-comment">//调用lookup(Account&amp;)</span><br><span class="hljs-comment">//在第一个调用中，我们传入的是const对象a</span><br><span class="hljs-comment">//因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数就是以常量引用作为形参的函数</span><br><span class="hljs-comment">//调用该函数与实参a精确匹配</span><br><span class="hljs-comment">//在第二个调用中，传入的是非常量对象b</span><br><span class="hljs-comment">//对于这个调用来说，两个函数都是可行的</span><br><span class="hljs-comment">//因为可以使用b初始化常量引用也可以使用b初始化非常量引用</span><br><span class="hljs-comment">//然而用非常量对象初始化常量引用需要类型转换，接受非常量形参的版本则与b精确匹配</span><br><span class="hljs-comment">//因此应该选用非常量版本的函数</span><br></code></pre></td></tr></table></figure></li><li><p>指针类型的形参也类似。如果两个函数的唯一区别是它的指针形参指向常量或者非常量，则编译器能通过实参是否是常量决定选用哪个函数：如果实参是指向常量的指针，选用形参是const type *的函数；如果实参是指向非常量的指针，调用形参是普通指针的函数。</p></li><li><p>练习 6.52 已知有如下声明，请指出下列调用中每个类型转换的等级。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//声明</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manip</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-keyword">double</span> dobj;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">manip</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br><span class="hljs-comment">//发生的参数类型转换是类型提升，字符型实参自动提升为整型</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">manip</span>(<span class="hljs-number">55.4</span>, dobj);<br><span class="hljs-comment">//发生的参数类型转换是算数类型转换，双精度浮点数自动转换成整型。</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.53 说明下列每组声明中的第二条语句会产生什么影响，并指出哪些不合法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">int</span>&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;)</span></span>;<br><span class="hljs-comment">//合法的，两个函数的区别是它们的引用类型的形参是否引用了常量</span><br><span class="hljs-comment">//属于底层const，可以把两个函数区分开来</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">char</span>*, <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)</span></span>;<br><span class="hljs-comment">//底层const可以把两个函数区分开来</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *, <span class="hljs-keyword">char</span> *)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span>, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span>)</span></span>;<br><span class="hljs-comment">//非法的，向实参添加顶层const或者从实参删除顶层const属于精确匹配，无法区分两个函数</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;重载与作用域&quot;&gt;&lt;a href=&quot;#重载与作用域&quot; class=&quot;headerlink&quot; title=&quot;重载与作用域&quot;&gt;&lt;/a&gt;重载与作用域&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作用域和重载之间的关系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_9_40</title>
    <link href="http://example.com/cpp-primer-9-40/"/>
    <id>http://example.com/cpp-primer-9-40/</id>
    <published>2021-06-01T01:30:12.000Z</published>
    <updated>2021-06-01T09:04:55.603Z</updated>
    
    <content type="html"><![CDATA[<h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><ol><li>没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为这类函数的最后一句后面会隐式地执行return。</li><li>一个返回类型是void的函数也能使用return语句的第二种形式，不过此时return语句的expression必须是另一个返回void的函数，强行令void函数返回其它类型的表达式将产生编译错误。</li></ol><h4 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h4><ol><li><p>return语句的返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数的返回类型。</p></li><li><p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p></li><li><p>注意函数返回局部变量时的初始化规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">make_plural</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> ctr, <span class="hljs-keyword">const</span> string &amp;word, <span class="hljs-keyword">const</span> string &amp;ending)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (ctr &gt; <span class="hljs-number">1</span>) ? word + ending : word;<br>&#125;<br><span class="hljs-comment">//该函数的作用而：给定计数值、单词和结束符</span><br><span class="hljs-comment">//判断计数值是否大于1，如果是，返回单词的复数形式；</span><br><span class="hljs-comment">//如果不是，返回单词原型</span><br><span class="hljs-comment">//该函数的返回值类型是string，意味着返回值将被拷贝到调用点</span><br><span class="hljs-comment">//因此该函数将返回一个word的副本或者一个未命名的临时string对象，该对象的内容是word和ending的和</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果函数返回引用，则该引用是它所引对象的一个别名</span><br><span class="hljs-comment">//假定某函数挑出两个string形参中较短的那个并返回其引用</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s1, <span class="hljs-keyword">const</span> string &amp;s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><span class="hljs-comment">//其中形参和返回类型都是const string对象的引用</span><br><span class="hljs-comment">//不管是调用函数还是返回结果都不会真正拷贝string对象</span><br></code></pre></td></tr></table></figure></li><li><p>函数完成后，它所占用的存储空间也随之释放。因此函数终止意味着局部变量的引用将指向不再有效的内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//严重错误，这个函数试图返回局部对象的引用</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> string &amp;<span class="hljs-title">manip</span><span class="hljs-params">()</span></span>&#123;<br>    string ret;<br>    <span class="hljs-keyword">if</span>(!ret.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//错误，返回局部对象的引用</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Empty&quot;</span>; <span class="hljs-comment">//错误，&quot;Empty&quot;是一个局部临时量</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//上面两条return语句都将返回未定义的值</span><br><span class="hljs-comment">//也就是说，试图使用manip函数的返回值将引发未定义的行为</span><br><span class="hljs-comment">//要想确保返回值安全，可以提醒自己一下，引用所引的是在函数之前已经存在的哪个对象？</span><br></code></pre></td></tr></table></figure></li><li><p>返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。</p></li><li><p>返回类类型的函数和调用运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合率</span><br><span class="hljs-comment">//因此如果函数返回指针、引用或者类的对象，就能使用函数调用的结果访问结果对象的成员</span><br><span class="hljs-comment">//例：调用string对象的size成员，该string对象是由shortString函数返回的</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-built_in">shortSting</span>(s1, s2).<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">//因为上面提到的运算符都满足左结合率，所以shortString的结果是点运算符的左侧运算对象</span><br><span class="hljs-comment">//点运算符可以得到该string对象的size成员</span><br><span class="hljs-comment">//size又是第二个调用运算符的左侧运算对象</span><br></code></pre></td></tr></table></figure></li><li><p>引用返回左值：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其它返回类型得到右值。可以像使用其它左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">char</span> &amp;<span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;str, string::size_type ix)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> str[ix]; <span class="hljs-comment">//get_val假定索引值是有效的</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;a value&quot;</span>)</span></span>;<br>    cout &lt;&lt; s &lt;&lt; endl;<br>    <span class="hljs-built_in">get_val</span>(s, <span class="hljs-number">0</span>) = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    cout &lt;&lt; s &lt;&lt;endl; <span class="hljs-comment">//输出A value</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//如果返回类型是常量引用，不能给调用的结果赋值</span><br></code></pre></td></tr></table></figure></li><li><p>列表初始化返回值：cpp11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在下面的函数中，返回一个vector对象，用它存放表示错误信息的string对象</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">process</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//expected和actual是string对象</span><br>    <span class="hljs-keyword">if</span>(expected.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-keyword">return</span> &#123;&#125;; <span class="hljs-comment">//返回一个空vector对象</span><br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(expected == actual)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;funX&quot;</span>, <span class="hljs-string">&quot;okey&quot;</span>&#125;  <span class="hljs-comment">//返回列表初始化的vector对象</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;funx&quot;</span>, actual, expected&#125;;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果函数返回的是内置类型，则花括号包围的列表最多包含一个值</span><br><span class="hljs-comment">//该值所占空间不应该大于目标类型的空间</span><br><span class="hljs-comment">//如果函数返回的是类类型，由类本身定义初始值如何使用</span><br></code></pre></td></tr></table></figure></li><li><p>主函数main的返回值：允许main函数没有return语句直接结束。如果控制达到了main函数的结尾处而且没有return语句，编译器将隐式的插入一条返回0的return语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main函数的返回值可以看作是状态指示器</span><br><span class="hljs-comment">//返回0表示执行成功，返回其它值表示执行失败，其中非0值具体含义依机器而定</span><br><span class="hljs-comment">//为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功和失败</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(some_failure)&#123;<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE; <span class="hljs-comment">//定义在cstdlib头文件中</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> EXIT_SUCCESS; <span class="hljs-comment">//定义在cstdlib头文件中</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//因为它们是预处理变量，所以既不能在前面加上std::，也不能在using声明中出现</span><br></code></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(val &gt; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">factorial</span>(val - <span class="hljs-number">1</span>) * val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.30 编译第200页的str_subrange函数，看看你的编译器是如何处理函数中的错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//编译器发现了一个严重错误，即for循环中的return语句是非法的</span><br><span class="hljs-comment">//函数的返回类型是布尔值，而该条return语句没有任何返回值。</span><br><span class="hljs-comment">//事实上程序还存在另一个严重错误</span><br><span class="hljs-comment">//按照程序的逻辑，for循环有可能不会中途退出而是一直执行完毕</span><br><span class="hljs-comment">//此时显然缺少一条return语句处理这种情况，但是编译器无法发现这种错误</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.31 什么情况下返回的引用无效？什么情况下返回常量的引用有效？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果引用的是函数开始之前就存在的对象，则返回该引用是有效的</span><br><span class="hljs-comment">//如果引用所引的是函数的局部变量，则随着函数结束，局部变量也失效了，此时返回的引用无效</span><br><span class="hljs-comment">//当不希望返回的对象被修改时，返回对常量的引用</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.32 下面的函数合法吗？如果合法，说明其功能；如果不合法，修改其中的错误并解释原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arry, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> arry[index];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;<br>        <span class="hljs-built_in">get</span>(ia, i) = i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//该函数是合法的。get函数接收一个整型指针，该指针实际指向一个整型数组的首元素</span><br><span class="hljs-comment">//另外还接收一个整数表示数组的某个元素</span><br><span class="hljs-comment">//当get函数执行完毕后，调用者得到实参数组arry中索引为index的元素的引用</span><br><span class="hljs-comment">//在main函数中，首先创建一个包含10个整数的数组，名字是ia</span><br><span class="hljs-comment">//由于ia定义在main函数的内部，所以ia不会执行默认初始化操作</span><br><span class="hljs-comment">//如果此时我们直接输出ia每个元素的值，则这些值都是未定义的</span><br><span class="hljs-comment">//进入循环后，每次循环使用get函数得到数组ia中第i个元素的引用，为该引用赋值i</span><br><span class="hljs-comment">//也就是说，为第i个元素赋值i</span><br><span class="hljs-comment">//循环结束时,ia的元素依次被赋值为0~9</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.33 编写一个递归函数，输出vector对象的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; vInt, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> size = vInt.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!vInt.<span class="hljs-built_in">empty</span>() &amp;&amp; index &lt; size)&#123;<br>        cout &lt;&lt; vInt[index]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(vInt, index + <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">print</span>(v, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.34 如果factorial函数的停止条件如下所示，将发生什么情况？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//因为原文中递归函数的参数类型是int</span><br><span class="hljs-comment">//所以理论上用户传入factorial函数的参数可以是负数</span><br><span class="hljs-comment">//按照原程序的逻辑，参数为负数时函数的返回值为1</span><br><span class="hljs-comment">//如果修改条件，则当参数为负时，会依次递归下去直至溢出</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.35 在调用factorial函数时，为什么传入的值是val - 1而不是val–?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果把val - 1变成val--，则出现一种我们不希望看到的情况</span><br><span class="hljs-comment">//即变量的递增操作与读取变量值的操作共存于同一表达式中，这时有可能产生未定义的值</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h4><ol><li><p>因为数组不能被拷贝，所以函数不能返回数组。不过函数可以返回数组的引用或者指针。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这个任务，其中最直接的方法就是使用类型别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">10</span>]; <span class="hljs-comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span><br><span class="hljs-keyword">using</span> arrT = <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//等价写法</span><br><span class="hljs-function">arrT* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;    <span class="hljs-comment">//func返回一个指向含有10个整数的数组的指针</span><br></code></pre></td></tr></table></figure></li><li><p>声明一个返回数组指针的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度</span><br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>]; <span class="hljs-comment">//arr是一个含有10个整数的数组</span><br><span class="hljs-keyword">int</span> *p1[<span class="hljs-number">10</span>]; <span class="hljs-comment">//p1时一个含有10个指针的数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*p2)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">//p2是一个指针，它指向含有10个整数的数组</span><br><span class="hljs-comment">//和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后</span><br><span class="hljs-comment">//然而，函数的形参列表也跟在函数名字之后并且形参列表应该先于数组的维度</span><br><span class="hljs-comment">//因此，返回数组指针的函数形式如下所示：</span><br><span class="hljs-built_in">Type</span> (*<span class="hljs-built_in">function</span>(parameter_list))[dimension];<br><span class="hljs-comment">//类似于其他数组的声明，Type表示元素的类型，dimension表示数组的维度</span><br><span class="hljs-comment">//(*function(parameter_list))两端的括号必须存在</span><br><span class="hljs-comment">//就像我们定义p2时两端必须有括号一样</span><br><span class="hljs-comment">//如果没有这对括号，函数的返回类型将是指针的数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*<span class="hljs-built_in">func</span>(<span class="hljs-keyword">int</span> i))[<span class="hljs-number">10</span>];<br><span class="hljs-comment">//可以按照以下顺序来逐层理解该声明的含义</span><br><span class="hljs-comment">//func(int i)表示调用func函数时需要一个int类型的实参</span><br><span class="hljs-comment">//(*func(int i)) 意味着我们可以对这个函数的结果执行解引用操作</span><br><span class="hljs-comment">//(*func(int i))[10] 表示解引用func的调用将得到一个大小是10的数组</span><br><span class="hljs-comment">//int (*func(int i))[10]表示数组中的元素是int类型</span><br></code></pre></td></tr></table></figure></li><li><p>使用尾置返回类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//任何函数的定义都能使用尾置返回，但是这种类型对于返回类型比较复杂的函数最有效</span><br><span class="hljs-comment">//比如返回类型是数组的指针或者数组的引用</span><br><span class="hljs-comment">//尾置返回类型跟在形参列表后面并以一个 -&gt;符号开头</span><br><span class="hljs-comment">//为了表示函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置一个auto</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> -&gt; <span class="hljs-title">int</span><span class="hljs-params">(*)</span>[10]</span>;<br></code></pre></td></tr></table></figure></li><li><p>使用decltype</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//还有一种情况，如果我们知道函数返回的指针将指向哪个数组</span><br><span class="hljs-comment">//就可以使用decltype关键字声明返回类型</span><br><span class="hljs-comment">//例如：下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个</span><br><span class="hljs-keyword">int</span> odd[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">int</span> even[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;;<br><span class="hljs-keyword">decltype</span>(odd) *<span class="hljs-built_in">arrPtr</span>(<span class="hljs-keyword">int</span> i)&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even; <span class="hljs-comment">//返回一个指向数组的指针</span><br>&#125;<br><span class="hljs-comment">//arrPtr使用关键字decltype表示它的返回类型是个指针</span><br><span class="hljs-comment">//并且该指针所指的对象与odd类型一致，因为odd是数组</span><br><span class="hljs-comment">//所以arrPtr返回一个指向含有五个整数的数组的指针</span><br><span class="hljs-comment">//有一个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是一个数组</span><br><span class="hljs-comment">//要想表示arrPtr返回指针还必须在函数声明时加一个*符号</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.36 编写一个函数的声明，使其返回数组的引用并且该数组包含10个string类型的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">string</span> (&amp;<span class="hljs-built_in">func</span>())[<span class="hljs-number">10</span>];<br><span class="hljs-comment">//func()表示调用该函数无须任何实参</span><br><span class="hljs-comment">//(&amp;func())表示函数的返回结果是一个引用</span><br><span class="hljs-comment">//(&amp;func())[10]表示引用的对象是一个维度为10的数组</span><br><span class="hljs-comment">//string (&amp;func())[10]表示数组的元素是string对象</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.37 使用类型别名、尾置返回类型和decltype关键字重写上一题。说明每种方式的优劣。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//类型别名</span><br><span class="hljs-keyword">typedef</span> string arr[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">using</span> arr = string[<span class="hljs-number">10</span>];<br><span class="hljs-function">arr &amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//尾置返回类型</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">string</span><span class="hljs-params">(&amp;)</span>[10]</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//decltype关键字</span><br>string str[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">decltype</span>(str) &amp;<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></table></figure></li><li><p>练习 6.38 修改arrPtr函数，使其返回数组的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//数组也是一个对象，所以可以定义数组的引用</span><br><span class="hljs-comment">//要想为数组的引用赋值，只要把数组名赋给该引用即可</span><br><span class="hljs-keyword">int</span> odd[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span> even[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-keyword">decltype</span>(odd) &amp;<span class="hljs-built_in">arrPtr</span>(<span class="hljs-keyword">int</span> i)&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? odd : even;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="重载与作用域"><a href="#重载与作用域" class="headerlink" title="重载与作用域"></a>重载与作用域</h4><ol><li><p>如果同一个作用域中的几个函数名字相同但是形参列表不同，我们称之为重载函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span>;<br><span class="hljs-comment">//这些函数接受的形参类型不一样，但是执行的操作非常类似</span><br><span class="hljs-comment">//当调用这些函数时，编译器会根据传递的实惨类型推断想要的是哪个函数</span><br><span class="hljs-keyword">int</span> j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello world&quot;</span>); <span class="hljs-comment">//调用print(const char *cp)</span><br><span class="hljs-built_in">print</span>(j, <span class="hljs-built_in">end</span>(j) - <span class="hljs-built_in">begin</span>(j));<span class="hljs-comment">//调用print(const int *, size_t size)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">begin</span>(j), <span class="hljs-built_in">end</span>(j)); <span class="hljs-comment">//调用print(const int *, const int *)</span><br></code></pre></td></tr></table></figure></li><li><p>main函数不能重载。</p></li><li><p>定义重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//有一种典型的数据库应用，需要创建几个不同的函数分别根据名字、电话、账户号码等信息查找记录</span><br><span class="hljs-comment">//函数重载可以使我们定义一组函数，它们的名字都是lookup，但是查找的依据不同</span><br><span class="hljs-comment">//能通过以下形式的任意一种调用lookup函数</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Name&amp;)</span></span>;<br>Account acct;<br>Phone phone;<br>Record r1 = <span class="hljs-built_in">lookup</span>(acct);<br>Record r2 = <span class="hljs-built_in">lookup</span>(phone);<br></code></pre></td></tr></table></figure></li><li><p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。在上面的代码中，虽然每个函数都只接收一个参数，但是参数的类型不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">//错误，和上一个函数相比只有返回类型不同</span><br></code></pre></td></tr></table></figure></li><li><p>判断两个形参的类型是否相异：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//有时候形参列表看起来不同，但实际上是一致的</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account &amp;acct)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">//省略了形参的名字</span><br><br><span class="hljs-keyword">typedef</span> Phone Telno;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone&amp;)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Telno&amp;)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>重载和const形参</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//顶层const不影响传入函数的对象</span><br><span class="hljs-comment">//一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone)</span></span>; <span class="hljs-comment">//重复声明了Record lookup(Phone)</span><br><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone* <span class="hljs-keyword">const</span>)</span></span>; <span class="hljs-comment">//重复声明</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//另一方面，如果形参是某种类型的指针或者引用</span><br><span class="hljs-comment">//则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account&amp;)</span></span>; <span class="hljs-comment">//函数作用于Account的引用</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account&amp;)</span></span>; <span class="hljs-comment">//新函数，作用于常量引用</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Account*)</span></span>; <span class="hljs-comment">//新函数，作用于指向Account的指针</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Account*)</span></span>; <span class="hljs-comment">//新函数，作用于指向Account的指针</span><br><span class="hljs-comment">//在上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数</span><br><span class="hljs-comment">//因为const不能转换成其它类型，所以我们只能把const对象（或指向const的指针）传递给const形参</span><br><span class="hljs-comment">//相反的，因为非常量可以转换成const</span><br><span class="hljs-comment">//所以上面四个函数都能作用于非常量对象或者指向非常量对象的指针</span><br><span class="hljs-comment">//当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数</span><br></code></pre></td></tr></table></figure></li><li><p>const_cast和重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较两个string对象的长度，返回较短的那个引用</span><br><span class="hljs-function"><span class="hljs-keyword">const</span> string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s1, <span class="hljs-keyword">const</span> string &amp;s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">size</span>() &lt;= s2.<span class="hljs-built_in">size</span>() ? s1 : s2;<br>&#125;<br><span class="hljs-comment">//这个函数的参数和返回类型都是const string的引用</span><br><span class="hljs-comment">//可以对两个非常量的string实参调用这个函数，但返回的结果都是const string的引用</span><br><span class="hljs-comment">//因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用</span><br><span class="hljs-comment">//使用const_cast可以做到这一点</span><br><span class="hljs-function">string &amp;<span class="hljs-title">shorterString</span><span class="hljs-params">(string &amp;s1, string &amp;s2)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = <span class="hljs-built_in">shorterString</span>(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">const</span> string&amp;&gt;(s1),<br>                           <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">const</span> string&amp;&gt;(s2));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const_cast</span>&lt;string&amp;&gt;(r);<br>&#125;<br><span class="hljs-comment">//在这个版本的函数中，首先将它的实参强制转换成了对const的引用</span><br><span class="hljs-comment">//然后调用了shorterString函数的const版本，const版本返回对const string的引用</span><br><span class="hljs-comment">//这个引用事实上绑定在了某个初始的非常量实参上</span><br><span class="hljs-comment">//因此，我们可以将其转换成一个普通的string&amp;，这显然是安全的</span><br></code></pre></td></tr></table></figure></li><li><p>调用重载的函数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 函数匹配是一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定究竟调用哪个函数。<br><span class="hljs-bullet">2.</span> 当调用重载函数时，有三种可能的结果：<br><span class="hljs-code">（1）编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。</span><br><span class="hljs-code">（2）找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。</span><br><span class="hljs-code">（3）有多于一个函数可以匹配，但是每一个都明显不是最佳选择，此时也将发生错误，称为二义性调用。</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.39 说明在下面的每组声明中第二条声明语句是何含义。如果有非法的声明，请指出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-comment">//第二个声明式非法的</span><br><span class="hljs-comment">//它的意图是声明另外一个函数，该函数只接受整型常量作为实参</span><br><span class="hljs-comment">//但是因为顶层const不影响传入函数的对象，所以一个拥有顶层const的形参无法与另一个没有顶层const的形参区分</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//第二个声明是非法的，它的意图是通过函数的返回值区分两个同名的函数</span><br><span class="hljs-comment">//但是这不可行，因为cpp规定重载函数必须在形参数量或形参类型上有所区别。</span><br><span class="hljs-comment">//如果两个同名函数的形参数量和类型都一样，那么即使返回类型不同也不行。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> *<span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *)</span></span>;<span class="hljs-comment">//合法</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;无返回值函数&quot;&gt;&lt;a href=&quot;#无返回值函数&quot; class=&quot;headerlink&quot; title=&quot;无返回值函数&quot;&gt;&lt;/a&gt;无返回值函数&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有r</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_8_40</title>
    <link href="http://example.com/cpp-primer-8-40/"/>
    <id>http://example.com/cpp-primer-8-40/</id>
    <published>2021-05-27T13:22:36.000Z</published>
    <updated>2021-05-31T12:52:52.729Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter6</p><p>函数基础 + 参数传递部分</p><span id="more"></span><h4 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h4><ol><li><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用的函数。此时主调函数的执行被暂时中断，被调函数开始执行。</p></li><li><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管形参和实参之间存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p></li><li><p>实参的类型必须与对应的形参类型匹配（存在类型转换），函数有几个形参，就必须提供相等数量的实参。因为函数的调用规定实参数量应该与形参数量一致，所以形参一定会被初始化。</p></li><li><p>关键字void可以表示函数没有形参，任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p></li><li><p>函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。</p></li><li><p>练习 6.1 实参和形参的区别是什么？ </p></li><li><p>练习 6.2 请指出下列函数哪个有错误，为什么？应该如何修改这些错误呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//(a) 函数体的返回类型是string，函数的返回类型是int，二者类型不同且不能互相转换</span><br><span class="hljs-function">string <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-comment">//(b) 函数缺少返回值类型，如果确实不需要返回值，可以声明返回值类型为void</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-comment">//(c) 形参的名字不能重复，并且函数体左侧的花括号丢失</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span></span>&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-comment">//(d) 函数体必须放在一对花括号之内</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.3 编写阶乘函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(val&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> result;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= val; ++i) &#123;<br>result *= i;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.4 编写一个与用户交互的函数，要求用户输入一个数字，生成计算该数字的阶乘。在main中调用该函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= val; ++i) &#123;<br>result *= i;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个正整数：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">int</span> val;<br>cin &gt;&gt; val;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot;!=&quot;</span> &lt;&lt; <span class="hljs-built_in">fact</span>(val) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.5 编写一个函数，输出其实参的绝对值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//根据参数类型的不同，可以分别求整数的绝对值和浮点数的绝对值</span><br><span class="hljs-comment">//从通用性的角度出发，在这里设置参数类型为浮点数类型</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myABS</span><span class="hljs-params">(<span class="hljs-keyword">double</span> val)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(val);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个数字:&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">double</span> val;<br>cin &gt;&gt; val;<br>cout &lt;&lt; <span class="hljs-string">&quot;该数的绝对值是:&quot;</span> &lt;&lt; <span class="hljs-built_in">myABS</span>(val) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cpp中，名字有作用域，对象有生命周期：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 名字的作用域是程序文本的一部分，名字在其中可见。<br><span class="hljs-bullet">2.</span> 对象的生命周期是程序执行过程中该对象存在的一段时间。<br><span class="hljs-bullet">3.</span> 局部变量：函数是一个语句块，块构成一个新的作用域。形参和函数体内部定义的变量统称为局部变量。它们对函数而言是‘局部’的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。<br><span class="hljs-bullet">4.</span> 在所有函数体之外的定义的对象存在于程序的整个执行过程中。此类对象在程序启动的时候被创建，直到程序结束才被销毁。局部变量的生命周期依赖于定义的方式。<br></code></pre></td></tr></table></figure></li><li><p>自动对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象</span><br><span class="hljs-comment">//当到达定义所在的块末尾时销毁它</span><br><span class="hljs-comment">//自动对象：只存在于块执行期间的对象，当块执行结束后，块中创建的自动对象的值就变成未定义的了</span><br><span class="hljs-comment">//形参是一种自动对象，函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内</span><br><span class="hljs-comment">//所以一旦函数终止，形参也被销毁</span><br><span class="hljs-comment">//用传递给函数的实参初始化形参对应的自动对象。对于局部变量对应的自动对象来说，分为两种情况</span><br><span class="hljs-comment">//（1）如果变量定义本身含有初始值，就用这个初始值进行初始化</span><br><span class="hljs-comment">//（2）如果变量定义本身不含初始值，执行默认初始化，这意味着内置类型的未初始化局部变量将产生未定义的值</span><br></code></pre></td></tr></table></figure></li><li><p>局部静态对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。</span><br><span class="hljs-comment">//可以将局部变量定义成static类型从而获得这样的对象。</span><br><span class="hljs-comment">//局部静态对象：在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁</span><br><span class="hljs-comment">//在此期间即使对象所在的函数结束执行也不会对它有什么影响</span><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">count_calls</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> ctr = <span class="hljs-number">0</span>; <span class="hljs-comment">//调用结束后，这个值仍然有效</span><br>    <span class="hljs-keyword">return</span> ++ctr;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> times = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != times; ++i)&#123;<br>        cout&lt;&lt;<span class="hljs-built_in">count_calls</span>()&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0，每次调用将ctr加1并返回新值</span><br><span class="hljs-comment">//每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出ctr时的值</span><br><span class="hljs-comment">//如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量被初始化为0</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.6 说明形参、局部变量以及静态局部变量的区别。编写一个函数，同时用到这三种形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myADD</span><span class="hljs-params">(<span class="hljs-keyword">double</span> v1, <span class="hljs-keyword">double</span> v2)</span> </span>&#123; <span class="hljs-comment">//v1和v2是形参</span><br><span class="hljs-keyword">double</span> result = v1 + v2; <span class="hljs-comment">//result是局部变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//count是静态局部变量</span><br>++count;<br>cout &lt;&lt; <span class="hljs-string">&quot;该函数已经累计执行了&quot;</span> &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot;次&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">double</span> v1, v2;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个数：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; v1 &gt;&gt; v2) &#123;<br>cout &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot;和&quot;</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-string">&quot;的和为&quot;</span> &lt;&lt; <span class="hljs-built_in">myADD</span>(v1, v2) &lt;&lt; endl;<br><span class="hljs-keyword">char</span> ch;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续(y or n)&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; ch;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个数：&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.7 编写一个函数，当它第一次被调用时返回0，以后每次被调用返回值加1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//上面的函数可以完成这个功能</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><ol><li><p>函数的名字必须在使用之前声明，类似于变量，函数只能定义一次，但可以声明多次。</p></li><li><p>函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号代替即可。</p></li><li><p>因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常忽略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好的理解函数的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator beg,</span></span><br><span class="hljs-params"><span class="hljs-function">           vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator end)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>函数的三要素（返回类型，函数名，参数类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型。</p></li><li><p>建议函数在头文件中声明而在源文件中定义。因为把函数声明放在头文件中，就能确保同一函数的所有声明保持一致。而且一旦我们想改变函数的接口，只需要改变一条声明即可。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p></li><li><p>练习 6.8 编写一个名为chapter6.h的头文件，令其包含6.1节练习中的函数声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> CHAPTER6_H_INCLUDED</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHAPTER6_H_INCLUDED</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myABS</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myABS2</span><span class="hljs-params">(<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>)</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// !CHAPTER6_H_INCLUDED</span></span><br><span class="hljs-comment">//函数声明的方式和函数定义的方式非常类似，唯一的区别就是函数声明无须函数体，可以不用声明形参名</span><br><span class="hljs-comment">//函数应该在头文件中声明而在源文件中定义</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h4><ol><li><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p></li><li><p>假设fact函数的定义位于一个名为fact.cc的文件中，它的声明位于名为chapter6.h的头文件中，显然与其他所有用到fact函数的文件一样，fact.cc应该包含chapter6.h头文件中。另外我们要在名为factMain.cc的文件中创建main函数，main函数将调用fact函数。要生成可执行文件，必须告诉编译器我们用到的代码在哪里。</p></li><li><p>如果修改了其中一个源文件，那么只需要重新编译那个改动了的文件，大多数编译器提供分离式编译每个文件的机制，这一过程通常会产生一个后缀名为.obj或.o的文件，后缀名的含义是该文件包含对象代码。编译器负责把对象文件链接在一起形成可执行文件。</p></li><li><p>练习 6.9 编写自己的fact.cc和factMain.cc，这两个文件都应该包含上一小节的练习中编写的chapter6.h头文件，通过这些文件，理解你的编译器是如何支持分离式编译的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//fact.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;chapter6.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (val &gt; <span class="hljs-number">1</span>) &#123;<br>result *= val;<br>--val;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//factMain.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;chapter6.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">fact</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h4><ol><li><p>和其它的类型一样，形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p></li><li><p>当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。和其它引用一样，引用形参也是它绑定的对象的别名。也就是说，引用形参是它对应实参的别名。</p></li><li><p>当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。</p></li><li><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。</p></li><li><p>指针的行为和其它非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接的访问它所指向的对象，所以可以通过指针修改它所指的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *ip)</span></span>&#123;<br>    *ip = <span class="hljs-number">0</span>; <span class="hljs-comment">//改变指针ip所指对象的值</span><br>     ip = <span class="hljs-number">0</span>; <span class="hljs-comment">//只改变了ip的局部拷贝，实参未被改变</span><br>&#125;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">reset</span>(&amp;i);<br>cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">//输出i = 0</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.10 编写一个函数，使用指针形参交换两个整数的值。在代码中调用该函数并输出交换后的结果，以此验证函数的正确性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;practice6_10.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> v1 = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> v2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1 = &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; v2 = &quot;</span> &lt;&lt; v2 &lt;&lt; endl;;<br><span class="hljs-built_in">swap</span>(&amp;v1, &amp;v2);<br>cout &lt;&lt; <span class="hljs-string">&quot;v1 = &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">&quot; v2 = &quot;</span> &lt;&lt; v2 &lt;&lt; endl;;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* p1, <span class="hljs-keyword">int</span>* p2)</span> </span>&#123;<br><span class="hljs-keyword">int</span> tmp = *p1;<br>*p1 = *p2;<br>*p2 = tmp;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h4><ol><li><p>对于引用的操作实际上是作用在引用所引的对象上。引用形参的行为与之类似。通过使用引用形参，允许函数改变一个或多个实参的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i)</span></span>&#123; <span class="hljs-comment">//i是传给reset函数的对象的另一个名字</span><br>    i = <span class="hljs-number">0</span>; <span class="hljs-comment">//改变了i所引对象的值</span><br>&#125;<br><span class="hljs-comment">//和其他引用一样，引用形参绑定初始化它的对象</span><br><span class="hljs-comment">//当调用这一版本的reset函数时，i绑定我们传给函数的int对象</span><br><span class="hljs-comment">//此时改变i也就是改变i所引用对象的值</span><br><span class="hljs-comment">//此例中，被改变的对象是传入reset的实参</span><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">reset</span>(j);<br>cout &lt;&lt; <span class="hljs-string">&quot;j = &quot;</span> &lt;&lt; j &lt;&lt;endl; <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure></li><li><p>使用引用避免拷贝</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作的时候，函数只能通过引用形参访问该类型的对象。<br><span class="hljs-bullet">2.</span> 举个例子，我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该尽量避免直接拷贝它们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，所以把形参定义成对常量的引用：<br>bool isShorter(const string &amp;s1, const string &amp;s2)&#123;<br><span class="hljs-code">return s1.size() &lt; s2.size();</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">3. 如果函数无需改变引用形参的值，最好将其声明为常量引用。</span><br></code></pre></td></tr></table></figure></li><li><p>使用引用形参返回额外的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//一个函数只能返回一个值，然后有时函数需要返回多个值</span><br><span class="hljs-comment">//可以使用引用形参一次返回多个值</span><br><span class="hljs-comment">//例：定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出现的位置</span><br><span class="hljs-comment">//同时我们也希望函数能返回该字符出现的总次数。</span><br><span class="hljs-comment">//第一种思路是定义一个新的数据结构，让他包含位置和数量两个成员</span><br><span class="hljs-comment">//第二种思路是给函数传一个额外的引用实参，令其保存字符出现的次数</span><br><span class="hljs-function">string::size_type <span class="hljs-title">find_char</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s, <span class="hljs-keyword">char</span> c,</span></span><br><span class="hljs-params"><span class="hljs-function">                           string::size_type &amp;occurs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> ret = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//第一次出现的位置</span><br>    occurs = <span class="hljs-number">0</span>；<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">decltype</span>(ret) i = <span class="hljs-number">0</span> ; i != s.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>        <span class="hljs-keyword">if</span>(s[i] == c)&#123;<br>            <span class="hljs-keyword">if</span>(ret == s.<span class="hljs-built_in">size</span>())&#123;<br>                ret = i; <span class="hljs-comment">//记录第一次出现的位置</span><br>            &#125;<br>            ++occurs; <span class="hljs-comment">//将出现的次数加1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-keyword">auto</span> index = <span class="hljs-built_in">find_char</span>(s, <span class="hljs-string">&#x27;o&#x27;</span>, ctr);<br><span class="hljs-comment">//调用完成后，如果string对象中确实存在o，那么ctr的值就是o出现的次数</span><br><span class="hljs-comment">//index指向o第一次出现的位置</span><br><span class="hljs-comment">//如果string对象中没有o，index等于s.size()而ctr等于0</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.11 编写并验证你自己的reset函数，使其作用于引用类型的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i)</span></span>&#123;<br>    i = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;重置前：j = &quot;</span>&lt;&lt; j &lt;&lt;endl;<br>    <span class="hljs-built_in">reset</span>(j);<br>    cout &lt;&lt; <span class="hljs-string">&quot;重置前：j = &quot;</span>&lt;&lt; j &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.12 改写练习6.10的程序，使用引用而非指针交换两个整数的值，你觉得哪种方法更容易使用呢？为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;i, <span class="hljs-keyword">int</span> &amp;j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = i;<br>    i = j;<br>    j = tmp;<br>&#125;<br><span class="hljs-comment">//与使用指针相比，使用引用交换变量的内容从形式上看更简单一些</span><br><span class="hljs-comment">//无须额外声明指针变量，避免了拷贝指针的值</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.13 假设T是某种类型的名字，说明以下两个函数声明的区别：一个是void f(T)，另一个是void f(&amp;T)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//void f(T)的形参采用的是传值的方式</span><br><span class="hljs-comment">//也就是说，实参的值被拷贝给形参，形参和实参是两个独立的变量</span><br><span class="hljs-comment">//在函数内部对形参所做的任何变动都不会影响实参的值</span><br><span class="hljs-comment">//void f(&amp;T)的形参采用的是传引用的方式</span><br><span class="hljs-comment">//此时形参是对应实参的别名</span><br><span class="hljs-comment">//形参绑定到初始化它的对象</span><br><span class="hljs-comment">//如果我们改变了形参的值，也就是改变了对应实参的值</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.14 举一个形参应该是引用类型的例子，再举一个形参不能是引用类型的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//与值传递相比，引用传递的优势主要体现在三个方面</span><br><span class="hljs-comment">//（1）直接操作引用形参所引的对象</span><br><span class="hljs-comment">//（2）使用引用形参可以避免拷贝大的类类型对象或容器类型对象</span><br><span class="hljs-comment">//（3）使用引用形参可以帮助我们从函数中返回多个值</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.15  说明find_char函数中三个形参为什么是现在的类型，特别说明为什么s是常量引用而occurs是普通引用？为什么s和occurs是引用类型而c不是？如果令s是普通引用会发生什么情况?如果令occurs是常量引用会发生什么情况？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 对于待查找的字符串s来说，为了避免拷贝长字符串，使用引用类型；同时我们只执行查找操作。无须改变字符串的内容，所以将其声明为常量引用。<br><span class="hljs-bullet">2.</span> 对于待查找的字符c来说，它的类型是char，只占1字节，拷贝的代价很低。而且我们无需操作实参在内存中实际存储的内容，所以不需要使用引用类型。<br><span class="hljs-bullet">3.</span> 对于字符出现的次数occurs来说，因为需要把函数内对实参值的更改反应在函数的外部，所以必须将其定义称为引用类型，但是不能把它定义成常量引用，否则就不能改变所引的内容了。<br></code></pre></td></tr></table></figure></li></ol><h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h4><ol><li><p>顶层const作用于对象本身：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">42</span>; <span class="hljs-comment">//不能改变ci，const是顶层的</span><br><span class="hljs-keyword">int</span> i = ci; <span class="hljs-comment">//正确：当拷贝ci时，忽略了它的顶层const</span><br><span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p = &amp;i; <span class="hljs-comment">//const是顶层的，不能给p赋值</span><br>*p = <span class="hljs-number">0</span>; <span class="hljs-comment">//正确：通过p改变对象的内容是允许的，现在i变成了0</span><br></code></pre></td></tr></table></figure></li><li><p>与其它初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">/*func能够读取i，但是不能向i写值*/</span>&#125;<br><span class="hljs-comment">//调用func函数时，既可以传入const int也可以传入int</span><br><span class="hljs-comment">//忽略掉形参的顶层const可能产生意想不到的效果</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i)</span></span>&#123; <span class="hljs-comment">/*func能够读取i，但是不能像i写值*/</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-comment">/*...*/</span>&#125; <span class="hljs-comment">//错误：重复定义了func(int)</span><br><span class="hljs-comment">//在cpp语言中，允许重载函数</span><br><span class="hljs-comment">//前提是不同函数的形参列表应该有明显的区别</span><br><span class="hljs-comment">//因为顶层const被忽略掉了，所以在上面的代码中传入两个func函数的参数可以完全一样</span><br><span class="hljs-comment">//因此第二个func是错误的</span><br><span class="hljs-comment">//尽管形式上是有差异的，但实际上它的形参和第一个func的形参没什么不同</span><br></code></pre></td></tr></table></figure></li><li><p>指针或引用形参与const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//形参的初始化方式和变量的初始化方式是一样的</span><br><span class="hljs-comment">//可以使用非常量初始化一个底层const对象，但是反过来不行</span><br><span class="hljs-comment">//同时一个普通的引用必须用同类型的对象初始化</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *cp = &amp;i; <span class="hljs-comment">// 正确，但是不能通过cp改变i</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = i; <span class="hljs-comment">//正确，但是不能通过r改变i</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">int</span> *p = cp; <span class="hljs-comment">//错误，p的类型和cp的类型不匹配</span><br><span class="hljs-keyword">int</span> &amp;r3 = r; <span class="hljs-comment">//错误，r3的类型和r的类型不匹配</span><br><span class="hljs-keyword">int</span> &amp;r4 = <span class="hljs-number">42</span>; <span class="hljs-comment">//错误，不能用字面值初始化一个非常量引用</span><br><span class="hljs-comment">//将同样的初始化规则应用到参数传递上可得如下形式：</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i;<br>string::size_type ctr = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">reset</span>(&amp;i); <span class="hljs-comment">//调用形参类型是int *的reset函数</span><br><span class="hljs-built_in">reset</span>(&amp;ci); <span class="hljs-comment">//错误：不能用指向const int对象的指针初始化int *</span><br><span class="hljs-built_in">reset</span>(i); <span class="hljs-comment">//调用形参类型是int&amp;的reset的函数</span><br><span class="hljs-built_in">reset</span>(ci); <span class="hljs-comment">//错误：不能把普通引用绑定到const对象ci上</span><br><span class="hljs-built_in">reset</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">//错误：不能把普通应用绑定到字面值上</span><br><span class="hljs-built_in">reset</span>(ctr);<span class="hljs-comment">//错误：类型不匹配，ctr是无符号类型</span><br><span class="hljs-comment">//正确，find_char的第一个形参是对常量的引用</span><br><span class="hljs-built_in">find_char</span>(<span class="hljs-string">&quot;hello World&quot;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, ctr);<br></code></pre></td></tr></table></figure></li><li><p>尽量使用常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//把函数不会改变的形参定义成普通的引用是一种比较常见的错误</span><br><span class="hljs-comment">//这么做带给函数的调用者一种误导，即函数可以修改它的实参的值</span><br><span class="hljs-comment">//此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。</span><br><span class="hljs-comment">//就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_sentence</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s)</span></span>&#123;<br>    <span class="hljs-comment">//如果在s的末尾有且只有一个句号，则s是一个句子</span><br>    string::size_type ctr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find_char</span>(s, <span class="hljs-string">&#x27;.&#x27;</span>, ctr) == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; ctr == <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//如果find_char的第一个形参类型是string&amp;，那么上面这条调用find_char的语句将在编译时发生错误</span><br><span class="hljs-comment">//原因是s是常量引用，但find_char被定义成只能接受普通引用</span><br><span class="hljs-comment">//如果实在不能修改find_char，就在is_sentence内部定义一个string类型的变量</span><br><span class="hljs-comment">//令其为s的副本，然后把这个string对象传递给find_char</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.16 下面这个函数虽然合法，但是不算特别有用。指出它的局限性并设法改善：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(string &amp;s)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">empty</span>();<br>&#125;<br><span class="hljs-comment">//本题的程序把参数类型设置为非常量引用，这样做有几个缺陷：</span><br><span class="hljs-comment">//(1)容易给使用者一种误导，即程序允许修改变量s的内容</span><br><span class="hljs-comment">//(2)限制了函数所能接收的实参类型，无法把const对象、字面值常量或需要进行类型转换的对象传递给普通的引用形参</span><br><span class="hljs-comment">//修改如下：</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.17 编写一个函数，判断string对象中是否含有大写字母。编写另一个函数，把string对象全部改成小写形式。在这两个函数中你使用的形参类型相同吗？为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一个函数的任务是判断string对象中是否含有大写字母，无须修改参数内容，因此将其设为常量引用类型</span><br><span class="hljs-comment">//第二个函数需要修改参数的内容，所以将其设为普通的引用</span><br><span class="hljs-comment">//第一个函数的实现：</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">HasUpper</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;str)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : str)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isupper</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//第二个函数的实现：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ChangeToLower</span><span class="hljs-params">(string &amp;s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : s)&#123;<br>        c = <span class="hljs-built_in">tolower</span>(c);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入一个字符串&quot;</span> &lt;&lt; endl;<br>    string str;<br>    cin &gt;&gt; str;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">HasUpper</span>(str))&#123;<br>        <span class="hljs-built_in">ChangeToLower</span>(str);<br>        cout &lt;&lt; <span class="hljs-string">&quot;装换之后的字符是：&quot;</span>&lt;&lt; str &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;该字符串不含大写字母，无须转换&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.18 为下面的函数编写函数声明，从给定的名字中推测函数具有的功能？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a)名为compare的函数，返回布尔值，两个参数都是matrix的引用<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> matrix&amp;, <span class="hljs-keyword">const</span> matrix&amp;)</span></span>;<br>(b)名为change_val的函数，返回vector&lt;<span class="hljs-keyword">int</span>&gt;的迭代器，有两个参数：一个是<span class="hljs-keyword">int</span>，另一个是vector&lt;<span class="hljs-keyword">int</span>&gt;的迭代器<br>    vector&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-function">iterator <span class="hljs-title">change_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.19 假定有如下声明，判断哪个调用合法，哪个调用不合法。对于不合法的函数调用，说明原因：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//(a)是非法的，函数的声明只包含一个参数，而函数的调用提供了两个参数，因此无法编译通过</span><br><span class="hljs-comment">//(b)合法的，字面值常量可以初始化常量引用形参</span><br><span class="hljs-comment">//(c)合法，可以进行类型转换</span><br><span class="hljs-comment">//(d)合法</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.20  引用形参什么时候应该是常量引用？如果形参应该是常量引用，而我们将其设为了普通引用，会发生什么情况？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//参见6.16答案</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h4><ol><li><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组以及使用数组时会将其转换成指针。因为不能拷贝数组，所以我们无法使用值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的时指向数组首元素的指针。</p></li><li><p>尽管不能以值传递的方式传递数组，但是可以把形参写成类似数组的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//尽管形式不同，但这三个print函数是等价的</span><br><span class="hljs-comment">//每个函数都有一个const int*类型的形参</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>[])</span></span>;<br><span class="hljs-comment">//这里的维度实际上是期望数组含有多少元素，实际上不一定</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>; <br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">print</span>(&amp;i); <span class="hljs-comment">//正确：&amp;i的类型是int *</span><br><span class="hljs-built_in">print</span>(j); <span class="hljs-comment">//正确，j转换成int*并指向j[0]</span><br></code></pre></td></tr></table></figure></li><li><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息，管理指针形参有三种常用的技术。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用标记指定数组的长度</span><br><span class="hljs-comment">//要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串</span><br><span class="hljs-comment">//C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符</span><br><span class="hljs-comment">//函数在处理C风格字符串时遇到空字符停止</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(*cp)&#123; <span class="hljs-comment">//检查cp是不是一个空指针</span><br>        <span class="hljs-keyword">while</span>(*cp)&#123; <span class="hljs-comment">//检查指针所指字符是不是空字符</span><br>            cout &lt;&lt; *cp++;  <span class="hljs-comment">//输出当前字符并将指针向前移动一个位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用标准库规范</span><br><span class="hljs-comment">//传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发</span><br><span class="hljs-comment">//使用该方法，可以按照如下形式输出元素内容</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(beg != end)&#123;<br>        cout&lt;&lt;*beg ++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//显式传递一个表示数组大小的形参</span><br><span class="hljs-comment">//const int ia[]等价于const int *ia</span><br><span class="hljs-comment">//size表示数组的大小，将它显式地传给函数用于控制对ia元素的访问</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != size; i++)&#123;<br>        cout &lt;&lt; ia[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数形参和const：当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。</p></li><li><p>数组引用形参：函数的形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem : arr)&#123;<br>        cout&lt;&lt;elem&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//int &amp;arr[10]; 这里arr指的是引用的数组</span><br><span class="hljs-comment">//int (&amp;arr)[10]; //arr是具有10个整数的整型数组的引用</span><br><span class="hljs-comment">//这一用法会限制print函数的可用性，只能将函数作用于大小为10的数组</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span> , <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">int</span> k[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> , <span class="hljs-number">9</span>&#125;;<br><span class="hljs-built_in">print</span>(&amp;i); <span class="hljs-comment">//错误</span><br><span class="hljs-built_in">print</span>(j); <span class="hljs-comment">//错误</span><br><span class="hljs-built_in">print</span>(k); <span class="hljs-comment">//正确，实参是含有10个整数的数组</span><br></code></pre></td></tr></table></figure></li><li><p>传递多维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp中没有真正的多维数组，所谓多维数组都是数组的数组</span><br><span class="hljs-comment">//和所有数组一样，当将多维数组传递给函数的时候，真正传递的是指向数组首元素的指针</span><br><span class="hljs-comment">//因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针</span><br><span class="hljs-comment">//数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能忽略</span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-keyword">int</span> rowSize)&#123;<br>    <span class="hljs-comment">/*matrix是指向含有10个整数的数组的指针*/</span><br>&#125;<br><span class="hljs-comment">//也可以使用数组的语法定义函数，编译器会一如既往的忽略掉第一个维度</span><br><span class="hljs-comment">//所以最好不要把它包括在形参列表里</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> matrix[][<span class="hljs-number">10</span>], <span class="hljs-keyword">int</span> rowSize)</span></span>&#123;<br>    <span class="hljs-comment">/*matrix的声明看起来像一个二维数组，实际上形参是指向含有10个整数的数组的指针*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.21 编写一个函数，令其接收两个参数：一个是int类型的数，另一个是int类型的指针，函数比较int的值和指针所指的值，返回较大的那个。在该函数中指针的类型应该是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一个参数的实际值毫无疑问是int类型</span><br><span class="hljs-comment">//第二个参数是int指针，实际上有可能表示的是int数组，该指针指向数组的首元素</span><br><span class="hljs-comment">//因为两个参数的内容都不会被修改，所以应该设置为const</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (val &gt; *p) ? val : *p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>) <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;val : a)&#123;<br>        val = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;请输入一个数字:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">int</span> j;<br>    cin &gt;&gt; j;<br>    cout &lt;&lt; <span class="hljs-string">&quot;输入数字与数组首元素中较大的一个是：&quot;</span> &lt;&lt; <span class="hljs-built_in">compare</span>(j, a) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;数组的全部元素是：&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val : a)&#123;<br>        cout &lt;&lt; val;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.22 编写两个函数，令其交换两个int指针（对于该题目有两种理解，一种是交换指针本身的值，即指针所指的内存地址，另一种是交换指针所指的内容）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一版：以值传递的方式使用指针，所有改变都局限于函数内部</span><br><span class="hljs-comment">//当函数执行完毕之后即不会改变指针本身的值，也不会改变指针所指的内容</span><br><span class="hljs-comment">//在函数内交换了两个指针的指向</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapVer1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p, <span class="hljs-keyword">int</span> *q)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> *temp = p;<br>    p = q;<br>    q = tmep;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第二版：以值传递的方式使用指针，但是在函数内部通过解引用的方式直接访问内存并修改了指针所指的内容</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapVer2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p, <span class="hljs-keyword">int</span> *q)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = *p;<br>    *p = *q;<br>    *q = temp;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第三版：参数形式是int *&amp;，其含义是，该参数是一个指向int *的引用</span><br><span class="hljs-comment">//使用这种方式可以把指针当作对象，交换指针本身的值</span><br><span class="hljs-comment">//需要注意的是，最后一个函数既然交换了指针，当然解引用该指针所得的结果也会相应的发生改变</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapVer3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *&amp;p, <span class="hljs-keyword">int</span> *&amp;q)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> * temp = p;<br>    p = q;<br>    q = temp;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.23 参考本节介绍的几个print函数，根据理解编写你自己的版本。依次调用每个函数使其输入下面定义的i和j</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br><span class="hljs-comment">//实现了三个版本的print函数，第一个版本不控制指针的边界</span><br><span class="hljs-comment">//第二个版本由调用者指定数组的维度</span><br><span class="hljs-comment">//第三个版本使用cpp11新规定的begin和end函数限定数组边界</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一个版</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p)</span></span>&#123;<br>    cout &lt;&lt; *p &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-built_in">print</span>(&amp;i);<br><span class="hljs-built_in">print</span>(j);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第二个版本</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* p, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i != sz)&#123;<br>        cout&lt;&lt; *p++&lt;&lt;endl;<br>        ++i;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-built_in">print</span>(&amp;i, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">print</span>(j , <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(j) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*j));<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第三个版本</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* beg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* end)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = beg; p != end; ++p)&#123;<br>        cout &lt;&lt; *p &lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">begin</span>(j);<br><span class="hljs-keyword">auto</span> e = <span class="hljs-built_in">end</span>(j);<br><span class="hljs-built_in">print</span>(b, e);<br></code></pre></td></tr></table></figure></li><li><p>练习 6.24 描述下面这个函数的行为。如果代码中存在问题，请指出并改正。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>])</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;i != <span class="hljs-number">10</span>; ++i)&#123;<br>        cout&lt;&lt; ia[i] &lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 当我们想把数组作为函数的形参时，有三种可供选择的方式：一是声明为指针；二是声明为维度不限的数组；三是声明为维度确定的数组。实际上，因为数组传入函数时实参自动转换成指向数组首元素的指针，所以这三种方式是等价的。<br><span class="hljs-bullet">2.</span> 由上面的分析知，const int ia[10]实际上等价于const int <span class="hljs-emphasis">* ia。ia的维度10只是我们期望的数组维度，实际上不一定，即使实参数组的真实维度不是10，也可以正常的调用print函数。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//修改后的程序为</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != sz; ++i)&#123;<br>        cout &lt;&lt; ia[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a>main：处理命令行选项</h4><ol><li><p>有时候确实需要给main函数传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如，假定main函数位于可执行文件prog之内，我们可以向程序传递下面的选项：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">prog -d -o ofile data0<br></code></pre></td></tr></table></figure></li><li><p>这些命令行选项通过两个(可选的)形参传递给main函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span>&#123;<span class="hljs-comment">/**/</span>&#125;<br><span class="hljs-comment">//第二个形参argv是一个数组，它的元素是指向C风格字符串的指针</span><br><span class="hljs-comment">//第一个形参argc表示数组中字符串的数量</span><br><span class="hljs-comment">//因为第二个形参是数组，所以main函数也可以定义成</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span>&#123;<span class="hljs-comment">/**/</span>&#125;<br><span class="hljs-comment">//其中argv指向char*</span><br></code></pre></td></tr></table></figure></li><li><p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以上面提供的命令行为例，argc应该等于5，argv应该包含如下的C风格字符串</span><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;prog&quot;</span>; <span class="hljs-comment">//此处也可以指向一个空字符串</span><br>argv[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-d&quot;</span>;<br>argv[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;-o&quot;</span>;<br>argv[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;ofile&quot;</span>;<br>argv[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;data0&quot;</span>;<br>argv[<span class="hljs-number">5</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写一个main函数，令其接受两个实参。把实参的内容连接成一个string对象并输出出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span>&#123;<br>    string str;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != argc; i++)&#123;<br>        str += argv[i];<br>    &#125;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写一个程序，使其接受本节所示的选项，输出传递给main函数的实参的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != argc; i++)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;argv[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; argv[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h4><ol><li><p>为了编写能处理不同数量实参的函数，cpp11新标准提供了两种主要的办法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。</p></li><li><p>initializer_list形参</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> initializer<span class="hljs-emphasis">_list是一种标准库类型，用于表示某个特定类型的值的数组。initializer_</span>list定义在同名的头文件中，定义的操作如下所示。<br><span class="hljs-bullet">2.</span> initializer<span class="hljs-emphasis">_list<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span></span> lst：默认初始化，T类型元素的空列表</span><br><span class="hljs-emphasis">3. initializer_</span>list<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span></span> lst&#123;a, b, c...&#125;：lst的元素数量和初始值一样多，lst的元素是对应初始值的副本，列表中的元素是const。<br><span class="hljs-bullet">4.</span> lst2(lst)：拷贝或者赋值一个initializer<span class="hljs-emphasis">_list对象不会拷贝列表中的元素，拷贝后，原始列表和副本共享元素。</span><br><span class="hljs-emphasis">5. lst.size()：列表中的元素数量。</span><br><span class="hljs-emphasis">6. lst.begin()：返回指向列表中首元素的指针。</span><br><span class="hljs-emphasis">7. lst.end()：返回指向尾后元素的指针。</span><br></code></pre></td></tr></table></figure></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(initializer_list&lt;string&gt; il)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++beg)&#123;<br>        cout &lt;&lt; *beg &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内</span><br><span class="hljs-keyword">if</span>(expected != actual)&#123;<br>    <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;funcx&quot;</span>, expected, actual&#125;); <span class="hljs-comment">//expected, actual是string对象</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>     <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;funcx&quot;</span>, <span class="hljs-string">&quot;okey&quot;</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>省略符形参</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 省略符形参是为了便于cpp程序访问某些特殊的c代码而设置的，这些代码使用了名为varargs的c标准库功能。通常，省略符形参不应用于其它目的。<br><span class="hljs-bullet">2.</span> 省略符形参应该仅仅用于C和c++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。<br><span class="hljs-bullet">3.</span> 省略符形参你只能出现在形参列表的最后一个位置，形式如下：<br>void foo(parm<span class="hljs-emphasis">_list, ...); //指定了部分形参的类型，对应于这些形参的实参将会执行正常的类型检查</span><br><span class="hljs-emphasis">void foo(...);</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.27 编写一个函数，它的参数是initializer_list&lt; int &gt;类型的对象，函数的功能是计算列表中所有元素的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">iCount</span><span class="hljs-params">(initializer_list&lt; <span class="hljs-keyword">int</span> &gt; il)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> val: il)&#123;<br>        count += val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//使用列表初始化的方式构建initializer_list&lt;int&gt;对象</span><br>    <span class="hljs-comment">//然后把它作为实参传递给函数iCount</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;1,6,9的和是：&quot;</span> &lt;&lt; <span class="hljs-built_in">iCount</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;) &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;4,5,9,18的和是：&quot;</span> &lt;&lt; <span class="hljs-built_in">iCount</span>(&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">18</span>&#125;) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 6.28 在error_msg函数的第二个版本中包含ErrCode类型的参数，其中循环内的elem是什么类型？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(ErrCode e, initializer_list&lt;string&gt; il)</span></span>&#123;<br>    cout &lt;&lt; e.<span class="hljs-built_in">msg</span>() &lt;&lt;<span class="hljs-string">&quot;:&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;elem : il)&#123;<br>        cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//initializer_list&lt;string&gt;的所有元素类型都是string，因此const auto &amp;el : il</span><br><span class="hljs-comment">//推断得到的elem的类型是const string&amp;</span><br><span class="hljs-comment">//使用引用是为了避免拷贝长字符串</span><br><span class="hljs-comment">//把它定义为常量的原因是我们只需读取字符串的内容，不需要修改它。</span><br></code></pre></td></tr></table></figure></li><li><p>练习 6.29 在范围for循环中使用initializer_list对象时，应该将循环控制变量声明成引用类型吗？为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//引用类型的主要优势是可以直接操作所引用的对象</span><br><span class="hljs-comment">//避免拷贝较为复杂的类类型对象和容器对象，因为initial_list对象的元素永远是常量值</span><br><span class="hljs-comment">//所以不可能通过设定引用类型来更改循环控制变量的内容</span><br><span class="hljs-comment">//只有当initializer_list对象的元素类型是类类型或者容器类型（string）时</span><br><span class="hljs-comment">//才有必要把范围for循环的循环控制变量设为引用型</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter6&lt;/p&gt;
&lt;p&gt;函数基础 + 参数传递部分&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_7_40</title>
    <link href="http://example.com/cpp-primer-7-40/"/>
    <id>http://example.com/cpp-primer-7-40/</id>
    <published>2021-05-27T07:51:05.000Z</published>
    <updated>2021-05-28T02:23:15.280Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter5</p><p>语句</p><span id="more"></span><ol><li><p>练习 5.1 什么是空语句？什么时候会用到空语句？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 空语句是最简单的语句，空语句由一个单独的分号构成。<br><span class="hljs-bullet">2.</span> 如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句，空语句什么都不做。<br><span class="hljs-bullet">3.</span> 一种常见的情况是，当循环的全部工作在条件部分就可以完成时，通常会使用到空语句。使用空语句时最好加上注释，从而令代码的阅读者知道这条语句是有意省略内容的。<br></code></pre></td></tr></table></figure></li><li><p>练习 5.2 什么是块，什么时候会用到块？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 块使用花括号括起来的语句和声明的序列，也称为复合语句。<br><span class="hljs-bullet">2.</span> 一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块访问。<br><span class="hljs-bullet">3.</span> 如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，此时应该使用块。块不需要以分号结束。<br></code></pre></td></tr></table></figure></li><li><p>练习 5.3 使用逗号运算符重写1.4.1节的while 循环，使它不再需要块，观察改写之后的代码的可读性提高了还是降低了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用连续的逗号运算符可以把多条语句合并为一条，这一点与块的作用类似</span><br><span class="hljs-comment">//但是一般来说，直接使用块在程序的可读性上更有优势</span><br><span class="hljs-comment">//原代码：</span><br><span class="hljs-keyword">while</span>(val &lt;= <span class="hljs-number">10</span>)&#123;<br>    sum += val;<br>    val++;<br>&#125;<br><span class="hljs-comment">//使用逗号运算符之后</span><br><span class="hljs-keyword">while</span>(val &lt;= <span class="hljs-number">10</span>)&#123;<br>    sum += val, val++; <span class="hljs-comment">//很明显，改写之后的代码不够清晰，可读性降低了</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.4 说明下列例子的含义，如果存在问题，试着修改它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//原程序</span><br><span class="hljs-keyword">while</span>(string :: iterator iter != s.<span class="hljs-built_in">end</span>())&#123;&#125;<br><span class="hljs-comment">//修改之后的程序为：</span><br>string::iterator iter = s.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(iter != s.<span class="hljs-built_in">end</span>())&#123;<br>    iter++;<br>&#125;<br><span class="hljs-comment">//原程序</span><br><span class="hljs-keyword">while</span>(<span class="hljs-keyword">bool</span> status = <span class="hljs-built_in">find</span>(word))&#123;<span class="hljs-comment">/* */</span>&#125;<br><span class="hljs-keyword">if</span>(!status)&#123;<span class="hljs-comment">/**/</span>&#125;<br><span class="hljs-comment">//修改之后的程序为</span><br><span class="hljs-keyword">bool</span> status;<br><span class="hljs-keyword">while</span>(status = <span class="hljs-built_in">find</span>(word))&#123;<span class="hljs-comment">/* */</span>&#125;<br><span class="hljs-keyword">if</span>(!status)&#123;<span class="hljs-comment">/* */</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.5 写一段自己的程序，使用if else语句实现把数字成绩转换成字母成绩的要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> grade;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入成绩：&quot;</span>;<br>cin &gt;&gt; grade;<br><span class="hljs-keyword">if</span> (grade &lt; <span class="hljs-number">0</span> || grade&gt;<span class="hljs-number">100</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;该成绩不合法&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (grade == <span class="hljs-number">100</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;成绩等级是：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;A++&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (grade &lt; <span class="hljs-number">60</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;成绩等级是：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;F&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> iU = grade / <span class="hljs-number">10</span>; <span class="hljs-comment">//成绩的十位数</span><br><span class="hljs-keyword">int</span> iT = grade % <span class="hljs-number">10</span>; <span class="hljs-comment">//成绩的个位数</span><br>string score, level, lettergrade;<br><span class="hljs-keyword">if</span> (iU == <span class="hljs-number">9</span>) &#123;<br>score = <span class="hljs-string">&quot;A&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iU == <span class="hljs-number">8</span>) &#123;<br>score = <span class="hljs-string">&quot;B&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iU == <span class="hljs-number">7</span>) &#123;<br>score = <span class="hljs-string">&quot;C&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>score = <span class="hljs-string">&quot;D&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (iT &lt; <span class="hljs-number">3</span>) &#123;<br>level = <span class="hljs-string">&quot;-&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iT &gt; <span class="hljs-number">7</span>) &#123;<br>level = <span class="hljs-string">&quot;+&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>level = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br>lettergrade = score +level;<br>cout &lt;&lt; <span class="hljs-string">&quot;成绩等级是：&quot;</span> &lt;&lt; lettergrade &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.6 改写上一题的程序，使用条件运算符代替if else语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> grade;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入成绩：&quot;</span>;<br>cin &gt;&gt; grade;<br><span class="hljs-keyword">if</span> (grade &lt; <span class="hljs-number">0</span> || grade&gt;<span class="hljs-number">100</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;该成绩不合法&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (grade == <span class="hljs-number">100</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;成绩等级是：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;A++&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (grade &lt; <span class="hljs-number">60</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;成绩等级是：&quot;</span> &lt;&lt; <span class="hljs-string">&quot;F&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> iU = grade / <span class="hljs-number">10</span>; <span class="hljs-comment">//成绩的十位数</span><br><span class="hljs-keyword">int</span> iT = grade % <span class="hljs-number">10</span>; <span class="hljs-comment">//成绩的个位数</span><br>string score, level, lettergrade;<br>score = (iU == <span class="hljs-number">9</span>) ? <span class="hljs-string">&quot;A&quot;</span><br>: (iU == <span class="hljs-number">8</span>) ? <span class="hljs-string">&quot;B&quot;</span><br>: (iU == <span class="hljs-number">7</span>) ? <span class="hljs-string">&quot;C&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;<br>level = (iT &gt; <span class="hljs-number">7</span>) ? <span class="hljs-string">&quot;+&quot;</span> <br>: (iT &lt; <span class="hljs-number">3</span>) ? <span class="hljs-string">&quot;-&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;<br>lettergrade = score +level;<br>cout &lt;&lt; <span class="hljs-string">&quot;成绩等级是：&quot;</span> &lt;&lt; lettergrade &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.7 改正下列代码段中的错误。</p></li><li><p>练习 5.8 什么是悬垂else，cpp语言中是如何处理else子句的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//悬垂else是指当程序中的if分支多于else分支时，如何为else寻找与之匹配的if分支的问题。</span><br><span class="hljs-comment">//cpp规定，else与离他最近的尚未匹配的if匹配，从而消除了二义性。</span><br></code></pre></td></tr></table></figure></li><li><p>switch语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//switch语句首先对括号里的表达式求值，该表达式紧跟在switch语句的后面，可以是一个初始化的变量声明。</span><br><span class="hljs-comment">//表达式的值转换成整数类型，然后与每个case的标签进行比较。</span><br><span class="hljs-comment">//case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式：</span><br><span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">getVal</span>();<br><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(ch)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3.14</span>: <span class="hljs-comment">//错误,case标签必须是一个整数</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">case</span> ival: <span class="hljs-comment">//错误,case标签必须是一个常量</span><br>&#125;<br><span class="hljs-comment">//任何两个case标签的值不能相同，否则就会引发错误</span><br><span class="hljs-comment">//default也是一种特殊的case标签</span><br><span class="hljs-comment">//标签不应该孤零零的出现，它后面必须跟上一条语句或者另外一个case标签</span><br><span class="hljs-comment">//如果switch结构以一个空的default标签作为结束</span><br><span class="hljs-comment">//则default标签后面必须跟上一条空语句或者一个空块</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如前所述，switch的执行流程有可能会跨过某些case标签</span><br><span class="hljs-comment">//如果程序跳到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉</span><br><span class="hljs-comment">//那么如果被略过的代码中含有变量的定义该怎么办？</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">答案：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。</span><br><span class="hljs-comment">cpp语言规定，不允许跨过变量的初始化语句直接跳到该变量作用域的另一个位置。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br><span class="hljs-comment">//因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法</span><br>string file_name; <span class="hljs-comment">//错误：控制流绕过一个隐式初始化的变量</span><br><span class="hljs-keyword">int</span> ival = <span class="hljs-number">0</span>; <span class="hljs-comment">//错误：控制流绕过一个显式初始化的变量</span><br><span class="hljs-keyword">int</span> jval; <span class="hljs-comment">//正确，因为jval没有初始化</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>jval = <span class="hljs-built_in">next_num</span>(); <span class="hljs-comment">//正确，给jval赋一个值</span><br><span class="hljs-keyword">if</span>(file_name.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//file_name在作用域内，但是没有被初始化</span><br>    &#125;<br><br><span class="hljs-comment">//如果需要为某个case分支定义并初始化一个变量，应该把变量定义在块内</span><br><span class="hljs-comment">//从而确保后面的所有case标签都在变量的作用域之外</span><br><span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br>&#123;<br><span class="hljs-comment">//正确，声明和初始化语句位于语句块内部</span><br>    string file_name = <span class="hljs-built_in">get_file_name</span>();<br>&#125;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.9 编写一段程序，使用一系列if语句统计从cin读入的文本中有多少元音字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>string str;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, str)) &#123;<br><span class="hljs-keyword">if</span> (!str.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : str) &#123;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span> || ch == <span class="hljs-string">&#x27;e&#x27;</span> || ch == <span class="hljs-string">&#x27;i&#x27;</span> || ch == <span class="hljs-string">&#x27;o&#x27;</span> || ch == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>count++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.10 编写一段程序，既统计元音字母的小写形式，又统计元音字母的大写形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//修改上述程序的条件即可</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.11 修改统计元音字母的程序，使其也能统计空格，换行符和制表符的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//修改第一题的条件即可</span><br><span class="hljs-comment">//注意，读入字符的语句应该用cin.get(ch)，而不能使用&gt;&gt;</span><br><span class="hljs-comment">//因为后者会忽略本题要统计的特殊符号</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.12 修改统计元音字母的程序，使其能统计以下含有两个字符的字符序列的数量”ff”，“fl”和“fi”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> ch;<br><span class="hljs-keyword">char</span> pre = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>string str;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一段文本：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin.<span class="hljs-built_in">get</span>(ch)) &#123;<br><span class="hljs-keyword">if</span> (pre == <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ch) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;l&#x27;</span>:<span class="hljs-keyword">case</span><span class="hljs-number">&#x27;</span>i<span class="hljs-number">&#x27;</span>:<br>count++;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>pre = ch;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;count = &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.13 指出程序的错误然后修改它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//总结：switch语句有几个语法要点</span><br><span class="hljs-comment">//（1）必须在必要的地方使用break</span><br><span class="hljs-comment">//（2）语句，应该把变量定义在块作用域内</span><br><span class="hljs-comment">//（3）case标签只能有一个值，且不能是变量</span><br></code></pre></td></tr></table></figure></li><li><p>while语句</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 定义在while条件部分或者while循环体内的变量每次迭代都经历了从创建到销毁的过程。<br></code></pre></td></tr></table></figure></li><li><p>练习5.14 编写一段程序，从标准输入流中读取若干string对象并查找连续重复出现的单词。所谓连续重复出现的意思是：一个单词后面紧跟着这个单词本身。要求记录连续重复出现的最大次数以及对应的单词。如果这样的单词存在，输出重复出现的最大次数；如果不存在，输出一条信息说明任何单词都没有连续出现过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//示例：输入为 how now now now brown cow cow</span><br><span class="hljs-comment">//输出为 3</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> maxCount = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">unsigned</span> count = <span class="hljs-number">0</span>;<br>string maxStr;<br>string str;<br>string pre;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; str)<br>&#123;<br><span class="hljs-keyword">if</span> (str == pre) &#123;<br>++count;<br><span class="hljs-keyword">if</span> (count &gt; maxCount) &#123;<br>maxCount = count;<br>maxStr = str;<br>&#125;<br>&#125;<br>pre = str;<br>&#125;<br><span class="hljs-keyword">if</span> (maxCount &gt; <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; maxCount &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不存在重复的单词&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 5.15 说明下列循环的含义并改正其中的错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//理解for循环的语法规则</span><br><span class="hljs-comment">//特别是for循环控制结构中三条语句的作用</span><br><span class="hljs-comment">//理解循环控制变量和循环终止条件的关系，从而判断循环是否会无限执行下去</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.16 while循环特别适用于那些条件保持不变、反复执行操作的情况，例如当未到达文件末尾时不断读取下一个值。for循环则更像按照步骤迭代，它的索引在在某个范围内依次变化。根据每种循环的习惯用法各自编写一段程序，然后分别用另一种循环改写。如果只能用一种循环，倾向于用哪种？为什么？</p></li><li><p>练习 5.17 假设有两个包含整数的vector对象，编写一段程序，检验其中一个vector对象是否是另一个vector对象的前缀。为了实现这一目标，对于两个不等长的vector对象，只是挑出长度较短的那个，把它的元素和另一个vector对象比较即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//示例：两个vector对象的元素分别是 0 1 1 2 和 0 1 1 2 3 5 8</span><br><span class="hljs-comment">//则程序返回的结果应该为真</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ivec1&#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; ivec2&#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>&#125;;<br><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">auto</span> beg1 = ivec1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> beg2 = ivec2.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (beg1 != ivec1.<span class="hljs-built_in">end</span>() &amp;&amp; beg2 != ivec2.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-keyword">if</span> (*beg1 != *beg2) &#123;<br>flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>beg1++;<br>beg2++;<br>&#125;<br>cout &lt;&lt; flag &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>范围for语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(declaration : expression)&#123;<br>    statement;<br>&#125;<br><span class="hljs-comment">//expression必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象</span><br><span class="hljs-comment">//这些类型的共同特点是拥有能返回迭代器的begin和end成员</span><br><span class="hljs-comment">//declaration定义一个变量，序列中的每个元素都得能转换成该变量的类型</span><br><span class="hljs-comment">//确保类型相容最简单的办法是使用auto类型说明符</span><br><span class="hljs-comment">//如果需要对序列中的变量执行写操作，循环变量必须声明成引用类型</span><br><span class="hljs-comment">//范围for语句的定义来源于与之等价的传统for语句</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> beg = v.<span class="hljs-built_in">begin</span>(), end = v.<span class="hljs-built_in">end</span>(); beg != end; beg++)&#123;<br>    <span class="hljs-keyword">auto</span> &amp;r = *beg; <span class="hljs-comment">//r必须是引用类型，这样才能执行写操作</span><br>    r *= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">//从上面的代码可以看出</span><br><span class="hljs-comment">//范围for语句预存了end()的值，一旦在序列中删除或者添加元素，end函数的值可能就失效了</span><br><span class="hljs-comment">//所以不能通过范围for语句增加或者删除容器的元素</span><br></code></pre></td></tr></table></figure></li><li><p>do while语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">do</span> </span><br><span class="hljs-function">    statement</span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(condition)</span></span>;<br><span class="hljs-comment">//do while语句应该在括号包围起来的条件后面用一个分号表示语句结束</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.18 说明下列循环的含义并改正其中的错误</p></li><li><p>练习 5.19 编写一段程序，使用do while循环重复的执行下述任务：首先提示用户输入两个string对象，然后挑出那个较短的并输出它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string flagStr;<br><span class="hljs-keyword">do</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;<br>string s1, s2;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br>(s1.<span class="hljs-built_in">size</span>() &lt; s2.<span class="hljs-built_in">size</span>()) ? (cout &lt;&lt; s1 &lt;&lt; endl) : (cout &lt;&lt; s2 &lt;&lt; endl);<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续(yes or no)：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; flagStr;<br>&#125; <span class="hljs-keyword">while</span> (flagStr!=<span class="hljs-string">&quot;&quot;</span>&amp;&amp;flagStr[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;n&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>break语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//break语句的作用范围仅限于最近的循环或者switch</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.20 编写一段程序，从标准输入中读取string对象的序列直到连续出现两个相同的单词或者所有的单词都读完了为止。使用while循环一次读取一个单词，当一个单词连续出现两次时使用break语句终止循环。输出连续重复的单词，或者输出一个消息说明没有任何单词是连续重复出现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string result = <span class="hljs-string">&quot;不存在重复的单词&quot;</span>;<br>string preWord, curWord;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; curWord) &#123;<br><span class="hljs-keyword">if</span> (curWord == preWord) &#123;<br>result = curWord;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>preWord = curWord;<br>&#125;<br>&#125;<br>cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>continue语句</p></li><li><p>练习 5.21 修改5.20练习题的程序，使其找到的重复单词必须以大写字母开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string result = <span class="hljs-string">&quot;不存在重复的单词&quot;</span>;<br>string preWord, curWord;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; curWord) &#123;<br><span class="hljs-keyword">if</span> (curWord == preWord &amp;&amp; curWord[<span class="hljs-number">0</span>] == <span class="hljs-built_in">toupper</span>(curWord[<span class="hljs-number">0</span>])) &#123;<br>result = curWord;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>preWord = curWord;<br>&#125;<br>&#125;<br>cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>goto语句：不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</p></li><li><p>异常处理机制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//异常处理机制为程序中的异常检测和异常处理这两部分的协作提供支持，异常处理包括</span><br><span class="hljs-comment">//（1）throw表达式，异常检测部分用throw表达式来表示它遇到了无法处理的问题</span><br><span class="hljs-comment">//通常说throw引发了异常</span><br><span class="hljs-comment">//（2）try语句块，异常处理部分使用try语句块处理异常。try语句块以关键字try开始</span><br><span class="hljs-comment">//并以一个或多个catch子句结束</span><br><span class="hljs-comment">//try语句块中代码抛出的异常通常会被某个catch子句处理</span><br><span class="hljs-comment">//因为catch子句&quot;处理&quot;异常，所以它们也被称作异常处理代码</span><br><span class="hljs-comment">//（3）一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先检查两条数据是否是关于同一种书籍的</span><br><span class="hljs-keyword">if</span>(item1.<span class="hljs-built_in">isbn</span>() != item2.<span class="hljs-built_in">isbn</span>())&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;ISBN号不一致&quot;</span>);<br>&#125;<br>cout &lt;&lt; item1 + item2 &lt;&lt; endl;<br><span class="hljs-comment">//在这段代码中，如果ISBN不一样就抛出一个异常</span><br><span class="hljs-comment">//该异常是类型runtime_error的对象</span><br><span class="hljs-comment">//抛出异常将终止当前函数，并把控制权转移给能处理该异常的代码</span><br><span class="hljs-comment">//runtime_error时标准库异常类型的一种，定义在stdexcept头文件中</span><br><span class="hljs-comment">//初始化runtime_error对象的方式是给它提供一个string对象或者一个c风格字符串</span><br><span class="hljs-comment">//这个字符串中有一些关于异常的辅助信息</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//try语句块的通用语法形式是</span><br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//program-statements</span><br>&#125;<span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(exception-declaration)&#123;<br>    <span class="hljs-comment">//handler-statements</span><br>&#125;<span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(exception-declaration)&#123;<br>    <span class="hljs-comment">//handler-statements</span><br>&#125;<br><span class="hljs-comment">//当选中了某个catch子句处理异常之后，执行与之对应的块。</span><br><span class="hljs-comment">//catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(cin &gt;&gt; item1 &gt;&gt; item2)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//执行添加两个Sales_item对象的代码</span><br>        <span class="hljs-comment">//如果添加失败，代码抛出一个runtime_error异常</span><br>    &#125;<span class="hljs-built_in"><span class="hljs-keyword">catch</span></span>(runtime_error err)&#123; <br>        cout &lt;&lt; err.<span class="hljs-built_in">what</span>()<br>             &lt;&lt; <span class="hljs-string">&quot;\nTry Again? Enter y or n&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">char</span> c;<br>        cin &gt;&gt; c;<br>        <span class="hljs-keyword">if</span>(!cin || c == <span class="hljs-string">&#x27;n&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//每个标准库类型都定义了名为what的成员函数</span><br><span class="hljs-comment">//这些函数没有参数，返回值是c风格字符串（const char*）</span><br><span class="hljs-comment">//runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块</span><br><span class="hljs-comment">//例如，一个try语句块可能调用了包含另一个try语句块的函数</span><br><span class="hljs-comment">//寻找处理代码的过程与函数调用链正好相反。当异常被抛出的时候，首先搜索抛出该异常的函数</span><br><span class="hljs-comment">//如果没有找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找</span><br><span class="hljs-comment">//如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数</span><br><span class="hljs-comment">//以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止</span><br><span class="hljs-comment">//如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数</span><br><span class="hljs-comment">//该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出</span><br></code></pre></td></tr></table></figure></li><li><p>标准异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp标准库定义了一组类，用于报告标准库函数遇到的问题。</span><br><span class="hljs-comment">//这些异常类也可以在用户编写的程序中使用，它们分别定义在四个头文件中</span><br><span class="hljs-comment">//1. exception</span><br><span class="hljs-comment">//定义了最通用的异常类exception，只报告异常的发生，不提供任何额外信息</span><br><span class="hljs-comment">//2. stdexcept</span><br><span class="hljs-comment">//定义了几种常用的异常类</span><br><span class="hljs-comment">//3. new</span><br><span class="hljs-comment">//定义了bad_alloc异常类型</span><br><span class="hljs-comment">//4. type_info</span><br><span class="hljs-comment">//定义了bad_cast异常类型</span><br><span class="hljs-comment">//标准库类型只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值</span><br><span class="hljs-comment">//只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初值</span><br><span class="hljs-comment">//其他异常类型的行为则恰好相反（stdexcept定义的各种异常类）</span><br><span class="hljs-comment">//应该使用string对象或者c风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式</span><br><span class="hljs-comment">//创建此类对象时，必须提供初始值，该初始值含有错误相关的信息</span><br><span class="hljs-comment">//异常类型只定义了一个名为what的成员函数，该函数没有任何参数</span><br><span class="hljs-comment">//what的返回值与异常对象的类型有关</span><br><span class="hljs-comment">//如果异常类型有一个字符串初始值，则what返回该字符串，对于无初始值的类型来讲，由编译器决定。</span><br></code></pre></td></tr></table></figure></li><li><p>练习 5.23 编写一段程序，从标准输入中读取两个整数，输出第一个整数除以第二个数的结果</p></li><li><p>练习 5.24 修改你的程序，使得当第二个数为0时抛出异常，先不要定义catch子句，运行程序并真的为除数输入0，看看会发生什么</p></li><li><p>练习 5.25 修改上一题的程序，使用try语句块去捕获异常，catch子句应该为用户输出一条提示信息，询问其是否输入新数并重新执行try语句块的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请依次输入被除数和除数：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">int</span> v1, v2;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; v1 &gt;&gt; v2) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (v2 == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;除数不能为零&quot;</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;结果为：&quot;</span> &lt;&lt; v1 / v2 &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (runtime_error err) &#123;<br>cout &lt;&lt; err.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;需要继续嘛（y or n）：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">char</span> ch;<br>cin &gt;&gt; ch;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;n&#x27;</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter5&lt;/p&gt;
&lt;p&gt;语句&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_6_40</title>
    <link href="http://example.com/cpp-primer-6-40/"/>
    <id>http://example.com/cpp-primer-6-40/</id>
    <published>2021-05-26T15:02:04.000Z</published>
    <updated>2021-05-27T04:55:04.174Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter4</p><p>类型转换</p><span id="more"></span><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li><p>隐式转换：算数类型之间的隐式转换被设计的尽可能避免损失精度。比如，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//发生隐式转换的几种情况<br><span class="hljs-bullet">1.</span> 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。<br><span class="hljs-bullet">2.</span> 在条件中，非布尔值转换成布尔值。<br><span class="hljs-bullet">3.</span> 初始化过程中，初始值转换成变量的类型。<br><span class="hljs-bullet">4.</span> 在赋值语句中，右侧运算对象转换成左侧运算对象的值。<br><span class="hljs-bullet">5.</span> 如果算数运算或者关系运算的运算对象有多种类型，需要转换成同一种类型。<br><span class="hljs-bullet">6.</span> 函数调用时也会发生类型转换。<br></code></pre></td></tr></table></figure></li><li><p>算数转换：算数转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。例如，如果一个运算对象的类型是long double，那么不论另外一个运算对象是什么类型都会被转换成long double。</p></li><li><p>整型提升：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 整型提升负责把小整数类型转换成较大的整数类型。<br><span class="hljs-bullet">2.</span> 对于bool，char, signed char, unsigned char, short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int类型，否则，提升成unsigned int类型。比如，布尔值false提升为0，true提升为1。<br><span class="hljs-bullet">3.</span> 较大的char类型提升成int, unsigned int, long, unsigned long, long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。<br></code></pre></td></tr></table></figure></li><li><p>无符号类型的运算对象</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 如果某个运算符的运算对象类型不一样，这些运算对象将转换成同一种类型。<br><span class="hljs-bullet">2.</span> 如果某个运算对象是无符号类型，转换的结果依赖于机器中各个整数类型的相对大小。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//转换过程</span><br><span class="hljs-number">1.</span> 首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的，要么都是无符号的，则小类型的运算对象转换成较大的类型。<br><span class="hljs-number">2.</span> 如果其中一个对象是无符号类型，另外一个对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。<br><span class="hljs-comment">//例如假设两个类型分别是unsigned int和int，则int类型的运算对象转换成unsigned int类型</span><br><span class="hljs-comment">//需要注意的是，如果int的值恰好为负值，转换将会有一定的副作用，如前文所述</span><br><span class="hljs-number">3.</span> 剩下的一种情况就是带符号类型大于无符号类型，此时转换结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。<br><span class="hljs-comment">//例如两个运算对象的类型分别是long和unsigned int</span><br><span class="hljs-comment">//如果long和int大小相同，则long类型的运算对象转换成unsigned int类型</span><br><span class="hljs-comment">//如果long类型所占空间更多，则unsigned int类型的运算对象转换成long类型</span><br></code></pre></td></tr></table></figure></li><li><p>一些例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> flag;<br><span class="hljs-keyword">char</span> cval;<br><span class="hljs-keyword">short</span> sval;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> usval;<br><span class="hljs-keyword">int</span> ival;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uival;<br><span class="hljs-keyword">long</span> lval;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ulval;<br><span class="hljs-keyword">float</span> fval;<br><span class="hljs-keyword">double</span> dval;<br><span class="hljs-comment">//3.14159L + &#x27;a&#x27;; //&#x27;a&#x27;被提升为int，然后int转换成long double</span><br><span class="hljs-comment">//dval + ival; //ival转换成double</span><br><span class="hljs-comment">//dval + fval; //fval转换成double</span><br><span class="hljs-comment">//ival = dval; //窄化操作，dval切除小数部分</span><br><span class="hljs-comment">//flag = dval; //如果dval是0，则flag为false，否则为true</span><br><span class="hljs-comment">//cval + fval; //cval提升为int，然后再转换成float</span><br><span class="hljs-comment">//sval + cval; //两者都提升为int</span><br><span class="hljs-comment">//cval + lval; //cval转换成long</span><br><span class="hljs-comment">//ival + ulval; //ival转换成unsigned int</span><br><span class="hljs-comment">//usval + ival; //根据unsigned 和 int 所占空间的大小进行提升</span><br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (usval + ival) &lt;&lt; endl; <span class="hljs-comment">//4</span><br><span class="hljs-comment">/*uival + lval; */</span><span class="hljs-comment">//根据unsigned int和long所占空间的大小进行转换</span><br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> ( uival + lval)&lt;&lt;endl; <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.34 根据本节给出的变量定义，说明在下面的表达式中将发生什么样的类型转换，需要注意每种运算符遵循的是左结合率还是右结合律：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(fval);<br><span class="hljs-comment">//if语句的条件应该是布尔值，因此float型变量fval自动转换成布尔值</span><br><span class="hljs-comment">//转换规则是所有非0值转换为true，0转换成false</span><br>dval = fval + ival;<br><span class="hljs-comment">//ival转换成float</span><br><span class="hljs-comment">//与fval求和后所得的结果进一步转换成double类型</span><br>dval + ival * cval;<br><span class="hljs-comment">//cval执行整型提升转换为int，与ival相乘后所得结果转换为double类型，最后再与dval相加</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.35  请回答在下面的表达式中发生了隐式类型转换嘛？如果有，请说明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> cval;<br><span class="hljs-keyword">int</span> ival;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ui;<br><span class="hljs-keyword">float</span> fval;<br><span class="hljs-keyword">double</span> dval;<br>cval = <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">3</span>;<br><span class="hljs-comment">//&#x27;a&#x27;提升为int，与3相加所得结果再转为char并赋值给cval;</span><br>fval = ui - ival * <span class="hljs-number">1.0</span>;<br><span class="hljs-comment">//ival转换成double，与1.0相乘的结果也是double类型</span><br><span class="hljs-comment">//ui转换成double类型之后与乘法得到的结果相减，最终的结果转换为float并赋给fval</span><br>dval = ui * fval;<br><span class="hljs-comment">//ui转换为float，与fval相乘的结果转换成double类型并赋值给dval</span><br>cval = ival + fval + dval;<br><span class="hljs-comment">//int -&gt; float -&gt; double -&gt; char</span><br></code></pre></td></tr></table></figure></li><li><p>其他隐式类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</span><br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">int</span> *ip = ia;<br><span class="hljs-comment">//不会发生上述转换的几种情况</span><br><span class="hljs-comment">//(1)数组被用作decltype关键字的参数</span><br><span class="hljs-comment">//(2)作为取地址符的运算对象</span><br><span class="hljs-comment">//(3)用一个引用来初始化数组，上述转换也不会发生</span><br><span class="hljs-comment">//(2)(3)的例子</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>]; <br><span class="hljs-keyword">decltype</span>(ia) ib; <span class="hljs-comment">//(1)的例子</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*ic)[<span class="hljs-number">10</span>] = &amp;ia; <span class="hljs-comment">//(2)(3)的例子</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//指针的转换</span><br><span class="hljs-comment">//常量整数值0或者字面值nullptr能转换成任意指针类型</span><br><span class="hljs-comment">//指向任意非常量的指针能转换成void*</span><br><span class="hljs-comment">//指向任意对象的指针能转换成const void *</span><br><span class="hljs-comment">//在有继承关系的类型间还有另外一种指针转换的方式</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//存在一种从算数类型或者指针类型向布尔类型自动转换的机制</span><br><span class="hljs-comment">//如果指针或者算数类型的值为0</span><br><span class="hljs-comment">//转换结果为false，否则为true</span><br><span class="hljs-keyword">char</span> *cp = <span class="hljs-built_in">get_string</span>();<br><span class="hljs-keyword">if</span>(cp)&#123;<br>    <span class="hljs-comment">/*如果指针cp不是0，条件为真*/</span> <br>&#125;<br><span class="hljs-keyword">while</span>(*cp)&#123;<br>    <span class="hljs-comment">//如果*cp不是空字符，条件为真</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//转换成常量</span><br><span class="hljs-comment">//允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样</span><br><span class="hljs-comment">//如果T是一种类型，就能将指向T的指针或者引用分别转换成指向const T的指针和引用</span><br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;j = i; <span class="hljs-comment">//非常量转换成const int的引用</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;i; <span class="hljs-comment">//非常量的地址转换成const的地址</span><br><span class="hljs-comment">//注意相反的转换并不存在，因为它试图删除掉底层const</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//类类型的转换</span><br><span class="hljs-comment">//类类型能定义编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换</span><br><span class="hljs-comment">//如果同时提出多个转换请求，这些请求将被拒绝</span><br><span class="hljs-comment">//示例1：需要标准库string类型的地方使用C风格字符串</span><br>string s,t = <span class="hljs-string">&quot;a value&quot;</span>; <span class="hljs-comment">//字符串字面值转换成string类型</span><br><span class="hljs-comment">//示例2：while条件部分把cin转换成了bool值</span><br><span class="hljs-comment">//IO库定义了从istream向布尔值转换的规则</span><br><span class="hljs-comment">//所得的布尔值到底是什么由输入流的状态决定</span><br><span class="hljs-comment">//如果最后一次读入成功，转换得到的布尔值是true</span><br><span class="hljs-comment">//如果最后一次读入不成功，转换得到的布尔值false</span><br><span class="hljs-keyword">while</span>(cin &gt;&gt; s)&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>显式转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//命名的强制类型转换</span><br>cast-name&lt;type&gt; expression;<br><span class="hljs-comment">//type是转换的目标类型，而expression是转换的值</span><br><span class="hljs-comment">//如果type是引用类型，则结果是左值</span><br><span class="hljs-comment">//cast-name是static_cast，dynamic_cast，const_cast和reinterpret_cast中的一种</span><br><span class="hljs-comment">//dynamic_cast支持运行时类型识别</span><br><span class="hljs-comment">//cast-name指定了执行的是哪种转换</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//static_cast</span><br><span class="hljs-comment">//任何具有明确定义的类型转换，只要不包含底层const，就可以使用static_cast</span><br><span class="hljs-keyword">double</span> slope = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(j) / i; <span class="hljs-comment">//进行强制类型转换以便执行浮点数除法</span><br><span class="hljs-comment">//static_cast常用于把一个较大的算数类型转换成一个较小的算数类型</span><br><span class="hljs-comment">//static_cast对于编译器无法自动执行的类型转换也非常有用</span><br><span class="hljs-keyword">double</span> d = <span class="hljs-number">3.24</span>;<br><span class="hljs-keyword">void</span> *p = &amp;d; <span class="hljs-comment">//任何非常量对象的地址都能存入void*</span><br><span class="hljs-keyword">double</span> *dp = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span> *&gt;(p); <span class="hljs-comment">//正确：将void*转换成初始的指针类型</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//const_cast</span><br><span class="hljs-comment">//只能改变运算对象的底层const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pc;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pc); <span class="hljs-comment">//正确，但是通过p写值是未定义的行为</span><br><span class="hljs-comment">//对于将常量对象转换成非常量对象的行为，一般将其称之为“去掉const”性质</span><br><span class="hljs-comment">//编译器就不会阻止我们对该对象进行写操作了</span><br><span class="hljs-comment">//如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为</span><br><span class="hljs-comment">//然而如果对象是一个常量，在使用const_cast执行写操作就会产生未定义的结果</span><br><span class="hljs-comment">//只有const_cast能改变对象的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发错误</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp;<br><span class="hljs-keyword">char</span> *q = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">char</span> *&gt;(cp);<span class="hljs-comment">//错误</span><br><span class="hljs-keyword">static_cast</span>&lt;string&gt;(cp);<span class="hljs-comment">//正确，字符串字面值转换成了string类型</span><br><span class="hljs-keyword">const_cast</span>&lt;string&gt;(cp);<span class="hljs-comment">//错误：const_cast只改变常量属性</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//reinterpret_cast</span><br><span class="hljs-comment">//为运算对象的位模式提供较低层次上的重新解释</span><br></code></pre></td></tr></table></figure></li><li><p>练习4.36 假设i是int类型，d是double类型，书写表达式i *= d使其执行整数类型的乘法而非浮点类型的乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i *= <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(d);<br></code></pre></td></tr></table></figure></li><li><p>练习4.37 用命名的强制类型转换改写下列旧式的转换语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">double</span> d;<br><span class="hljs-keyword">const</span> string *ps;<br><span class="hljs-keyword">char</span> *pc;<br><span class="hljs-keyword">void</span> *pv;<br>(a) pv = (<span class="hljs-keyword">void</span>*) ps;<br>pv = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(<span class="hljs-keyword">const_cast</span>&lt;string *&gt;(ps));<br>(b)i = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*pc);<br>i = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(*pc);<br>(c)pv = &amp;d;<br>pv = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(&amp;d);<br>(d)pc = (<span class="hljs-keyword">char</span>*) pv;<br>pc = <span class="hljs-built_in"><span class="hljs-keyword">static_cast</span></span>(<span class="hljs-keyword">char</span>*) (pv);<br></code></pre></td></tr></table></figure></li><li><p>练习4.38 说明下面这条表达式的含义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> slope = <span class="hljs-built_in"><span class="hljs-keyword">static_cast</span></span>(<span class="hljs-keyword">double</span>)(j / i);<br><span class="hljs-comment">//把 j / i的值强制转换成double，然后赋值给slope</span><br><span class="hljs-comment">//如果i和j是int，则j / i的求值结果仍然是int</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter4&lt;/p&gt;
&lt;p&gt;类型转换&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_5_40</title>
    <link href="http://example.com/cpp-primer-5-40/"/>
    <id>http://example.com/cpp-primer-5-40/</id>
    <published>2021-05-25T09:41:27.000Z</published>
    <updated>2021-05-26T15:00:55.753Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter4</p><p>第三章内容的总结 + 部分第四章内容</p><span id="more"></span><h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h4><ol><li><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。因为多维数组实际上是数组的数组，所以由多维数组名转化而来的指针实际上是指向第一个内层数组的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]; <span class="hljs-comment">//大小为3的数组，每个元素是含有四个整数的数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*p)[<span class="hljs-number">4</span>] = ia; <span class="hljs-comment">//p指向含有4个整数的数组</span><br>p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">//p指向ia的尾元素</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ip[<span class="hljs-number">4</span>]; <span class="hljs-comment">//整型指针的数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*ip)[<span class="hljs-number">4</span>]; <span class="hljs-comment">//指向含有四个整数的数组</span><br></code></pre></td></tr></table></figure></li><li><p>auto和decltype的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = ia; p != ia + <span class="hljs-number">3</span>; p++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q = *p; q != *p + <span class="hljs-number">4</span>; q++)&#123;<br>        cout &lt;&lt; *q &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//p是一个指针，指向保存每一行元素的数组</span><br><span class="hljs-comment">//*p是一个含有四个整数的数组</span><br><span class="hljs-comment">//所以数组名被自动的转换成指向该数组首元素的指针</span><br><span class="hljs-comment">//q是一个指针，指向内层数组首元素</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用begin和end实现同样的功能</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">begin</span>(ia); p != <span class="hljs-built_in">end</span>(ia); p++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">begin</span>(*p); q != <span class="hljs-built_in">end</span>(*p); q++)&#123;<br>        cout&lt;&lt; *q &lt;&lt;<span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">//输出q所指的整数值</span><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类型别名简化多维数组的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//两种等价的类型别名声明</span><br><span class="hljs-keyword">using</span> int_array = <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> int_array[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span>(int_array *p = ia; p != ia + <span class="hljs-number">3</span>; p++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *q = *p; q != *p + <span class="hljs-number">4</span>; ++q)&#123;<br>        cout&lt;&lt; *q &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.43 编写三个不同版本的程序，令其均能输出ia的元素。此外，三个版本中的程序都要直接写出数据类型，不能使用类型别名，auto关键字或者decltype关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用范围for语句输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(&amp;row)[<span class="hljs-number">4</span>] : ia) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : row) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用普通for语句和下标运算符输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>cout &lt;&lt; ia[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用普通for循环和指针输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*p)[<span class="hljs-number">4</span>] = ia; p &lt; ia + <span class="hljs-number">3</span>; p++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>* q = *p; q &lt; *p + <span class="hljs-number">4</span>; q++) &#123;<br>cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.44 改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> int_array = <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用范围for语句输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (int_array &amp;row: ia ) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : row) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用普通for语句和下标运算符输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>cout &lt;&lt; ia[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用普通for循环和指针输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (int_array* p = ia; p &lt; ia + <span class="hljs-number">3</span>; p++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>* q = *p; q &lt; *p + <span class="hljs-number">4</span>; q++) &#123;<br>cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.45 再一次改写程序，这次使用auto关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用范围for语句输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row: ia ) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : row) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用普通for语句和下标运算符输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) &#123;<br>cout &lt;&lt; ia[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;利用普通for循环和指针输出多维数组的内容：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = ia; p &lt; ia + <span class="hljs-number">3</span>; p++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = *p; q &lt; *p + <span class="hljs-number">4</span>; q++) &#123;<br>cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="第三章总结"><a href="#第三章总结" class="headerlink" title="第三章总结"></a>第三章总结</h4><ol><li><p>术语表</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.</span> begin：string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。<br><span class="hljs-number">2.</span> 缓冲区溢出：一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等。<br><span class="hljs-number">3.</span> C风格字符串：以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错。<br><span class="hljs-number">4.</span> 类模板：用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如要定义一个vector对象需要指定元素的类型，vector &lt;<span class="hljs-keyword">int</span>&gt; 包含<span class="hljs-keyword">int</span>类型的元素。<br><span class="hljs-number">5.</span> 编译器扩展：某个特定的编译器为cpp语言额外增加的特性。基于编译器扩展编写的程序不易移植到其它编译器上。<br><span class="hljs-number">6.</span> 容器：是一种类型，其对象容纳了一组给定类型的对象，vector是一种容器类型。<br><span class="hljs-number">7.</span> 拷贝初始化：使用赋值号（=）的初始化形式。新创建的对象是初始值的一个副本。<br><span class="hljs-number">8.</span> difference_type：由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。<br><span class="hljs-number">9.</span> 直接初始化：不使用赋值号（=）的初始化形式。<br><span class="hljs-number">10.</span> empty：string和vector的成员。当对象的大小为<span class="hljs-number">0</span>时返回真，否则返回假。<br><span class="hljs-number">11.</span> end：string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素下一个位置的指针。<br><span class="hljs-number">12.</span> getline：在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。<br><span class="hljs-number">13.</span> 索引：是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。<br><span class="hljs-number">14.</span> 实例化：编译器生成一个指定的模板类或函数的过程。<br><span class="hljs-number">15.</span> 迭代器：是一种类型，用于访问容器中的元素或者在元素之间移动。<br><span class="hljs-number">16.</span> 迭代器运算：是string或vector的迭代器的运算，迭代器与整数相加减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或者向后移动了若干个位置，两个迭代器相减得到了它们之间的距离，此时它们必须指向同一个容器中的元素或该容器尾元素的下一位置。<br><span class="hljs-number">17.</span> 以空字符结束的字符串：是一个字符串，它的后面还跟着一个空字符<span class="hljs-string">&#x27;\0&#x27;</span>。<br><span class="hljs-number">18.</span> 尾后迭代器：end函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一个位置。<br><span class="hljs-number">19.</span> 指针运算：指针类型支持的算数运算。指向数组的指针所支持的运算的种类与迭代器运算一样。<br><span class="hljs-number">20.</span> <span class="hljs-keyword">ptrdiff_t</span>：是cstddef头文件中定义的一种与机器实现有关的带符号数整数类型，它的空间足够大，能表示数组中任意两个指针之间的距离。<br><span class="hljs-number">21.</span> push_back：vector对象的成员，向vector对象的末尾添加元素。<br><span class="hljs-number">22.</span> 范围<span class="hljs-keyword">for</span>语句：一种控制语句，可以在值的一个特定集合内迭代。<br><span class="hljs-number">23.</span> size：是string和vector对象的成员，分别返回字符的数量或者元素的数量。返回值的类型是size_type。<br><span class="hljs-number">24.</span> <span class="hljs-keyword">size_t</span>：是cstddef头文件中定义的一种与机器实现相关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。<br><span class="hljs-number">25.</span> size_type：是string或vector定义的类型的名字，能存放下任意string或者vector对象的大小。在标准库中，size_type被定义为无符号类型。<br><span class="hljs-number">26.</span> string：一种标准库类型，表示字符的序列。<br><span class="hljs-number">27.</span> <span class="hljs-keyword">using</span>声明：令命名空间中的某个名字可以被程序直接使用。<span class="hljs-keyword">using</span> 命名空间::名字; <br><span class="hljs-number">28.</span> 值初始化：是一种初始化过程。内置类型初始化为<span class="hljs-number">0</span>，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值。<br><span class="hljs-number">29.</span> vector：是一种标准库类型，容纳某指定类型的一种元素。<br><span class="hljs-number">30.</span> ++运算符：迭代器和指针定义的递增运算符，执行“加一”操作可以使迭代器指向下一个元素。<br><span class="hljs-number">31.</span> []运算符：下标运算符返回的是一个对象。如果p是指针，n是整数，则p[n]与*(p + n)是等价的。<br><span class="hljs-number">32.</span> 箭头运算符：-&gt;，该运算符综合了解引用操作符和点操作，a-&gt;b等价于 (*a).b。<br><span class="hljs-number">33.</span> &lt;&lt;运算符：标准库类型string定义的输出运算符，负责输出string对象中的字符。<br><span class="hljs-number">34.</span> &gt;&gt;运算符：标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。<br><span class="hljs-number">35.</span> ！运算符：非运算符。<br><span class="hljs-number">36.</span> &amp;&amp;运算符：与运算符。<br><span class="hljs-number">37.</span> ||运算符：或运算符。<br></code></pre></td></tr></table></figure><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ol><li><p>重载运算符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> cpp语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。<br><span class="hljs-bullet">2.</span> 当运算符作用于类类型的运算对象时，用户可以自定义其含义。<br><span class="hljs-bullet">3.</span> 这种自定义的过程事实上是为已存在的运算符赋予了另一层含义，所以称之为重载运算符。<br><span class="hljs-bullet">4.</span> IO库的&gt;&gt;和&lt;&lt;以及string对象、vector对象和迭代器使用的运算符都是重载的运算符。<br><span class="hljs-bullet">5.</span> 使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。<br></code></pre></td></tr></table></figure></li><li><p>左值和右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用关键字decltype的时候，左值和右值也有所不同</span><br><span class="hljs-comment">//如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型</span><br><span class="hljs-comment">//假定p的类型是int*</span><br><span class="hljs-keyword">decltype</span>(*p); <span class="hljs-comment">//因为解引用运算符生成左值，所以decltype(*p)的结果是int&amp;</span><br><span class="hljs-comment">//因为取地址运算符生成右值，所以decltype(&amp;p)的结果是int**</span><br><span class="hljs-comment">//也就是说，结果是一个指向整型指针的指针</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="优先级和结合律"><a href="#优先级和结合律" class="headerlink" title="优先级和结合律"></a>优先级和结合律</h4><ol><li><p>练习 4.1 表达式5 + 10 * 20 / 2的求值结果是多少？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">105<br></code></pre></td></tr></table></figure></li><li><p>练习 4.2 根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*vec.<span class="hljs-built_in">begin</span>();<br>*vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//在本题涉及的运算符中，优先级最高的是成员选择运算符和函数调用运算符，其次是解引用运算符</span><br><span class="hljs-comment">//最后是加法运算符</span><br><span class="hljs-comment">//因此添加括号后等价的式子是：</span><br>*(vec.<span class="hljs-built_in">begin</span>());<br>(*(vec.<span class="hljs-built_in">begin</span>())) + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><ol><li><p>求值顺序、优先级、结合律</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值</span><br><span class="hljs-comment">//在大多数情况下，不会明确指定求值的顺序</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-built_in">f1</span>() * <span class="hljs-built_in">f2</span>();<br><span class="hljs-comment">//f1和f2一定会在执行乘法之间被调用，但是无法确定f1和f2的调用顺序</span><br><span class="hljs-comment">//对于那些没有指定执行顺序的运算符来说</span><br><span class="hljs-comment">//如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;++i&lt;&lt;endl;<br><span class="hljs-comment">//因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求++i的值再求i的值</span><br><span class="hljs-comment">//此时输出结果就是1 1</span><br><span class="hljs-comment">//也可能先求i的值再求++i的值，输出结果就是 0 1</span><br><span class="hljs-comment">//甚至编译器还可能做完全不同的操作</span><br><span class="hljs-comment">//因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的</span><br></code></pre></td></tr></table></figure></li><li><p>四种明确规定了运算对象求值顺序的运算符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> &amp;&amp; 逻辑与运算符<br><span class="hljs-bullet">2.</span> || 逻辑或运算符<br><span class="hljs-bullet">3.</span> ?: 三目运算符<br><span class="hljs-bullet">4.</span> , 逗号运算符<br></code></pre></td></tr></table></figure></li><li><p>练习 4.3 cpp语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受嘛？请说出你的理由。</p></li></ol><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><ol><li><p>除非另作特殊说明，算数运算符都能作用于任意算数类型，以及任意能转换为算术类型的类型。</p></li><li><p>算数运算符的运算对象和求值结果都是右值。</p></li><li><p>在表达式求值之前，小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。</p></li><li><p>一元正号运算符、加法运算符和减法运算符都能作用于指针。</p></li><li><p>当一元正号运算符作用于一个指针或者算数值时，返回运算对象值的一个副本。</p></li><li><p>一元负号运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">bool</span> b = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">bool</span> b1 = -b; <span class="hljs-comment">//b1是true</span><br><span class="hljs-comment">//对于大多数运算符来说，布尔类型的运算对象被提升为int类型。</span><br><span class="hljs-comment">//如上所示，布尔变量b的值为真，参与运算时将被提升为整数值1</span><br><span class="hljs-comment">//求负后的结果是 -1</span><br><span class="hljs-comment">//将-1再转换成布尔值，因为不为0，所以转换结果为true</span><br></code></pre></td></tr></table></figure></li><li><p>除法运算中，商一律向0取整，也就是直接切除小数部分。</p></li><li><p>如果m%n的运算结果不为0，则它的符号和m相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">21</span> % <span class="hljs-number">6</span> == <span class="hljs-number">3</span>;                            <br><span class="hljs-number">21</span> % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>;<br><span class="hljs-number">-21</span> % <span class="hljs-number">-8</span> == <span class="hljs-number">-5</span>;<br><span class="hljs-number">21</span> % <span class="hljs-number">-5</span> == <span class="hljs-number">1</span>;<br><span class="hljs-number">21</span> / <span class="hljs-number">6</span> == <span class="hljs-number">3</span>;<br><span class="hljs-number">21</span> / <span class="hljs-number">7</span> == <span class="hljs-number">3</span>;<br><span class="hljs-number">-21</span> / <span class="hljs-number">-8</span> == <span class="hljs-number">2</span>;<br><span class="hljs-number">21</span> / <span class="hljs-number">-5</span> == <span class="hljs-number">-4</span>;<br></code></pre></td></tr></table></figure></li><li><p>练习4.4 加括号，说明其求值的过程以及最终的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">12</span> / <span class="hljs-number">3</span> * <span class="hljs-number">4</span> + <span class="hljs-number">5</span> * <span class="hljs-number">15</span> + <span class="hljs-number">24</span> % <span class="hljs-number">4</span> / <span class="hljs-number">2</span> == <span class="hljs-number">91</span><br></code></pre></td></tr></table></figure></li><li><p>练习4.5 写出下列表达式的求值结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a) <span class="hljs-number">-30</span> * <span class="hljs-number">3</span> + <span class="hljs-number">21</span> / <span class="hljs-number">5</span> == <span class="hljs-number">-86</span><br>(b) <span class="hljs-number">-30</span> + <span class="hljs-number">3</span> * <span class="hljs-number">21</span> / <span class="hljs-number">5</span> == <span class="hljs-number">-18</span><br>(c) <span class="hljs-number">30</span> / <span class="hljs-number">3</span> * <span class="hljs-number">21</span> / <span class="hljs-number">5</span> == <span class="hljs-number">0</span><br>(d) <span class="hljs-number">-30</span> / <span class="hljs-number">3</span> * <span class="hljs-number">21</span> % <span class="hljs-number">4</span> == <span class="hljs-number">-2</span><br></code></pre></td></tr></table></figure></li><li><p>练习4.6 写出一条表达式用于确定一个整数是奇数还是偶数。</p></li><li><p>练习4.7 溢出是何含义？ 写出三条导致溢出的表达式。</p></li></ol><h4 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h4><ol><li><p>短路求值：逻辑与和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用逻辑或的例子</span><br><span class="hljs-comment">//假定有一个存储若干string对象的vector对象</span><br><span class="hljs-comment">//要求输出string对象的内容</span><br><span class="hljs-comment">//在遇到空字符串或者以句号结束的字符串时进行转换</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;s : text)&#123;<br>    cout&lt;&lt;s;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>() || s[<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">&quot;.&quot;</span>)&#123;<br>        cout&lt;&lt;endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//值得注意的是</span><br><span class="hljs-comment">//s被声明成了对常量的引用</span><br><span class="hljs-comment">//因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝</span><br><span class="hljs-comment">//又因为不需要对string对象做写操作</span><br><span class="hljs-comment">//所以s被声明成对常量的引用</span><br></code></pre></td></tr></table></figure></li><li><p>在进行比较运算的时候除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(val == <span class="hljs-literal">true</span>)&#123;<br>    <br>&#125;<br><span class="hljs-comment">//如果val不是布尔值，那么进行比较之前会把true转换成val的类型</span><br><span class="hljs-comment">//假设val是int类型的</span><br><span class="hljs-comment">//上述式子等价于</span><br><span class="hljs-keyword">if</span>(val == <span class="hljs-number">1</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习4.8 说明逻辑与、逻辑或和相等性运算符中运算对象求值的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//逻辑与和逻辑或运算符：短路求值</span><br><span class="hljs-comment">//相等性运算符：两个运算对象都要求值，cpp没有规定其求值的顺序。</span><br></code></pre></td></tr></table></figure></li><li><p>练习4.9 解释在下面的if语句中条件判断的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-keyword">if</span>(cp &amp;&amp; *cp)&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-comment">//cp是指向字符串的指针</span><br><span class="hljs-comment">//因此上式的条件部分含义是首先检查指针cp是否有效</span><br><span class="hljs-comment">//如果cp为空指针或者无效指针，则条件不满足</span><br><span class="hljs-comment">//如果cp有效，即cp指向了内存中的某个有效地址</span><br><span class="hljs-comment">//继续解引用指针cp并检查cp所指的对象是否为空字符串&#x27;\0&#x27;</span><br><span class="hljs-comment">//如果cp所指的对象不是空字符串则条件满足，否则不满足</span><br></code></pre></td></tr></table></figure></li><li><p>练习4.10 为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(cin &gt;&gt; num &amp;&amp; num != <span class="hljs-number">42</span>)&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-comment">//首先检查输入流数据是否正常，然后判断当前读入的数字是否是42</span><br><span class="hljs-comment">//遇到42则条件不满足，退出循环</span><br></code></pre></td></tr></table></figure></li><li><p>练习4.11 书写一条表达式用于测试a，b，c和d的关系，确保a大于b，b大于c，c大于d。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a &gt; b &amp;&amp; b &gt; c &amp;&amp; c &gt; d<br></code></pre></td></tr></table></figure></li><li><p>练习4.12 假设i，j和k是三个 整数，说明下述表达式的含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i != k &lt; j;<br><span class="hljs-comment">//cpp规定 &lt; &lt;= &gt; &gt;=的优先级高于==和!=</span><br><span class="hljs-comment">//因此上式的求值过程等同于 i != (k &lt; j)</span><br><span class="hljs-comment">//意即先比较j和k的大小，然后得到一个布尔值，最后判断i的值和这个布尔值是否相等</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ol><li><p>赋值运算的结果是它的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧的运算对象将转换成左侧运算对象的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>k = <span class="hljs-number">1</span>; <span class="hljs-comment">//结果，类型是int，值为1</span><br>k = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//结果，类型是int，值为3</span><br></code></pre></td></tr></table></figure></li><li><p>cpp11允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">k = &#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">//错误，窄化运算</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v1; <span class="hljs-comment">//初始为空</span><br>v1 = &#123;<span class="hljs-number">0</span> ,<span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,<span class="hljs-number">3</span> ,<span class="hljs-number">4</span> ,<span class="hljs-number">5</span> ,<span class="hljs-number">6</span> ,<span class="hljs-number">7</span> ,<span class="hljs-number">8</span> ,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">//如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值</span><br><span class="hljs-comment">//而且该值即使转换，其所占的空间也不应该大于目标类型的空间</span><br><span class="hljs-comment">//对于类类型来说，赋值运算的细节由类本身决定。</span><br><span class="hljs-comment">//对于vector来说，vector模板重载了赋值运算符并且可以接收初始值列表</span><br><span class="hljs-comment">//当赋值发生时，用右侧运算对象的元素替换左侧运算对象的元素</span><br></code></pre></td></tr></table></figure></li><li><p>赋值运算符满足右结合律。对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival, *pval;<br>ival = pval = <span class="hljs-number">0</span>; <span class="hljs-comment">//错误，不能把指针的值赋给int</span><br>string s1, s2;<br>s1 = s2 = <span class="hljs-string">&quot;ok&quot;</span>； <span class="hljs-comment">//字符串字面值转换成&quot;ok&quot;；</span><br></code></pre></td></tr></table></figure></li><li><p>赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>((i = <span class="hljs-built_in">get_value</span>()) != <span class="hljs-number">42</span>)&#123;<br>    <span class="hljs-comment">//处理过程是首先将get_value函数的返回值赋给i，然后比较i和42是否相等</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 4.13 在下列语句中，完成赋值后i和d的值分别都是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">double</span> d;<br>d = i = <span class="hljs-number">3.5</span>;<br>i = d = <span class="hljs-number">3.5</span>;<br><span class="hljs-comment">//赋值运算符左右两个运算对象的类型不同，则右侧运算对象转换成左侧运算对象的类型</span><br><span class="hljs-comment">//赋值运算符满足右结合律</span><br><span class="hljs-comment">//第一个式子的含义是先把3.5赋给整数i</span><br><span class="hljs-comment">//此时发生了自动类型转换，小数部分被舍弃，i的值为3</span><br><span class="hljs-comment">//接着i的值再赋给双精度浮点数d，所以d的值也是3.0</span><br><span class="hljs-comment">//第二个式子的含义是先把3.5赋值给双精度浮点数d，因此d的值是3.5</span><br><span class="hljs-comment">//接着d的值再赋给整数i</span><br><span class="hljs-comment">//此时发生了自动类型转换，小数部分被舍弃，i的值为3</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.14 执行下述if语句后将发生什么情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-number">42</span> = i)&#123;<br>    <span class="hljs-comment">/**/</span><br>&#125;<br><span class="hljs-comment">//编译错误，赋值运算符的左侧必须是左值</span><br><span class="hljs-comment">//字面值常量42显然不是左值，不能作为左侧运算对象</span><br><span class="hljs-keyword">if</span>(i = <span class="hljs-number">42</span>)&#123;<br>    <span class="hljs-comment">//从语法上来说是正确的</span><br>    <span class="hljs-comment">//但是 i = 42 的返回值是42，所以条件永远为真</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 4.15 下面的赋值是非法的，为什么？应该如何修改？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> dval;<br><span class="hljs-keyword">int</span> ival;<br><span class="hljs-keyword">int</span> *pi;<br>dval = ival = pi = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//pi = 0表示pi是一个空指针</span><br><span class="hljs-comment">//ival = pi试图把整型指针的值赋给整数，这是不符合语法规范的操作，无法编译通过</span><br><span class="hljs-comment">//把上述程序改成合法的情况如下</span><br><span class="hljs-keyword">double</span> dval;<br><span class="hljs-keyword">int</span> ival;<br><span class="hljs-keyword">int</span> *pi;<br>dval = ival = <span class="hljs-number">0</span>;<br>pi = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>练习 4.16 尽管下面的语句合法，但是它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(p = <span class="hljs-built_in">getPtr</span>() != <span class="hljs-number">0</span>)&#123;<br>    <br>&#125;<br><span class="hljs-comment">//修改为</span><br><span class="hljs-keyword">if</span>((p = <span class="hljs-built_in">getPtr</span>()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//原意是判断是否是一个空指针</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><ol><li><p>很多迭代器不支持算数运算，所以有些时候递增运算符和递减运算符是必须的。</p></li><li><p>递增运算符和递减运算符的前置版本和后置版本。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 这两种运算符必须作用于左值运算对象。<br><span class="hljs-bullet">2.</span> 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。<br><span class="hljs-bullet">3.</span> 建议：出于性能的考虑，除非必须，否则不用递增递减运算符的后置版本。<br></code></pre></td></tr></table></figure></li><li><p>在一条语句中混用解引用操作符和递增运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> pbeg = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(pbeg != v.<span class="hljs-built_in">end</span>() &amp;&amp; *pbeg &gt;= <span class="hljs-number">0</span>)&#123;<br>    cout&lt;&lt; *pbeg++ &lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//后置运算符的优先级高于解引用运算符，因此*pbeg++等价于 *(pbeg++)</span><br></code></pre></td></tr></table></figure></li><li><p>运算对象可按照任意顺序求值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话</span><br><span class="hljs-comment">//运算对象的求值顺序会变的非常关键</span><br><span class="hljs-comment">//递增运算符和递减运算符会改变运算对象的值所，所以要提防在复合表达式中错用这两个运算符</span><br><span class="hljs-comment">//下面这个循环就是一个错误的示例</span><br><span class="hljs-keyword">while</span>(beg != s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*beg))&#123;<br>    *beg = <span class="hljs-built_in">toupper</span>(*beg++); <span class="hljs-comment">//错误，该赋值语句未定义</span><br>&#125;<br><span class="hljs-comment">//问题在于：赋值运算符左右两端的运算对象都用到了beg</span><br><span class="hljs-comment">//并且右侧的运算对象还改变了beg的值，所以该赋值语句是未定义的</span><br><span class="hljs-comment">//编译器可能按照下面的任意一种思路处理该表达式</span><br>*beg = <span class="hljs-built_in">toupper</span>(*beg); <span class="hljs-comment">//如果先求左侧的值</span><br>*(beg + <span class="hljs-number">1</span>) = <span class="hljs-built_in">toupper</span>(*beg) <span class="hljs-comment">//如果先求右侧的值</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.17 说明前置递增运算符的区别和后置递增运算符的区别。</p></li><li><p>练习 4.18 如果第132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果这样做了，将会产生两个错误</span><br><span class="hljs-comment">//一是无法输出vector对象的第一个元素</span><br><span class="hljs-comment">//二是当所有元素都不为负时，移动到最后一个元素的地方</span><br><span class="hljs-comment">//程序试图继续向前移动迭代器并且解引用一个根本不存在的元素</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.19 假设ptr的类型是指向int的指针、vec的类型是vector&lt; int &gt;、ival的类型是int，说明下列表达式是何含义？如果有表达式不正确，为什么？应该如何修改？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a)ptr != <span class="hljs-number">0</span> &amp;&amp; *ptr++;<br><span class="hljs-comment">//(a)的含义时先判断指针ptr是否为空</span><br><span class="hljs-comment">//如果不为空，继续判断指针ptr所指的整数是否为0</span><br><span class="hljs-comment">//最后指针ptr向右移动一位</span><br>(b)ival++ &amp;&amp; ival;<br><span class="hljs-comment">//先判断ival是否为0</span><br><span class="hljs-comment">//再判断ival + 1是否为0</span><br>(c)vec[ival++] &lt;= vac[ival];<br><span class="hljs-comment">//这是一种未定义的情况</span><br><span class="hljs-comment">//如果先算左边 vec[ival] &lt;= vec[ival + 1]</span><br><span class="hljs-comment">//如果先算右边 vec[ival] &lt;= vec[ival];</span><br><span class="hljs-comment">//程序可能出现未定义的行为</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h4><ol><li><p>点运算符和箭头运算符都可以用于访问成员，其中，点运算符用于获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr-&gt;mem等价于(*ptr).mem。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1 = <span class="hljs-string">&quot;a string&quot;</span>, *p = &amp;s1;<br><span class="hljs-keyword">auto</span> n = si.<span class="hljs-built_in">size</span>();<br>n = (*p).<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//运行p所指对象的size成员</span><br>n = p-&gt;<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//等价于(*p).size()</span><br></code></pre></td></tr></table></figure></li><li><p>解引用运算符的优先级低于点运算符。</p></li><li><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</p></li><li><p>点运算符分为两种情况：如果成员所属对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p></li><li><p>练习 4.20 假设iter的类型是 vector&lt; string &gt;::iterator，说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a)*iter++;<br><span class="hljs-comment">//合法的，后置递增运算符的优先级高于解引用运算符；</span><br><span class="hljs-comment">//其含义是，解引用当前迭代器所处位置的内容，然后把迭代器的内容向后移动一位。</span><br>(b)(*iter)++;<br><span class="hljs-comment">//非法的，解引用iter是一个string对象</span><br><span class="hljs-comment">//string对象不支持递增运算符</span><br>(c)*iter.<span class="hljs-built_in">empty</span>();<br><span class="hljs-comment">//非法的，点运算符的优先级高于解引用运算符</span><br>(d)iter-&gt;<span class="hljs-built_in">empty</span>();<br><span class="hljs-comment">//合法的，等价于(*iter).empty()</span><br>(e)++*iter;<br><span class="hljs-comment">//非法的，string没有前置递增操作</span><br>(f)iter++-&gt;<span class="hljs-built_in">empty</span>();<br><span class="hljs-comment">//合法的，(*iter++).empty()</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><ol><li><p>cond ? expr1 : expr2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cond是判断条件的表达式。</span><br><span class="hljs-comment">//expr1和expr2是两个类型相同或者可以转换成为某个公共类型的表达式。</span><br></code></pre></td></tr></table></figure></li><li><p>当条件运算符的两个表达式都是左值或者能转换成同一左值类型的时候，运算的结果是左值，否则运算的结果是右值。</p></li><li><p>练习 4.21 编写一段程序，使用条件运算符从vector&lt; int &gt;中找到哪些元素是奇数，然后将这些奇数值翻倍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>; <span class="hljs-comment">//sz是向量的维度</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>cout &lt;&lt; <span class="hljs-string">&quot;数组的初始值是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>);<br>cout &lt;&lt; vInt[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">//使用范围for循环把数组中的奇数翻倍</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; val : vInt) &#123;<br>val = (val % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) ? val * <span class="hljs-number">2</span> : val;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;处理后数组的值为：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>cout &lt;&lt; vInt[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 4.22  本节的示例程序将成绩划分为high pass、pass和fail三种，扩展该程序使其进一步将60分到75分之间的成绩设定为low pass。要求程序包含两个版本，一个版本只使用条件运算符；另一个版本使用1个或者多个if语句。哪个版本的程序更容易理解呢？为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在这里只写用条件运算符的实现方法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string finalgrade;<br><span class="hljs-keyword">int</span> grade;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入您要检查的成绩：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//确保输入的成绩合法</span><br><span class="hljs-keyword">while</span> (cin &gt;&gt; grade &amp;&amp; grade &gt;= <span class="hljs-number">0</span> &amp;&amp; grade &lt;= <span class="hljs-number">100</span>) &#123;<br>finalgrade = (grade &gt; <span class="hljs-number">90</span>) ? <span class="hljs-string">&quot;high pass&quot;</span> :<br>(grade &gt; <span class="hljs-number">75</span>) ? <span class="hljs-string">&quot;pass&quot;</span> :<br>(grade &gt; <span class="hljs-number">60</span>) ? <span class="hljs-string">&quot;low pass&quot;</span> : <span class="hljs-string">&quot;fail&quot;</span>;<br>cout &lt;&lt; finalgrade &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入您要检查的成绩：&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 4.23 因为运算符的优先级问题，下面这条表达式无法通过编译。根据4.12节中的表指出它的问题在哪里？应该如何修改？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s = <span class="hljs-string">&quot;word&quot;</span>;<br>string p1 = s + s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;s&#x27;</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-comment">//几个运算符的优先级从高到低分别是 加法运算符 相等运算符 条件运算符和赋值运算符</span><br><span class="hljs-comment">//因此式子的求值过程是先把s和s[s.size() - 1]相加得到一个新字符串，然后该字符串与字符&#x27;s&#x27;比较是否相等</span><br><span class="hljs-comment">//这是一个非法操作，并且与程序的原意不服</span><br><span class="hljs-comment">//经过修改之后的语句为</span><br>string p1 = s + (s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;s&#x27;</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot;s&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>练习 4.24 本节是示例程序将程序划分为high pass、pass和fail三种，它的依据是条件运算符满足右结合律。假设条件运算符满足的是左结合律，求值过程该是怎样的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//原文的程序如下</span><br>finalgrade = (grade &gt; <span class="hljs-number">90</span>) ? <span class="hljs-string">&quot;high pass&quot;</span> <br>    : (grade &lt; <span class="hljs-number">60</span>) ? <span class="hljs-string">&quot;fail&quot;</span> : <span class="hljs-string">&quot;pass&quot;</span>;<br><span class="hljs-comment">//如果满足左结合率，该式等价于：</span><br>finalgrade = ((grade &gt; <span class="hljs-number">90</span>) ? <span class="hljs-string">&quot;high pass&quot;</span> : (grade &lt; <span class="hljs-number">60</span>)) <br>? <span class="hljs-string">&quot;fail&quot;</span> : <span class="hljs-string">&quot;pass&quot;</span>;<br><span class="hljs-comment">//先考察grade &gt; 90是否成立，</span><br><span class="hljs-comment">//如果成立，第一个条件表达式的值为 &quot;high pass&quot;</span><br><span class="hljs-comment">//如果不成立，第一个条件表达式的值为(grade &lt; 60)</span><br><span class="hljs-comment">//这条语句是无法编译通过的，因为条件运算符要求两个结果表达式的类型相同或者可以相互转化</span><br><span class="hljs-comment">//即使语法上通过，也就是说，第一个条件表达式求值的结果分为三种</span><br><span class="hljs-comment">//分别是high pass, 1, 0</span><br><span class="hljs-comment">//接下来根据第一个条件表达式的结果求解第二个条件表达式</span><br><span class="hljs-comment">//求值结果应该是&quot;fail&quot;或&quot;pass&quot;，上述求值结果显然是与我们的期望不符的</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ol><li><p>位运算符作用于整数类型的运算对象，并且把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能。</p></li><li><p>一种名为bigset的标准库类型也可以表示任意大小的二进制位的集合，所以位运算符同样能作用于bigset类型。</p></li><li><p>一般来说，如果运算对象是‘小整型’，则它的值会被自动提升为较大的整数类型。</p></li><li><p>运算对象可以是有符号数，也可以是无符号数。如果运算对象是有符号数并且它的值为负，位运算符如何处理符号位依赖于机器，此时的左移操作可能会改变符号位的值，因此是一种未定义的操作。所以强烈建议仅将位运算符用于处理无符号类型。</p></li><li><p>一个使用位运算符的例子：假设班级中有30个学生，老师每周都会对学生进行一次小测验，测验的结果只有通过和不通过两种。为了更好的追踪测验的结果，用一个二进制位代表某个学生在一次测验中是否通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//显然全班的测验结果可以用一个无符号整数来表示</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> quiz1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//quiz1的类型是unsigned long，在任何机器上都至少有32位</span><br><span class="hljs-comment">//使用左移运算符和一个unsigned long类型的整数字面值1就能得到一个表示某学生通过的数值</span><br><span class="hljs-number">1UL</span> &lt;&lt; n; <span class="hljs-comment">//生成一个值，该值只有第n位为1</span><br>quiz1 |= <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">27</span>; <span class="hljs-comment">//表示学生27通过了测验 </span><br><span class="hljs-comment">//如果核查的时候发现学生27其实并没有通过测验</span><br>quiz1 &amp;= ~( <span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">27</span>);<br><span class="hljs-comment">//试图检查学生27究竟有没有通过测验</span><br><span class="hljs-keyword">bool</span> status = quiz1 &amp; (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure></li><li><p>移位运算符满足左结合率。</p></li><li><p>练习 4.25 如果一台机器上int占32位，char占8位，用的是Latin-1字符集，其中字符’q’的形式是01110001，那么表达式 ~’q’ &lt;&lt; 6的值是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在位运算符中，运算符~的优先级高于移位运算符</span><br><span class="hljs-comment">//因为位运算符作用的运算对象应该是整数类型，所以字符q首先转换为整数类型</span><br><span class="hljs-comment">//转化的结果是00000000 00000000 00000000 01110001</span><br><span class="hljs-comment">//取反的结果是11111111 11111111 11111111 10001110</span><br><span class="hljs-comment">//移位的结果是11111111 11111111 11100011 10000000</span><br><span class="hljs-comment">//cpp规定整数按照补码形式存储，对上式求补，即最终结果的二进制形式，转换成十进制是-7296</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.26 在本节关于测验成绩的例子中，如果使用unsigned int作为quiz1的类型会发生什么情况？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp规定unsigned int所占空间的最小值是16</span><br><span class="hljs-comment">//所以在很多机器类型中，该数据类型不足以存放全部学生的信息</span><br><span class="hljs-comment">//从而造成了信息丢失</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.27 下列表达式的结果是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ul1 = <span class="hljs-number">3</span>, ul2 = <span class="hljs-number">7</span>;<br>(<span class="hljs-number">1</span>) ul1 &amp; ul2; <span class="hljs-comment">//3</span><br>(<span class="hljs-number">2</span>) ul1 | ul2; <span class="hljs-comment">//7</span><br>(<span class="hljs-number">3</span>) ul1 &amp;&amp; ul2; <span class="hljs-comment">//1，结果为true</span><br>(<span class="hljs-number">4</span>) ul1 || ul2; <span class="hljs-comment">//1，结果为true</span><br><span class="hljs-comment">//ul1 00000000 00000000 00000000 00000011</span><br><span class="hljs-comment">//ul2 00000000 00000000 00000000 00000111</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><ol><li><p>sizeof运算符返回一条表达式或者一个类型所占的字节数。sizeof并不实际计算其运算对象的值。</p></li><li><p>sizeof运算符满足右结合率，其所得的值是一个size_t类型的常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//运算符的运算对象有两种形式</span><br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span> (type)<br><span class="hljs-keyword">sizeof</span> expr<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Sales_data data, *p;<br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(Sales_data);  <span class="hljs-comment">//存储对应类型的对象所占的空间大小</span><br><span class="hljs-keyword">sizeof</span> data;         <span class="hljs-comment">//和上面的语句等价</span><br><span class="hljs-keyword">sizeof</span> p;            <span class="hljs-comment">//指针所占的空间的大小</span><br><span class="hljs-keyword">sizeof</span> *p;           <span class="hljs-comment">//p所指对象所占的空间的大小</span><br><span class="hljs-keyword">sizeof</span> Sales_data.revenue;   <span class="hljs-comment">//Sales_data的revenue成员对应类型的大小</span><br><span class="hljs-keyword">sizeof</span> Sales_data::revenue;  <span class="hljs-comment">//和上一句代码等价</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//详解sizeof *p</span><br><span class="hljs-comment">//sizeof满足右结合律并且和*运算符的优先级是一致的</span><br><span class="hljs-comment">//所以表达式按照从右向左的顺序组合，所以，上式等价于</span><br><span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*p);<br><span class="hljs-comment">//因为sizeof不会实际求运算对象的值</span><br><span class="hljs-comment">//所以即使p是一个无效，即未初始化的指针，也不会有什么影响</span><br><span class="hljs-comment">//sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有真正被用到</span><br><span class="hljs-comment">//sizeof不需要真的解引用指针也能知道他所指对象的类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span>* p;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span> * p &lt;&lt; endl; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cpp11新标准允许使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。</p></li><li><p>sizeof运算符的结果部分地依赖于其作用的类型：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 对char或者类型为char的表达式执行sizeof运算，结果为1。<br><span class="hljs-bullet">2.</span> 对引用类型执行sizeof运算得到被引用对象所占空间的大小。<br><span class="hljs-bullet">3.</span> 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。<br><span class="hljs-bullet">4.</span> 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素各执行一次sizeof运算并将所得结果求和。注意，sizeof不会把数组名转换成指针处理。<br><span class="hljs-bullet">5.</span> 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//sizeof(ia) / sizeof(*ia) 返回ia元素的数量</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> sz = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ia) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*ia);<br><span class="hljs-keyword">int</span> arr2[sz];<span class="hljs-comment">// 正确，sizeof返回一个常量表达式</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.28 编写一段程序，输出每种内置类型所占的空间的大小。</p></li><li><p>练习 4.29 推断下面代码的输出结果并说明理由。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> x[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">int</span> *p = x;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(x) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*x)&lt;&lt;endl; <span class="hljs-comment">//10，经典的求数组元素个数的方法</span><br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(p) / <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(*p)&lt;&lt;endl;<br><span class="hljs-comment">//sizeof(p)，p是一个指针，求值结果是指针所占空间的大小</span><br><span class="hljs-comment">//sizeof(*p)的运算对象*p是指针p所指的对象，即int变量x，所以求值结果是int值所占空间的大小</span><br><span class="hljs-comment">//int占4字节，指针占4字节，所以第二条语句的结果为1</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.30 在下述表达式的适当位置加上括号，使得加上括号之后的表达式与原来的含义相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//sizeof的优先级高于加法运算符的优先级</span><br><span class="hljs-comment">//所以该条语句的含义是先求x所占空间的大小然后与y相加</span><br>(<span class="hljs-number">1</span>)<span class="hljs-keyword">sizeof</span> x + y; <span class="hljs-comment">//(sizeof x) + y;</span><br><span class="hljs-comment">//成员选择运算符的优先级高于sizeof的优先级，所以本例无须添加括号</span><br>(<span class="hljs-number">2</span>)<span class="hljs-keyword">sizeof</span> p-&gt;mem[i];<br><span class="hljs-comment">//sizeof的优先级高于关系运算符的优先级</span><br>(<span class="hljs-number">3</span>)<span class="hljs-keyword">sizeof</span> a &lt; b;<br><span class="hljs-comment">//函数调用运算符的优先级高于sizeof优先级，所以无须添加括号</span><br>(<span class="hljs-number">4</span>)<span class="hljs-function"><span class="hljs-keyword">sizeof</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><ol><li><p>逗号运算符规定了运算对象的求值顺序。</p></li><li><p>练习 4.31 本节的程序使用了前置版本递增运算符和递减运算符，解释为什么要使用前置版本而不是后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节的程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//本题从程序运行结果来说，使用前置版本和后置版本是一样的</span><br><span class="hljs-comment">//因为递增运算符和递减运算符与真正使用这两个变量的语句位于不同的表达式中</span><br><span class="hljs-comment">//但是出于性能方面的考虑，后置版本需要将原始值存储下来以便于返回这个未修改的内容</span><br><span class="hljs-comment">//如果不需要修改之前的值，那么后置版本的操作就是一种浪费</span><br><span class="hljs-comment">//综上，就本题而言，前置版本是更好的选择</span><br></code></pre></td></tr></table></figure></li><li><p>练习 4.32 解释下面这个循环的含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> ia[size] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *ptr = ia, ix = <span class="hljs-number">0</span>; ix != size &amp;&amp; ptr != ia + size; ++ix, ++ptr)&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习 4.33 根据4.12节中的表，说明下面这条表达式的含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">someValue ? ++x, ++y : --x, --y;<br><span class="hljs-comment">//cpp规定条件运算符优先级高于逗号运算符</span><br><span class="hljs-comment">//所以someValue ? ++x, ++y : --x, --y等价于(someValue ? ++x, ++y : --x), --y</span><br><span class="hljs-comment">//如果someValue为真，则执行 ++x ++y --y</span><br><span class="hljs-comment">//如果someValue为假，则执行 --x --y</span><br></code></pre></td></tr></table></figure></li></ol><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter4&lt;/p&gt;
&lt;p&gt;第三章内容的总结 + 部分第四章内容&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_4_40</title>
    <link href="http://example.com/cpp-primer-4-40/"/>
    <id>http://example.com/cpp-primer-4-40/</id>
    <published>2021-05-24T07:29:34.000Z</published>
    <updated>2021-05-25T14:15:58.016Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter3</p><p>主要内容包括迭代器、数组和多维数组。</p><span id="more"></span><h4 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h4><ol><li><p>使用迭代器可以访问标准库中容器的元素。</p></li><li><p>所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</p></li><li><p>严格来说，string对象不属于容器类型，但是string支持很多与容器类型类似的操作。vector支持下标运算符，这点和string一样；string支持迭代器，这也和vector一样。</p></li><li><p>迭代器与指针类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//类似于指针类型，迭代器也提供了对对象的间接访问。</span><br><span class="hljs-comment">//就迭代器而言，其对象是容器中的元素或者string对象中的字符。</span><br><span class="hljs-comment">//使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。</span><br><span class="hljs-comment">//迭代器有有效和无效之分</span><br><span class="hljs-comment">//有效的迭代器：</span><br><span class="hljs-comment">//（1）指向某个元素</span><br><span class="hljs-comment">//（2）指向容器中尾元素的下一位置</span><br><span class="hljs-comment">//其它所有的情况都属于无效</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//和指针不一样的是，获取迭代器不是使用取地址符</span><br><span class="hljs-comment">//如果一个类型有迭代器，那么它肯定拥有能返回迭代器的成员</span><br><span class="hljs-comment">//比如，这些类型都拥有名为begin和end的成员</span><br><span class="hljs-comment">//其中begin成员负责返回指向第一个元素（或者第一个字符）的迭代器</span><br><span class="hljs-comment">//end成员则负责返回指向容器（或者string对象）“尾元素的下一个位置”的迭代器</span><br><span class="hljs-comment">//也就是说，该迭代器指示的是容器本不存在的一个“尾后”元素。</span><br><span class="hljs-comment">//这样的迭代器本身并没有什么实际含义</span><br><span class="hljs-comment">//它的作用就是表示我们已经处理完了容器中的所有元素</span><br><span class="hljs-comment">//如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//由编译器决定b和e的类型</span><br><span class="hljs-comment">//b表示v的第一个元素，e表示v尾元素的下一个位置</span><br><span class="hljs-keyword">auto</span> b = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> e = v.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">//b和e的类型是相同的</span><br></code></pre></td></tr></table></figure></li><li><p>迭代器运算符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> \<span class="hljs-emphasis">*iter 返回迭代器iter所指元素的引用。</span><br><span class="hljs-emphasis">2. iter-&gt;mem 解引用iter并获取该元素名为mem的成员，等价于(\*</span>iter).mem。<br><span class="hljs-bullet">3.</span> ++iter 令iter指向容器中的下一个元素<br><span class="hljs-bullet">4.</span> --iter 令iter指向容器中的上一个元素<br><span class="hljs-bullet">5.</span> iter1 == iter2 <br><span class="hljs-bullet">6.</span> iter != iter2<br>对于5和6<br>判断两个迭代器是否相等<br>（1）如果两个迭代器指向的是同一个元素<br>（2）两个迭代器是同一个容器的尾后迭代器<br></code></pre></td></tr></table></figure></li><li><p>示例：把string对象的第一个字符改成大写形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">begin</span>() != s.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">//确保s非空</span><br>    <span class="hljs-keyword">auto</span> iter = s.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//iter表示s的第一个字符</span><br>    *iter = <span class="hljs-built_in">touper</span>(*iter); <span class="hljs-comment">//通过解引用拿到第一个字符的引用并做大小写转换</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或者解引用的操作。</p></li><li><p>示例：利用迭代器和递增运算符把string对象中第一个单词改为大写形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*it); ++it)&#123;<br>    *it = <span class="hljs-built_in">toupper</span>(*it); <span class="hljs-comment">//将当前字符改成大写的形式</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泛型编程：在cpp中使用迭代器和 != 会使程序有更强的通用性。因为所有标准库容器都定义了迭代器和==以及!=运算符。</p></li><li><p>拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it;  <span class="hljs-comment">//it能读写vector&lt;int&gt;的元素</span><br>string::iterator it2; <span class="hljs-comment">//it2能读写string对象中的字符</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it3; <span class="hljs-comment">//it3只能读元素，不能写元素</span><br>string::const_iterator it4; <span class="hljs-comment">//it4只能读字符，不能写字符</span><br><span class="hljs-comment">//const_iterator和常量指针差不多，能读取但是不能修改它所指的元素值</span><br><span class="hljs-comment">//iterator的对象可读可写</span><br><span class="hljs-comment">//如果vector对象或string对象是一个常量，只能使用const_iterator</span><br><span class="hljs-comment">//如果vector对象或string对象不是一个常量，两种迭代器都可以用</span><br></code></pre></td></tr></table></figure></li><li><p>begin和end返回的具体类型由对象是否的常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; cv;<br><span class="hljs-keyword">auto</span> it1 = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//it1的类型是vector&lt;int&gt;::iterator</span><br><span class="hljs-keyword">auto</span> it2 = cv.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">//it2的类型是vector&lt;int&gt;::const_iterator</span><br></code></pre></td></tr></table></figure></li><li><p>为了便于专门得到const_iterator类型的返回值，cpp11新标准引入了两个新函数，cbegin和cend：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it3 = v.<span class="hljs-built_in">cbegin</span>();<span class="hljs-comment">//it3的类型是vector&lt;int&gt;::const_iterator</span><br></code></pre></td></tr></table></figure></li><li><p>结合解引用和成员访问操作</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 解引用迭代器可以获得迭代器所指的对象。<br><span class="hljs-bullet">2.</span> 如果该对象的类型恰好是类，则有可能希望进一步访问它的成员。<br><span class="hljs-bullet">3.</span> 例如对于一个由字符串组成的vector对象来说，要检查其元素是否为空，令it是该vector对象的迭代器，只需要检查it所指字符串是否为空就可以了，代码如下所示：<br>（<span class="hljs-emphasis">*it）.empty();</span><br><span class="hljs-emphasis">注意*</span>it.empty(); //错误，试图访问it的名为empty的成员，但是it是个迭代器，没有empty成员<br></code></pre></td></tr></table></figure></li><li><p>箭头运算符（-&gt;）：把解引用和成员访问两个操作结合在一起：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//it——&gt;mem和(*it).mem是两个等价的表达式</span><br><span class="hljs-comment">//假设用一个名为text的字符串向量存放文本文件中的数据</span><br><span class="hljs-comment">//其中的元素或者是一句话，或者是一个用于表示段落分割的空字符串</span><br><span class="hljs-comment">//如果要输出text中第一段的内容</span><br><span class="hljs-comment">//可以令迭代器写一个循环遍历text，知道遇到空字符串时为止</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = text.<span class="hljs-built_in">cbegin</span>(); it != text.<span class="hljs-built_in">cend</span>() &amp;&amp; !it-&gt;<span class="hljs-built_in">empty</span>(); it++)&#123;<br>    result += (*it);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>某些对vector对象的操作会使迭代器失效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector对象可以动态的增长，但是也会有一些副作用。</span><br><span class="hljs-comment">//1. 不能在范围for循环中向vector对象添加元素</span><br><span class="hljs-comment">//2. 任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.21 请使用迭代器重做第3.3.3节的第一个练习</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v4&#123; <span class="hljs-number">10</span> &#125;;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v5&#123; <span class="hljs-number">10</span>, <span class="hljs-number">42</span> &#125;;<br>vector&lt;string&gt; v6&#123; <span class="hljs-number">10</span> &#125;;<br>vector&lt;string&gt; v7&#123; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的元素个数是：&quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">cbegin</span>() != v1.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v1.<span class="hljs-built_in">cbegin</span>(); it != v1.<span class="hljs-built_in">cend</span>(); it++) &#123;<br>cout &lt;&lt; *it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v2的元素个数是：&quot;</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v2.<span class="hljs-built_in">cbegin</span>()!=v2.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v2.<span class="hljs-built_in">cbegin</span>(); it != v2.<span class="hljs-built_in">cend</span>(); it++) &#123;<br>cout &lt;&lt; *it&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v3的元素个数是：&quot;</span> &lt;&lt; v3.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v3.<span class="hljs-built_in">cbegin</span>()!=v3.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v3.<span class="hljs-built_in">cbegin</span>(); it != v3.<span class="hljs-built_in">cend</span>(); it++) &#123;<br>cout &lt;&lt; *it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v4的元素个数是：&quot;</span> &lt;&lt; v4.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v4.<span class="hljs-built_in">cbegin</span>()!= v4.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v4.<span class="hljs-built_in">cbegin</span>(); it != v4.<span class="hljs-built_in">cend</span>(); it++) &#123;<br>cout &lt;&lt; *it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v5的元素个数是：&quot;</span> &lt;&lt; v5.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v5.<span class="hljs-built_in">cbegin</span>()!=v5.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v5.<span class="hljs-built_in">cbegin</span>(); it != v5.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v6的元素个数是：&quot;</span> &lt;&lt; v6.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v6.<span class="hljs-built_in">cbegin</span>()!=v6.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v6.<span class="hljs-built_in">begin</span>(); it != v6.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v7的元素个数是：&quot;</span> &lt;&lt; v7.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v7.<span class="hljs-built_in">cbegin</span>()!=v7.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v7.<span class="hljs-built_in">begin</span>(); it != v7.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.22 修改之前那个输出text第一段的程序，首先把text第一段全部改成大写形式，然后再输出它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;string&gt; text;<br>string s;<br><span class="hljs-comment">//利用getline读取一句话，直接回车产生一个空串，表示段落结束</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, s)) &#123;<br>text.<span class="hljs-built_in">push_back</span>(s);<br>&#125;<br>string result;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = text.<span class="hljs-built_in">begin</span>(); it != text.<span class="hljs-built_in">end</span>() &amp;&amp; !it-&gt;<span class="hljs-built_in">empty</span>(); it++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> charIter = it-&gt;<span class="hljs-built_in">begin</span>(); charIter != it-&gt;<span class="hljs-built_in">end</span>(); charIter++) &#123;<br>*charIter = <span class="hljs-built_in">toupper</span>(*charIter);<br>&#125;<br>result += *it;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;结果为：&quot;</span> &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.23  编写一段程序，创建一个含有10个整数的vector对象，然后使用迭代器将所有元素的值都变成原来的两倍，输出vector对象的内容，检验程序是否正确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">1000</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;随机生成的10个数字是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vInt.<span class="hljs-built_in">cbegin</span>(); it != vInt.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;修改后的10个数字是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vInt.<span class="hljs-built_in">begin</span>(); it != vInt.<span class="hljs-built_in">end</span>(); it++) &#123;<br>*it = *it * <span class="hljs-number">2</span>;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="迭代器计算"><a href="#迭代器计算" class="headerlink" title="迭代器计算"></a>迭代器计算</h4><ol><li><p>string和vector的迭代器提供了更多的额外运算符：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> iter + n<br><span class="hljs-bullet">2.</span> iter - n<br><span class="hljs-bullet">3.</span> iter1 += n<br><span class="hljs-bullet">4.</span> iter1 -= n<br><span class="hljs-bullet">5.</span> iter1 - iter2<br><span class="hljs-bullet">6.</span> 关系运算符 &gt; &lt; &gt;= &lt;=<br></code></pre></td></tr></table></figure></li><li><p>可以令迭代器和一个整数值相加（或者相减），其返回值是向前（或向后）移动了若干个位置的迭代器。执行这样的操作时，结果迭代器或者指向原vector对象（或string对象）内的一个元素，或者指向原vector对象（或者string对象）尾元素的下一个位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//计算得到最接近vi中间元素的一个迭代器</span><br><span class="hljs-keyword">auto</span> mid = vi.<span class="hljs-built_in">begin</span>() + vi.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>;<br><span class="hljs-comment">//如果vi有20个元素，vi.size() / 2 = 10;</span><br><span class="hljs-comment">//此例中即令mid = vi.begin() + 10;</span><br><span class="hljs-comment">//已知下标从0开始，则迭代器所指的元素是vi[10]</span><br><span class="hljs-comment">//也就是从首元素开始向前相隔10个位置的那个元素</span><br></code></pre></td></tr></table></figure></li><li><p>对于string和vector的迭代器来说，除了判断是否相等，还能使用关系运算符对其进行比较。参与比较的两个迭代器必须合法且指向的是同一个容器的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//例如假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码表示它们的位置前后</span><br><span class="hljs-keyword">if</span>(it &lt; mid)&#123;<br>    <span class="hljs-comment">//处理vi前半部分的元素</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，就能将其相减，所得结果是两个迭代器之间的距离。所谓的距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为different_type的带符号整数。string和vector都定义了different_type，因为这个距离可正可负，所以different_type是带符号类型的。</p></li><li><p>使用迭代器运算实现二分搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">int</span> sought =<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; text&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-keyword">auto</span> beg = text.<span class="hljs-built_in">begin</span>(), end = text.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">//beg和end是进行二分搜索的范围</span><br><span class="hljs-keyword">auto</span> mid = text.<span class="hljs-built_in">begin</span>() + (end - beg) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (mid != end &amp;&amp; *mid != sought) &#123;<br><span class="hljs-keyword">if</span> (sought &lt; *mid) &#123;<br>            <span class="hljs-comment">//注意end的含义是查找范围最后一个元素的后一个元素</span><br>end = mid;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>beg = mid + <span class="hljs-number">1</span>;<br>&#125;<br>mid = beg + (end - beg) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (mid != end) &#123;<br>flag = <span class="hljs-literal">true</span>;<br>&#125;<br>cout &lt;&lt; flag &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.24 请使用迭代器重做3.3.3节的最后一个练习 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//求相邻元素和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//求相邻元素和</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">int</span> iVal;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一组数字：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; iVal) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(iVal);<br>&#125;<br><span class="hljs-comment">//判断到底向vector中输入了多少数字</span><br><span class="hljs-keyword">if</span> (vInt.<span class="hljs-built_in">cbegin</span>() == vInt.<span class="hljs-built_in">cend</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector中没有任何元素&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;相邻两项的和依次是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vInt.<span class="hljs-built_in">cbegin</span>(); it != vInt.<span class="hljs-built_in">cend</span>() - <span class="hljs-number">1</span>; it++) &#123;<br>cout &lt;&lt; *it + *(++it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//如果元素个数是奇数，就单独处理最后一个元素</span><br><span class="hljs-keyword">if</span> (vInt.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; *(vInt.<span class="hljs-built_in">cend</span>() - <span class="hljs-number">1</span>);<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//求首尾元素和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//求首尾元素和</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">int</span> iVal;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一组数字：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; iVal) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(iVal);<br>&#125;<br><span class="hljs-comment">//判断到底向vector中输入了多少数字</span><br><span class="hljs-keyword">if</span> (vInt.<span class="hljs-built_in">cbegin</span>() == vInt.<span class="hljs-built_in">cend</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector中没有任何元素&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">auto</span> beg = vInt.<span class="hljs-built_in">cbegin</span>();<br><span class="hljs-keyword">auto</span> end = vInt.<span class="hljs-built_in">cend</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (beg &lt; end) &#123;<br>cout &lt;&lt; *beg + *end &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>beg++;<br>end--;<br>&#125;<br><span class="hljs-keyword">if</span> (vInt.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; *beg;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习2.35 3.3.3节划分分数段的程序是使用下标运算符来实现的，请使用迭代器改写该程序并实现完全相同的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">unsigned</span>&gt; <span class="hljs-title">vUS</span><span class="hljs-params">(<span class="hljs-number">11</span>)</span></span>; <span class="hljs-comment">//记录各分段的人数，初始值均为0</span><br><span class="hljs-keyword">auto</span> it = vUS.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">int</span> iVal;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一组成绩：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; iVal) &#123;<br><span class="hljs-keyword">if</span>(iVal &lt; <span class="hljs-number">101</span>)<br>            <span class="hljs-comment">//注意这里++写在后面不行，涉及到运算优先级的问题</span><br>++*(it + iVal / <span class="hljs-number">10</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;总共输入了&quot;</span> &lt;&lt; vUS.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;个成绩&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;各分数段的人数是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = vUS.<span class="hljs-built_in">begin</span>(); beg != vUS.<span class="hljs-built_in">end</span>(); beg++) &#123;<br>cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.26 在100页的二分搜索程序中，为什么用的是mid = beg + (end - beg) / 2而非mid = (beg + end) / 2;?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp没有定义迭代器的加法，实际上把两个迭代器加起来是没有意义的</span><br><span class="hljs-comment">//cpp定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h4><ol><li><p>数组是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在的位置访问。</p></li><li><p>与vector不同的是，数组的大小不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。</p></li><li><p>数组是一种复合类型。数组的声明型如a[d]，其中a是数组的名字，d是数组的维度。维度说明了数组中元素的个数，因此必须大于0。</p></li><li><p>数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的，也就是说，维度必须是一个常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> cnt = <span class="hljs-number">42</span>; <span class="hljs-comment">//不是一个常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> sz = <span class="hljs-number">42</span>; <span class="hljs-comment">//常量表达式</span><br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>]; <span class="hljs-comment">//含有10个整数的数组</span><br><span class="hljs-keyword">int</span> *parr[sz];<span class="hljs-comment">// 含有42个整型指针的数组</span><br>string bad[cnt];<span class="hljs-comment">// 错误，cnt不是常量表达式</span><br>string strs[<span class="hljs-built_in">get_size</span>()];<span class="hljs-comment">//当get_size是constexpr时正确，否则错误</span><br></code></pre></td></tr></table></figure></li><li><p>默认情况下，数组的元素被默认初始化，和内置类型的变量一样，如果函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p></li><li><p>定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应该为对象，因此不存在引用的数组。</p></li><li><p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量推测出来。相反，如果指明了维度，那么初始值总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> sz = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> a1[sz] = &#123;<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//含有三个元素的数组，元素值分别是0，1，2</span><br><span class="hljs-keyword">int</span> a2[] = &#123;<span class="hljs-number">0</span> , <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//维度是3的数组</span><br><span class="hljs-keyword">int</span> a3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//等价于a3[] = &#123;0, 1, 2, 0, 0&#125;</span><br>string a4[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&quot;h1&quot;</span>,<span class="hljs-string">&quot;h2&quot;</span>&#125;<span class="hljs-comment">//等价于a4[] = &#123;&quot;h1&quot;, &quot;h2&quot;,&quot;&quot;&#125;;</span><br><span class="hljs-keyword">int</span> a5[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 错误，初始值过多</span><br></code></pre></td></tr></table></figure></li><li><p>字符数组有一种额外的初始化形式，我们可以用字符串字面量对此类数组进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//当使用这种方式的时候，一定要注意字符串字面值结尾还有一个空字符</span><br><span class="hljs-comment">//这个空字符也会向字符串的其它字符一样被拷贝到字符数组中</span><br><span class="hljs-keyword">char</span> a1[] = &#123;<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>&#125;;<span class="hljs-comment">//列表初始化，没有空字符</span><br><span class="hljs-keyword">char</span> a2[] = &#123;<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-string">&#x27;+&#x27;</span>，<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<span class="hljs-comment">//列表初始化，含有显式的空字符</span><br><span class="hljs-keyword">char</span> a3[] = <span class="hljs-string">&quot;c++&quot;</span>;<span class="hljs-comment">//自动添加表示字符串结束的空字符</span><br><span class="hljs-keyword">char</span> a4[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;c++&quot;</span>; <span class="hljs-comment">//错误：没有空间可以存放空字符 </span><br></code></pre></td></tr></table></figure></li><li><p>不能将数组的内容拷贝给其它数组作为初始值，也不能用数组为其它数组赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">int</span> a1[] = a; <span class="hljs-comment">//错误，不允许使用一个数组初始化另一个数组</span><br>a2 = a;<span class="hljs-comment">//错误，不能把一个数组直接赋值给另一个数组</span><br></code></pre></td></tr></table></figure></li><li><p>复杂的数组声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>]; <span class="hljs-comment">//ptrs是含有10个整型指针的数组</span><br><span class="hljs-keyword">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* */</span>; <span class="hljs-comment">//错误，不存在引用的数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">//Parray指向一个含有十个整数的数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">//arrRef引用一个含有十个整数的数组</span><br><span class="hljs-comment">//默认情况下，类型修饰符从右向左绑定。</span><br><span class="hljs-comment">//对于ptrs来说，从右向左理解其含义比较简单</span><br><span class="hljs-comment">//首先知道我们定义的是一个大小为10的数组，数组名为ptrs</span><br><span class="hljs-comment">//然后知道数组中存放的是指向int的指针</span><br><span class="hljs-comment">//但是对于Parray来讲，从右向左理解就不太合理了</span><br><span class="hljs-comment">//由内向外可以帮助我们更好的理解Parray的含义</span><br><span class="hljs-comment">//首先是圆括号括起来的部分 ,*Parray意味着Parray是一个指针</span><br><span class="hljs-comment">//接下来观察右边，可知Parray是个指向大小为10的数组的指针</span><br><span class="hljs-comment">//最后观察左边，知道数组中的元素是int</span><br><span class="hljs-comment">//这样最终的含义就明确了，Parray是一个指针，指向一个int数组，数组中包含10个元素</span><br><span class="hljs-comment">//（&amp;arrRef）表示arrRef是一个引用，它引用的对象是一个int数组，数组中包含10个元素</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs; <span class="hljs-comment">//arry是数组的引用，该数组含有10个指针</span><br><span class="hljs-comment">//按照由内向外的顺序阅读</span><br><span class="hljs-comment">//首先知道arry是一个引用</span><br><span class="hljs-comment">//然后观察右边知道，arry引用的对象是个大小为10的数组</span><br><span class="hljs-comment">//最后观察左边知道，数组的元素类型是指向int的指针</span><br><span class="hljs-comment">//arry就是一个含有10个int型指针的数组的引用</span><br></code></pre></td></tr></table></figure></li><li><p>综上，要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p></li><li><p>练习3.27 假设txt_size是一个无参数的函数，它的返回值是int。请回答下列哪个定义是非法的？为什么？ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> buf_size = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">int</span> ia[buf_size]; <span class="hljs-comment">//非法的，buf_size是一个普通的无符号数，不是常量，不能作为数组的维度</span><br><span class="hljs-keyword">int</span> ib[<span class="hljs-number">4</span> * <span class="hljs-number">7</span> - <span class="hljs-number">14</span>];<span class="hljs-comment">//合法，4 * 7 - 14是一个常量表达式</span><br><span class="hljs-keyword">int</span> ic[<span class="hljs-built_in">txt_size</span>()];<span class="hljs-comment">//非法的，txt_size()是一个普通的函数调用，没有被定义为constexpr，不是常量</span><br><span class="hljs-keyword">char</span> st[<span class="hljs-number">11</span>] = <span class="hljs-string">&quot;fundamental&quot;</span>;<span class="hljs-comment">//非法的，没有考虑字符串末尾的空字符。</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.28 下列数组中元素的值是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string sa[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string sa2[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">int</span> ia2[<span class="hljs-number">10</span>];<br>&#125;<br><span class="hljs-comment">//对于string类型的数组来说</span><br><span class="hljs-comment">//因为string类本身接受无参数的初始化方式</span><br><span class="hljs-comment">//所以不论数组定义在函数体外还是函数体内都默认被初始化为空串</span><br><span class="hljs-comment">//对于内置类型int来说</span><br><span class="hljs-comment">//数组ia定义在函数体之外，ia所有元素默认初始化为0</span><br><span class="hljs-comment">//数组ia2定义在main函数的内部，将不被初始化</span><br><span class="hljs-comment">//如果程序试图拷贝或输出未初始化的变量，将遇到未定义的奇异值</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.29 相比于vector来说，数组有哪些缺点，请列举一些。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 数组与vector的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问<br><span class="hljs-bullet">2.</span> 数组与vector最大的不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能比较好，但是没有vector灵活。<br><span class="hljs-bullet">3.</span> 具体的说，数组的维度在定义的时候已经确定了，如果我们想更改数组的长度，只能创建一个更大的新数组，然后把原数组中的所有元素复制到新数组中去。我们也无法向vector那样使用size函数直接获得数组的维度。<br><span class="hljs-bullet">4.</span> 如果是字符数组，可以调用strlen函数得到字符串的长度；如果是其它数组，只能使用sizeof(array)/sizeof(arr[0])的方式计算数组的维度。<br></code></pre></td></tr></table></figure></li></ol><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><ol><li><p>数组的元素也可以使用范围for语句或下标运算符来访问。</p></li><li><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计的足够大以便能保存内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是c标准库stddef.h头文件的c++语言版本。</p></li><li><p>示例：使用数组来记录各分数段的成绩个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> scores[<span class="hljs-number">11</span>] = &#123;&#125;; <span class="hljs-comment">//11个分数段，全部被初始化为0</span><br><span class="hljs-keyword">unsigned</span> score;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; score)&#123;<br>    ++scores[score / <span class="hljs-number">10</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.30 指出下面代码中的索引错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> array_size = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> ia[array_size];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> ix = <span class="hljs-number">1</span>; ix &lt;= array_size; ++ix)&#123;<br>    ia[ix] = ix;<br>&#125;<br><span class="hljs-comment">//错误：数组的下标应该大于等于0而小于数组的大小。在本题中，下标范围应该是0到9</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.31 编写一段程序，定义一个含有10个int的数组，令每个元素值就是其下标值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>; <span class="hljs-comment">//常量sz作为数组的维度</span><br><span class="hljs-keyword">int</span> a[sz];<br><span class="hljs-comment">//通过for循环为数组的元素赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>a[i] = i;<br>&#125;<br><span class="hljs-comment">//通过范围for循环输出数组的全部元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : a) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.32 将上一题刚刚创建的数组拷贝给另一个数组。利用vector重写程序，实现类似的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果想把数组的内容拷贝给另一个数组，不能直接对数组使用赋值运算符，应该逐一拷贝数组的元素</span><br><span class="hljs-comment">//vector的拷贝原理和数组类似</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>; <span class="hljs-comment">//常量sz作为数组的维度</span><br><span class="hljs-keyword">int</span> a[sz], b[sz];<br><span class="hljs-comment">//通过for循环为第一个数组赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>a[i] = i;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sz; j++) &#123;<br>b[j] = a[j];<br>&#125;<br><span class="hljs-comment">//通过范围for循环输出数组的全部元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : b) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>; <span class="hljs-comment">//常量sz作为vector的容量</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt, vInt2;<br><span class="hljs-comment">//通过for循环为vector对象的元素赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sz; j++) &#123;<br>vInt2.<span class="hljs-built_in">push_back</span>(vInt[j]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : vInt2) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.33 对于104页的程序来说，如果不初始化scores将发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//该程序对scores执行了列表初始化，为所有元素赋初值为0，这样在后续统计时将会从0开始计算个各分段的人数</span><br><span class="hljs-comment">//如果不初始化，则该数组会含有未定义的值，这是因为scores是定义在函数内部的整型数组，不会执行默认初始化</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><ol><li><p>通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以作用于任何对象。</p></li><li><p>数组的元素也是对象，对数组使用下标运算符可以得到该数组指定位置的元素。因此像其它对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string nums[] = &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;; <span class="hljs-comment">//数组的元素是string对象</span><br>string *p = &amp;nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">//p指向nums的第一个元素</span><br></code></pre></td></tr></table></figure></li><li><p>数组的特性：在很多使用数组名的地方，编译器会自动的将其替换为一个指向数组首元素的指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string *p2 = nums; <span class="hljs-comment">//等价于 p2 = &amp;nums[0];</span><br></code></pre></td></tr></table></figure></li><li><p>当使用数组作为一个auto变量的初始值的时候，推断得到的类型是指针而非数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//ia是一个含有三个整数的数组</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">//ia2是一个整型指针，指向ia的第一个元素</span><br>ia2 = <span class="hljs-number">42</span>; <span class="hljs-comment">//错误：ia2是一个指针，不能用int值给指针赋值</span><br><span class="hljs-comment">//当使用ia作为初始值时，编译器实际执行的初始化过程类似于下面的形式</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>; <span class="hljs-comment">//显然ia2的类型是int*</span><br></code></pre></td></tr></table></figure></li><li><p>当使用decltype关键字时，上述转换不会发生，decltype（ia）返回的类型是由十个整数构成的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//ia3是一个含有10个整数的数组</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>ia3 = p; <span class="hljs-comment">//错误，不能用整形指针给数组赋值</span><br>ia3[<span class="hljs-number">4</span>] = i;<span class="hljs-comment">//正确，把i的值赋给ia3的一个元素</span><br></code></pre></td></tr></table></figure></li><li><p>指向数组元素的指针拥有更多的功能，vector和string的迭代器支持的运算，数组的指针全部支持。例如，允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">int</span> *p = arr; <span class="hljs-comment">//p指向arr的第一个元素</span><br>++P; <span class="hljs-comment">//p指向arr[1]</span><br><span class="hljs-comment">//就像使用迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素</span><br><span class="hljs-comment">//通过数组名字或者数组中首元素的地址都能得到指向首元素的指针</span><br><span class="hljs-keyword">int</span> *e = &amp;arr[<span class="hljs-number">10</span>]; <span class="hljs-comment">//指向arr尾元素的下一位置的指针</span><br><span class="hljs-comment">//尾后指针e不指向具体的元素。因此不能对尾后指针执行解引用或者递增的操作。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> *b = arr; b != e; b++)&#123;<br>    cout&lt;&lt; *b &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br></code></pre></td></tr></table></figure></li><li><p>标准库函数begin和end</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp11新标准引入了两个名为begin和end的函数，这两个函数定义在iterator头文件中</span><br><span class="hljs-comment">//这两个函数与容器中的两个同名成员类似</span><br><span class="hljs-comment">//数组不是类类型，因此这两个函数不是成员函数，正确的使用形式是将数组作为它们的参数</span><br><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;; <span class="hljs-comment">//ia是一个含有10个整数的数组</span><br><span class="hljs-keyword">int</span> *beg = <span class="hljs-built_in">begin</span>(ia); <span class="hljs-comment">//指向ia首元素的指针</span><br><span class="hljs-keyword">int</span> *last = <span class="hljs-built_in">end</span>(ia); <span class="hljs-comment">//指向arr尾元素的下一个位置的指针</span><br></code></pre></td></tr></table></figure></li><li><p>指向数组元素的指针可以执行上述列出的所有迭代器运算。这些运算，包括解引用，递增，比较，与整数相加，两个指针相减等，用在指针和用在迭代器上意义完全一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//给一个指针加上（减去）某整数值，结果仍是指针</span><br><span class="hljs-comment">//新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置：</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> sz = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> arr[sz] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">int</span> *ip = arr; <span class="hljs-comment">//等价于int *ip = &amp;arr[0];</span><br><span class="hljs-keyword">int</span> *ip2 = ip + <span class="hljs-number">4</span>; <span class="hljs-comment">//ip2指向arr的尾元素arr[4]</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = arr + sz; <span class="hljs-comment">//使用警告，不要解引用</span><br><span class="hljs-keyword">int</span> *p2 = arr + <span class="hljs-number">10</span>; <span class="hljs-comment">//错误：arr只有5个元素，p2的值未定义</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//和迭代器一样，两个指针相减的结果是它们之间的距离</span><br><span class="hljs-comment">//参与运算的两个指针必须指向同一个数组中的元素：</span><br><span class="hljs-keyword">auto</span> n = <span class="hljs-built_in">end</span>(arr) - <span class="hljs-built_in">begin</span>(arr); <span class="hljs-comment">//n的值是5，也就是arr中元素的数量</span><br><span class="hljs-comment">//两个指针相减的结果是一种名为ptrdiff_t的标准库类型</span><br><span class="hljs-comment">//和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型</span><br><span class="hljs-comment">//因为差值可能为负值，所以ptrdiff_t是一种带符号类型</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//利用关系运算符对指针进行比较从而完成遍历</span><br><span class="hljs-keyword">int</span> *b = arr;<br><span class="hljs-keyword">int</span> *e = arr + sz;<br><span class="hljs-keyword">while</span>(b &lt; e)&#123;<br>    <span class="hljs-comment">/*使用指针*/</span><br>    ++b;<br>&#125;<br><span class="hljs-comment">//如果两个指针分别指向不想关的对象，则不能比较它们</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 上述指针运算同样适用于空指针和所指对象并非数组的指针。<br><span class="hljs-bullet">2.</span> 在后一种情况下，两个指针必须指向同一个对象或者该对象的下一个位置。<br><span class="hljs-bullet">3.</span> 如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。<br><span class="hljs-bullet">4.</span> 两个空指针也允许彼此相减，结果当然是0。<br></code></pre></td></tr></table></figure></li><li><p>如前所述，在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针，一个典型的例子是当对这些数组使用下标运算符的时候，编译器会自动执行上述转换操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">//对数组执行下标运算其实是对指向数组元素的指针执行下标运算</span><br><span class="hljs-keyword">int</span> i = ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">//ia替换成指向数组首元素的指针，ia[2]替换成(ia + 2)指向的元素</span><br><span class="hljs-comment">//可以等价于如下的语句</span><br><span class="hljs-keyword">int</span> *p = ia;<br><span class="hljs-keyword">int</span> i = *(p + <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样</span><br><span class="hljs-keyword">int</span> *p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">//p指向索引为2的元素</span><br><span class="hljs-keyword">int</span> j = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">//p[1]等价于*(p + 1)，就是ia[3]表示的那个元素</span><br><span class="hljs-keyword">int</span> k = p[<span class="hljs-number">-2</span>]; <span class="hljs-comment">//p[-2]是ia[0]表示的那个元素</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.34 假定p1和p2指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p1 += p2 - p1;<br><span class="hljs-comment">//如果p1和p2指向同一个数组中的元素</span><br><span class="hljs-comment">//则该条语句令p1指向p2原来所指向的元素</span><br><span class="hljs-comment">//从语法上说，即使p1和p2指向的元素不属于同一个数组，但只要p1和p2的类型相同也是合法的</span><br><span class="hljs-comment">//如果p1和p2的类型不同，则编译时报错</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.35 编写一段程序，利用指针将数组的元素置为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>; <span class="hljs-comment">//常量sz作为数组的维度</span><br><span class="hljs-keyword">int</span> a[sz];<br><span class="hljs-comment">//通过for循环为数组元素赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>a[i] = i;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;初始状态下的数组为：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : a) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">int</span>* p = <span class="hljs-built_in">begin</span>(a);<br><span class="hljs-keyword">int</span>* e = <span class="hljs-built_in">end</span>(a);<br><span class="hljs-keyword">while</span> (p &lt; e) &#123;<br>*p = <span class="hljs-number">0</span>;<br>++p;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;修改后数组的内容是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : a) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.36 编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//无论是对比两个数组是否相等还是两个vector对象是否相等</span><br><span class="hljs-comment">//都必须逐一比较其元素</span><br><span class="hljs-comment">//比较两个数组是否相等</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> a[sz], b[sz];<br><span class="hljs-comment">//生成随机数种子</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>a[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>; <span class="hljs-comment">//每次生成一个10以内的随机数并添加到a中 </span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;数据已经生成，请输入您猜测的数字：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">int</span> uVal;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br><span class="hljs-keyword">if</span> (cin &gt;&gt; uVal) &#123;<br>b[i] = uVal;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;系统生成的数据是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : a) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;用户猜测的数据是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : b) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span> ;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">int</span>* p = <span class="hljs-built_in">begin</span>(a);<br><span class="hljs-keyword">int</span>* q = <span class="hljs-built_in">begin</span>(b);<br><span class="hljs-keyword">while</span> (p != <span class="hljs-built_in">end</span>(a) &amp;&amp; q != <span class="hljs-built_in">end</span>(b)) &#123;<br><span class="hljs-keyword">if</span> (*p != *q) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有猜对&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>p++;<br>q++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-built_in">end</span>(a) &amp;&amp; q == <span class="hljs-built_in">end</span>(b)) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜对了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较两个vector对象是否相等</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">5</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; a, b;<br><span class="hljs-comment">//生成随机数种子</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>a.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>); <span class="hljs-comment">//每次生成一个10以内的随机数并添加到a中 </span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;数据已经生成，请输入您猜测的数字：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">int</span> uVal;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br><span class="hljs-keyword">if</span> (cin &gt;&gt; uVal) &#123;<br>b.<span class="hljs-built_in">push_back</span>(uVal);<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;系统生成的数据是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : a) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;用户猜测的数据是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : b) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span> ;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">auto</span> it1 = a.<span class="hljs-built_in">cbegin</span>();<br><span class="hljs-keyword">auto</span> it2 = b.<span class="hljs-built_in">cbegin</span>();<br><span class="hljs-keyword">while</span> (it1 != a.<span class="hljs-built_in">cend</span>() &amp;&amp; it2 != b.<span class="hljs-built_in">cend</span>()) &#123;<br><span class="hljs-keyword">if</span> (*it1 != *it2) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有猜对&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>it1++;<br>it2++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (it1 == a.<span class="hljs-built_in">cend</span>() &amp;&amp; it2 == b.<span class="hljs-built_in">cend</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜对了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="c风格字符串"><a href="#c风格字符串" class="headerlink" title="c风格字符串"></a>c风格字符串</h4><ol><li><p>首先说明，尽管cpp支持c风格字符串，但是在c++程序中还是不要使用它们，容易引发程序漏洞。</p></li><li><p>字符串字面值是一种通用结构的实例，这种结构即是c++由c继承而来的c风格字符串。c风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\0’）,一般用指针来操作这些字符串。</p></li><li><p>c标准库String函数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//这些函数定义在cstring头文件中<br>//可以用于操作c风格字符串<br><span class="hljs-bullet">1.</span> strlen(p)：返回p的长度，空字符不计算在内<br>//比较p1和p2的相等性。如果p1 == p2，返回0<br>//如果p1 &lt; p2返回一个负值<br>//如果p1 &gt; p2返回一个正值<br><span class="hljs-bullet">2.</span> strcmp(p1, p2)<br><span class="hljs-bullet">3.</span> strcat(p1, p2) ：将p2附加到p1之后，返回p1<br><span class="hljs-bullet">4.</span> strcpy(p1, p2)：将p2拷贝给p1，返回p1<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//传入此类函数的指针必须指向以空字符作为结束的数组</span><br><span class="hljs-keyword">char</span> ca[] = &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>&#125;; <span class="hljs-comment">//不以空字符结束</span><br>cout&lt;&lt; <span class="hljs-built_in">strlen</span>(ca) &lt;&lt;endl; <span class="hljs-comment">//严重错误，ca没有以空字符结束</span><br></code></pre></td></tr></table></figure></li><li><p>比较字符串：比较两个c语言风格的字符串应该使用strcmp，不能直接使用关系运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较标准库string对象的时候，用的是普通的关系型运算符和相等运算符</span><br>string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-keyword">if</span>(s1 &lt; s2)&#123; <span class="hljs-comment">//false</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果把上述运算符用在两个c风格字符串上，实际比较的将是指针而非字符串本身</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> ca1[] = <span class="hljs-string">&quot;A string example&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> ca2[] = <span class="hljs-string">&quot;another string&quot;</span>;<br><span class="hljs-keyword">if</span>(ca1 &lt; ca2) <span class="hljs-comment">//未定义的：试图比较两个毫不相干的地址</span><br><span class="hljs-comment">//当使用数组的时候，其实真正用的是指向数组首元素的指针</span><br><span class="hljs-comment">//因此，上面的if条件实际上比较的是两个const char*的值</span><br><span class="hljs-comment">//这两个指针指向的并非同一对象，所以将得到未定义的结果</span><br></code></pre></td></tr></table></figure></li><li><p>连接或者拷贝c风格字符串，正确的方法是使用strcpy和strcat。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组</span><br><span class="hljs-comment">//该数组必须足够大以容纳下结果字符串以及末尾的空字符</span><br><span class="hljs-comment">//如果算错了largeStr的大小将引发严重错误</span><br><span class="hljs-built_in">strcpy</span>(largeStr, ca1); <span class="hljs-comment">//把ca1拷贝给largeStr</span><br><span class="hljs-built_in">strcpy</span>(largeStr, <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">//在末尾加上一个空格</span><br><span class="hljs-built_in">strcpy</span>(largeStr, ca2); <span class="hljs-comment">//把ca2拷贝给largeStr</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.37 下列程序是什么含义，程序输出的结果是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> ca[] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp = ca;<br><span class="hljs-keyword">while</span>(*cp)&#123;<br>    cout&lt;&lt;*cp&lt;&lt;endl;<br>    ++cp;<br>&#125;<br><span class="hljs-comment">//该程序的原意就是输出ca中存储的5个字符，每个字符占一行</span><br><span class="hljs-comment">//以列表初始化方式赋值的c风格字符串与以字符串字面量赋值的有所区别</span><br><span class="hljs-comment">//后者会在字符串最后额外增加一个空字符以示字符串的结束，而前者不会这样做</span><br><span class="hljs-comment">//因此在该程序中，ca的五个字符全部输出后，并没有遇到预期的空字符</span><br><span class="hljs-comment">//程序继续在内存中ca的存储位置之后挨个寻找空字符，直到找到为止</span><br><span class="hljs-comment">//在这个过程中，额外经历的内容也被输出出来，从而产生错误</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.38 在本书中我们提到，将两个指针相加不但是非法的，而且没什么意义，请问为什么两个指针相加没有意义。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 指针也是一个对象，与指针相关的属性有三个：<br><span class="hljs-code">（1）指针本身的值(value)</span><br><span class="hljs-code">（2）指针所指的对象(content)</span><br><span class="hljs-code">（3）指针本身在内存中的存储位置(address)</span><br><span class="hljs-code">2. 指针本身的值：是一个内存地址值，表示指针所指对象在内存中的存储地址。</span><br><span class="hljs-code">3. 指针所指的对象：指针所指对象可以通过解引用指针访问。</span><br><span class="hljs-code">4. 指针本身在内存中的存储位置：指针也是一个对象，所以指针也存储在内存中的某个位置，它有自己的地址，这也是为什么有&quot;指针的指针&quot;的原因。</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.39 编写一段程序，比较两个string对象。再编写一段程序，比较两个c风格字符串的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较两个string 对象</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//比较两个string对象</span><br>string str1, str2;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个字符串：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; str1 &gt;&gt; str2;<br><span class="hljs-keyword">if</span> (str1 &gt; str2) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一个字符串大于第二个字符串&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str1 &lt; str2) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一个字符串小于第二个字符串&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;两个字符串相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较两个c风格的字符串</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//比较两个c风格字符串的内容</span><br><span class="hljs-keyword">char</span> str1[<span class="hljs-number">80</span>], str2[<span class="hljs-number">80</span>];<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个字符串&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; str1 &gt;&gt; str2;<br><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">strcmp</span>(str1, str2);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (result) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;第一个字符串大于第二个字符串&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;第一个字符串小于第二个字符串&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;两个字符串相等&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;未定义的结果&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.40 编写一段程序，定义两个字符数组并用字符串字面值初始化它们，接着再定义一个数组存放前两个数组连接之后的结果。使用strcpy和strcat把前两个数组的内容拷贝到第三个数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//这部分代码有问题</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h4><ol><li><p>混用string对象和c风格字符串</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代。<br><span class="hljs-bullet">2.</span> 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。<br><span class="hljs-bullet">3.</span> 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。<br><span class="hljs-bullet">4.</span> 上述性质反过来并不成立。<br><span class="hljs-bullet">5.</span> 如果程序的某处需要一个c风格字符串，无法直接使用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c<span class="hljs-emphasis">_str的成员函数：</span><br><span class="hljs-emphasis">char * str = s; //错误，不能用string对象初始化char * </span><br><span class="hljs-emphasis">const char * str = s.c_</span>str(); //正确<br><span class="hljs-bullet">6.</span> 函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象一样。结果指针的类型是const char <span class="hljs-emphasis">* ，从而确保我们不会改变字符数组的内容。</span><br><span class="hljs-emphasis">7. 无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。</span><br></code></pre></td></tr></table></figure></li><li><p>使用数组初始化vector对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//不允许使用一个数组为另一个内置类型的数组赋值</span><br><span class="hljs-comment">//不允许使用vector对象初始化数组</span><br><span class="hljs-comment">//允许使用数组初始化vector对象</span><br><span class="hljs-comment">//要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了</span><br><span class="hljs-keyword">int</span> int_arr = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//ivec中有6个元素，分别是int_arr中对应元素的副本</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr), end(int_arr))</span></span>;<br><span class="hljs-comment">//其中第二个指针指向待拷贝区域尾元素的下一位置</span><br><span class="hljs-comment">//使用标准库函数begin和end来分别计算int_arr来计算首指针和尾后指针</span><br><span class="hljs-comment">//拷贝部分元素</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec2</span><span class="hljs-params">(int_arr + <span class="hljs-number">1</span>, int_arr + <span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-comment">//vector中有3个元素，分别是int_arr[1], int_arr[2], int_arr[3]</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.14 编写一段程序，用整型数组初始化一个vector对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> a[sz];<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>cout &lt;&lt; <span class="hljs-string">&quot;数组的内容是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//利用范围for循环遍历数组的每个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; val : a) &#123;<br>val = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(a), end(a))</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector的内容是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : ivec) &#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.42 编写一段程序，将含有整数元素的vector对象拷贝给一个整型数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-number">10</span>; <span class="hljs-comment">//指明vector的容量</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; ivec;<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>cout &lt;&lt; <span class="hljs-string">&quot;vector中的内容是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br><span class="hljs-keyword">auto</span> val = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>ivec.<span class="hljs-built_in">push_back</span>(val);<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">int</span> a[sz];<br>cout &lt;&lt; <span class="hljs-string">&quot;数组的内容是：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>a[i] = ivec[i];<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><ol><li><p>严格来说，cpp中没有多维数组，通常所说的数组指的是数组的数组。当一个数组的元素也是数组的时候，通常用两个维度来定义它，一个维度表示数组本身大小，另一个维度表示其元素的大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>][<span class="hljs-number">20</span>][<span class="hljs-number">30</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//大小为10的数组，它的每个元素都是大小为20的数组</span><br><span class="hljs-comment">//这些数组的元素是含有30个整数的数组</span><br><span class="hljs-comment">//将所有的元素初始化为0</span><br></code></pre></td></tr></table></figure></li><li><p>多维数组的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>    &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;,<br>    &#123;<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//内层嵌套的花括号并非必须的</span><br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//显式的初始化每行的首元素</span><br><span class="hljs-keyword">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<br>    &#123;<span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">4</span>&#125;,<br>    &#123;<span class="hljs-number">8</span>&#125;<br>&#125;<br><span class="hljs-comment">//其它的元素执行值初始化</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ix[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">//显式的初始化第一行，其它元素执行值初始化</span><br></code></pre></td></tr></table></figure></li><li><p>多维数组的下标引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素</span><br><span class="hljs-comment">//如果表达式含有的下标运算符数量比数组的维度小</span><br><span class="hljs-comment">//则表达式的结果将是给定索引处的一个内层数组</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;row)[<span class="hljs-number">4</span>] = ia[<span class="hljs-number">1</span>]; <span class="hljs-comment">//把row绑定在ia的第二个4元素数组上，row是一个对数组的引用</span><br></code></pre></td></tr></table></figure></li><li><p>使用范围for语句处理多维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">size_t</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;row : ia)&#123; <span class="hljs-comment">//row的类型是含有四个整数的数组的引用</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;col : row)&#123; <span class="hljs-comment">//col的类型是整数的引用</span><br>        col = cnt;<br>        cnt++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//要使用范围for语句处理多维数组</span><br><span class="hljs-comment">//除了最内层的循环外，其它所有循环的控制变量都应该是引用类型</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;row : ia)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> col : row)&#123;<br>        cout&lt;&lt;col&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//将外层循环的控制变量声明成引用类型是为了避免数组自动被转为指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> row : ia)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> col : row)&#123;<br>        <span class="hljs-comment">//程序将无法通过编译</span><br>        <span class="hljs-comment">//因为row不是引用类型</span><br>        <span class="hljs-comment">//所以编译器初始化row时会将其转换成指向数组中第一个元素的指针</span><br>        <span class="hljs-comment">//这样得到的row的类型就是int*，显然内存的循环就不合法了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter3&lt;/p&gt;
&lt;p&gt;主要内容包括迭代器、数组和多维数组。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_3_40</title>
    <link href="http://example.com/cpp-primer-3-40/"/>
    <id>http://example.com/cpp-primer-3-40/</id>
    <published>2021-05-23T03:17:36.000Z</published>
    <updated>2021-05-24T07:26:30.713Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter3</p><p>主要内容包括命名空间的using声明、标准库类型string和标准库类型vector</p><span id="more"></span><h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><ol><li><p>内置类型是由cpp语言直接定义的。这些类型，比如数字和字符，体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，它们尚未直接实现到计算机硬件中。</p></li><li><p>string表示可变长的字符序列。</p></li><li><p>vector存放的是某种给定类型对象的可变长序列。</p></li><li><p>数组类型：内置类型，数组的实现和硬件密切相关，相较于标准库类型string和vector，数组在灵活性上稍显不足。</p></li><li><p>作用域操作符::的含义是编译器应从操作符左侧名字所示的作用域中寻找右侧的那个名字。因此，std::cin的意思就是要使用命名空间std中的名字cin。</p></li><li><p>using 声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cin;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    cin &gt;&gt; i; <span class="hljs-comment">//正确，cin和std::cin含义相同</span><br>    cout &lt;&lt; i; <span class="hljs-comment">//错误，没有对应的using声明，必须使用完整的名字</span><br>    std::cout &lt;&lt; i &lt;&lt;std::endl; <span class="hljs-comment">//正确，显式的使用std命名空间中的cout</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>按照规定，每个using声明引入命名空间中的一个成员。用到的每个名字都必须有自己的声明语句，而且每句话都以分号结束。</p></li><li><p>头文件中不应该包含using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件中有某个using声明，那么每个使用了该头文件的文件就会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p></li><li><p>练习 3.1 使用恰当的using声明重做1.4.1节的练习和2.6.2节的练习。</p></li></ol><h4 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h4><ol><li><p>作为标准库的一部分，string定义在命名空间std中，引入string的代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> std::string;<br></code></pre></td></tr></table></figure></li><li><p>初始化string的常见方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s1; <span class="hljs-comment">//默认初始化，s1是一个空串</span><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>; <span class="hljs-comment">//s2是s1的副本</span><br>string s2 = s1; <span class="hljs-comment">//等价于s2(s1)，s2是s1的副本</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">//s3是字面值&quot;value&quot;的副本</span><br>string s3 = <span class="hljs-string">&quot;value&quot;</span>;  <span class="hljs-comment">//和上述句子等价</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;c&#x27;</span>)</span></span>; <span class="hljs-comment">//把s4初始化为连续n个字符c组成的串。</span><br></code></pre></td></tr></table></figure></li><li><p>拷贝初始化和直接初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//如果使用的是 = 初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。</span><br><span class="hljs-comment">//如果不使用等号，则执行的是直接初始化。</span><br><span class="hljs-comment">//一般来讲，拷贝初始化和直接初始化之间没有什么区别</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h4><ol><li><p>一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，也能定义&lt;&lt;、+等各种运算符在该类对象上的新含义。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">string的操作<br><span class="hljs-bullet">1.</span> os&lt;<span class="xml">&lt;s：将s写到输出流中，返回os</span><br><span class="xml">2. is&gt;</span>&gt;s：从is中读取字符串赋给s，字符串以空白分割，返回is<br><span class="hljs-bullet">3.</span> getline(is, s)：从is中读取一行赋给s，返回is<br><span class="hljs-bullet">4.</span> s.empty()：s为空时返回true，否则返回false<br><span class="hljs-bullet">5.</span> s.size()：返回s中字符的个数<br><span class="hljs-bullet">6.</span> s[n]：返回s中第n个字符的引用，位置n从0开始记起<br><span class="hljs-bullet">7.</span> s1 + s2：返回s1和s2连接之后的结果<br><span class="hljs-bullet">8.</span> s1 = s2：用s2的副本代替s1中原来的字符<br><span class="hljs-bullet">9.</span> s1 == s2：判断s1和s2中的字符是不是都是一样的<br><span class="hljs-bullet">10.</span> s1 != s2<br><span class="hljs-bullet">11.</span> &lt;，&lt;=，&gt;，&gt;=：利用字符在字典中的顺序进行比较，且对字母的大小写敏感<br></code></pre></td></tr></table></figure></li><li><p>读写string对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s; <span class="hljs-comment">//空字符串</span><br>cin &gt;&gt; s; <span class="hljs-comment">//将string对象读入s，遇到空白停止</span><br>cout &lt;&lt; s &lt;&lt; endl; <span class="hljs-comment">//输出s</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//在执行读取的时候，string对象会自动忽略开头的空白（空格符、换行符或者制表符等等）</span><br><span class="hljs-comment">//并从真正的第一个字符读起，直到遇见下一处空白为止。</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//读取未知数量的string对象</span><br>string <span class="hljs-keyword">word</span>;<br><span class="hljs-comment">//循环结束的条件：遇到文件结束标记或者非法输入</span><br><span class="hljs-keyword">while</span> (cin &gt;&gt; <span class="hljs-keyword">word</span>) &#123;<br>cout &lt;&lt; <span class="hljs-keyword">word</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//希望能在最终得到的字符串中保留输入时的空白符</span><br><span class="hljs-comment">//使用getline()函数代替&gt;&gt;运算符</span><br><span class="hljs-comment">//getline()函数的参数是一个输入流和一个string对象</span><br><span class="hljs-comment">//函数从给定的输入流中读取内容，直到遇到换行符时为止</span><br><span class="hljs-comment">//注意换行符也会被读进来</span><br><span class="hljs-comment">//然后把所读的内容存入到那个string对象中</span><br><span class="hljs-comment">//注意存的时候不存换行符</span><br><span class="hljs-comment">//getline()只要一遇到换行符就结束读取操作并返回结果</span><br><span class="hljs-comment">//getline()的返回值是它的流参数</span><br>string str;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, str)) &#123;<br>cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>empty()和size()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//empty()是string的一个成员函数</span><br><span class="hljs-comment">//只输出非空的行</span><br>string line;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin, line))&#123;<br>    <span class="hljs-keyword">if</span>(!line.<span class="hljs-built_in">empty</span>())&#123;<br>        cout &lt;&lt; line &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//size()返回string中字符的个数</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin, line))&#123;<br>    <span class="hljs-keyword">if</span>(line.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">80</span>)&#123;<br>        cout &lt;&lt; line &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>size函数返回的是一个string::size_type类型的值：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> string类型及其他大多数标准库类型都定义了几种配套的类型。<br><span class="hljs-bullet">2.</span> 这些配套类型体现了标准库类型与机器无关的特性。<br><span class="hljs-bullet">3.</span> 类型size<span class="hljs-emphasis">_type即是其中的一种。</span><br><span class="hljs-emphasis">4. 在使用的时候，通过作用域操作符来表明名字size_</span>type是在类string中定义的。<br><span class="hljs-bullet">5.</span> size<span class="hljs-emphasis">_type的特点：它是一个无符号类型的值而且能足够存放下任何string对象的大小。</span><br><span class="hljs-emphasis">6. 所有用于存放string类的size函数返回值的变量，都应该是string::size_</span>type类型的。<br>auto len = line.size();//auto通过返回值的类型来推断变量的类型<br><span class="hljs-bullet">7.</span> 由于size函数返回的是一个无符号的整数，因此切记如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。<br></code></pre></td></tr></table></figure></li><li><p>比较string对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//相等性运算符(==或者!=)</span><br><span class="hljs-comment">//string对象相等意味着它们的长度相同并且包含的字符完全相同</span><br><span class="hljs-comment">//关系运算符按照字典序对两个字符串进行逐字符比较</span><br>string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>string str1 = <span class="hljs-string">&quot;helloo&quot;</span>;<br>string str2 = <span class="hljs-string">&quot;hz&quot;</span>;<br><span class="hljs-comment">//str2最大，str1其次，str最小</span><br></code></pre></td></tr></table></figure></li><li><p>为string对象赋值：对string对象而言，允许把一个string对象的值赋给另外一个string对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>)</span>, str2</span>;<br>str2 = str1;<br></code></pre></td></tr></table></figure></li><li><p>两个string对象相加：字符串拼接。</p></li><li><p>字面量和string对象相加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp语言中的字符串字面值并不是标准库类型string的对象</span><br><span class="hljs-comment">//切记，字符串字面值和string是不同的类型</span><br><span class="hljs-comment">//标准库允许把字符字面值和字符串字面值转换成string对象</span><br><span class="hljs-comment">//所以在需要string对象的地方就可以使用这两种字面值来替代</span><br>string s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>string s2 = <span class="hljs-string">&quot;world&quot;</span>;<br>string s3 = s1 + <span class="hljs-string">&quot;, &quot;</span> + s2 + <span class="hljs-string">&#x27;\n&#x27;</span>;<br><span class="hljs-comment">//需要注意的是，两个字符串字面值是没有办法使用 + 拼接的</span><br><span class="hljs-comment">//所以当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少有一个是string。</span><br>string s5 = <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;, &quot;</span> + s1; <span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.2 编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入一个词</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用getline()从标准输入中一次读入一整行</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string line;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入您的字符串，可以包含空格：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(cin, line)) &#123;<br>cout &lt;&lt; line &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用cin从标准输入中一次读入一个词</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string word;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入您的单词，不可以包含空格：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; word) &#123;<br>cout &lt;&lt; word &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.3 请说明string类的输入运算符和getline()函数分别是如何处理空白字符的</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 标准库string的输入运算符自动忽略字符串开头的空白（包括空格符、换行符和制表符等），从第一个真正的字符开始读起，直到遇见下一个空白为止。<br><span class="hljs-bullet">2.</span> getline()从给定的输入流中读取数据，直到遇到换行符为止，此时换行符也被读取进来，但是并不存储在最后的字符串里。<br></code></pre></td></tr></table></figure></li><li><p>练习3.4 编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等则输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s1, s2;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个字符串，然后用空格分割&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br><span class="hljs-keyword">if</span> (s1 == s2) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;两个字符串相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s1 &gt; s2) &#123;<br>cout &lt;&lt; s1 &lt;&lt; endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>cout &lt;&lt; s2 &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s1, s2;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入两个字符串，然后用空格分割&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; s1 &gt;&gt; s2;<br><span class="hljs-keyword">auto</span> len1 = s1.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">auto</span> len2 = s2.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (len1 == len2) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;两个字符串一样长&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len1 &gt; len2) &#123;<br>cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;比较长&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&quot;比较长&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.5 编写一段程序从标准输入中读入多个字符串并把它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> flag = <span class="hljs-string">&#x27;y&#x27;</span>;<br>string s, result;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入第一个字符串：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>result += s;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续(y or n)&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; flag;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入下一个字符串：&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;拼接后的字符串是：&quot;</span> &lt;&lt; result &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">char</span> flag = <span class="hljs-string">&#x27;y&#x27;</span>;<br>string s, result;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入第一个字符串：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>result += s;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续(y or n)&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; flag;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-string">&#x27;y&#x27;</span>) &#123;<br>result += <span class="hljs-string">&quot; &quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入下一个字符串：&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;拼接后的字符串是：&quot;</span> &lt;&lt; result &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h4><ol><li><p>在cctype头文件中定义了一组标准库函数用于处理string对象中的字符。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> isalnum(c)：当c是字母或者数字时为真<br><span class="hljs-bullet">2.</span> isalpha(c)：当c是字母时为真<br><span class="hljs-bullet">3.</span> iscntrl(c)：当c是控制字符时为真<br><span class="hljs-bullet">4.</span> isdigit(c)：当c是数字时为真<br><span class="hljs-bullet">5.</span> isgraph(c)：当c不是空格并且c可以打印时为真<br><span class="hljs-bullet">6.</span> islower(c)：当c是小写字母时为真<br><span class="hljs-bullet">7.</span> isprint(c)：当c是可打印字符时为真(包括空格)<br><span class="hljs-bullet">8.</span> ispunct(c)：当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）<br><span class="hljs-bullet">9.</span> isspace(c): 当c是空白时为真<br><span class="hljs-bullet">10.</span> isupper(c)：当c是大写字母时为真<br><span class="hljs-bullet">11.</span> isxdigit(c)：当c是十六进制数字时为真<br><span class="hljs-bullet">12.</span> tolower(c)：如果c是大写字母，则输出对应的小写字母，否则原样输出c<br><span class="hljs-bullet">13.</span> toupper(c)：如果c是小写字母，则输出对应的大写字母，否则原样输出c<br></code></pre></td></tr></table></figure></li><li><p>c++标准库中除了定义cpp语言特有的功能外，也兼容了c语言的标准库。c语言的头文件型如name.h，c++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于c语言标准库的头文件。</p></li><li><p>在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中则不然。</p></li><li><p>基于范围的for语句：一种方便的处理string对象中每个字符的手段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(declaration : expression)&#123;<br>    statement;<br>&#125;<br><span class="hljs-comment">//expression部分是一个对象，表示一个序列</span><br><span class="hljs-comment">//declaration部分负责定义一个变量，该变量用于访问序列中的基础元素</span><br><span class="hljs-comment">//每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : str)&#123;<span class="hljs-comment">//对于str中的每个字符，这里auto的类型是char</span><br>    cout &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">//输出当前字符，后面紧跟一个换行符</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cctype&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//使用范围for语句和ispunct函数来统计string对象中标点符号的个数</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello,World!!!&quot;</span>)</span></span>;<br><span class="hljs-comment">//punct_cnt的类型和s.size的返回类型是一样的；</span><br><span class="hljs-keyword">decltype</span>(s.<span class="hljs-built_in">size</span>()) punct_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//统计s中标点符号的数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ispunct</span>(c)) &#123;<br>punct_cnt++;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;标点符号的个数是：&quot;</span> &lt;&lt; punct_cnt &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello, world&quot;</span>)</span></span>;<br>cout &lt;&lt; s &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : s) &#123;<br>c = <span class="hljs-built_in">toupper</span>(c); <span class="hljs-comment">//c是一个引用，因此赋值语句将改变s中字符的值</span><br>&#125;<br>cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>访问string对象中的单个字符有两种方式，一种是使用下标，另一种是使用迭代器。</p></li><li><p>下标运算符([ ])，接收的输入参数是string::size_type类型的值，这个 参数表示要访问的字符的位置，返回值是该位置上字符的引用。</p></li><li><p>string对象的下标必须大于等于0而小于s.size()。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>    cout&lt;&lt;s[<span class="hljs-number">0</span>]&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//把s的第一个词改成大写形式</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<br>    <span class="hljs-comment">//注意&amp;&amp;运算符的特性</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(s.<span class="hljs-built_in">size</span>()) index = <span class="hljs-number">0</span>; index &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(s[index]); index++) &#123;<br>s[index] = <span class="hljs-built_in">toupper</span>(s[index]);<br>&#125;<br>cout &lt;&lt; s &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意检查下标的合法性，一种简便易行的方法是：</span><br><span class="hljs-comment">//总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0</span><br><span class="hljs-comment">//此时代码只需保证下标小于size()的值就可以了</span><br></code></pre></td></tr></table></figure></li><li><p>编写一个程序把0到15之间的十进制数转换成对应的十六进制形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> string hexdigits = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入0到15之间的数字，用空格隔开，键入enter表示结束&quot;</span> &lt;&lt; endl;<br>string result;<br><span class="hljs-keyword">decltype</span>(hexdigits.<span class="hljs-built_in">size</span>()) n;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br><span class="hljs-keyword">if</span> (n &lt; hexdigits.<span class="hljs-built_in">size</span>()) &#123;<br>result += hexdigits[n];<br>&#125;<br>&#125;<br>cout &lt;&lt; result &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.6 编写一段程序，使用范围for语句将字符串内的所有字符用X代替</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个字符串，可以包含空格&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">getline</span>(cin, s); <span class="hljs-comment">//读取整行，遇到回车符结束</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : s) &#123;<br>c = <span class="hljs-string">&#x27;X&#x27;</span>;<br>&#125;<br>cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.7 就上一题完成的程序而言，如果将循环控制变量的类型设置为char将发生什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//就本题而言，将循环控制变量的类型设置为char不会对程序运行结果造成影响</span><br><span class="hljs-comment">//因为我们使用auto自动推断字符串s的元素类型，结果同样是char</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.8 分别用while循环和传统的for循环重写练习3.6的程序，说明两种形式哪个更好一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个字符串，可以包含空格：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-keyword">decltype</span>(s.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>s[i] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>i++;<br>&#125;<br>cout &lt;&lt; s &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个字符串，可以包含空格：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>s[i] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>&#125;<br>cout &lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.9 下面的程序有何作用，它合法吗？如果不合法，为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string s;<br>cout&lt;&lt; s[<span class="hljs-number">0</span>]&lt;&lt;endl;<br><span class="hljs-comment">//程序是错误的</span><br><span class="hljs-comment">//因为初始状态下没有给s赋任何初值，所以字符串s的内容为空</span><br><span class="hljs-comment">//当然也就不存在首字符，下标0是非法的</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.10 编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s, result;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个字符串，最好带有某些标点符号：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">getline</span>(cin, s);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(s.<span class="hljs-built_in">size</span>()) i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ispunct</span>(s[i])) &#123;<br>result += s[i];<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;去除所有的标点之后的字符串是：&quot;</span> &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.11 下面的范围for语句合法吗，如果合法，c的类型是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> string s = <span class="hljs-string">&quot;Keep out!&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;c : s)&#123;<br>    <br>&#125;<br><span class="hljs-comment">//该程序段从语法上来说是合法的</span><br><span class="hljs-comment">//s是一个常量字符串，则c推断类型是常量引用</span><br><span class="hljs-comment">//即c所绑定的对象值不能改变</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h4><ol><li><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中每个对象都有一个对应的索引，索引用于访问对象，因为vector“容纳着”其它对象，所以它也被称作容器。</p></li><li><p>使用vector必须包含适当的头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> std::vector;<br></code></pre></td></tr></table></figure></li><li><p>cpp语言既有类模板也有函数模板，其中vector是一个类模板。</p></li><li><p>模板本身不是类或者函数，相反可以将模板看作为编译器生成类或者函数编写的一份说明，编译器根据模板创建类或者函数的过程称为实例化，当使用模板时，需要指出编译器应把类或者函数实例化成何种类型。</p></li><li><p>对于类模板，我们提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以vector为例，提供的额外信息是vector内存放对象的类型：</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; ivec;<span class="hljs-comment">//ivec存放的是int类型的对象</span><br>vector&lt;Sales_item&gt; Sales_vec; <span class="hljs-comment">//存放的是Sales_item对象</span><br>vector&lt;vector&lt;string&gt;&gt; file; <span class="hljs-comment">//该向量的元素是vector对象</span><br></code></pre></td></tr></table></figure></li><li><p>vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。</p></li><li><p>vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。</p></li><li><p>初始化vector对象的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;T&gt; v1; <span class="hljs-comment">//v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>; <span class="hljs-comment">//v2中包含有v1所有元素的副本</span><br>vector&lt;T&gt; v2 = v1; <span class="hljs-comment">//等价于v2(v1)</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v3</span><span class="hljs-params">(n, val)</span></span>; <span class="hljs-comment">//包含了n个重复的元素，其中每个元素的值都是val</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v4</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//包含了n个重复地执行了值初始化的对象</span><br>vector&lt;T&gt; v5&#123;a, b, c...&#125;; <span class="hljs-comment">//包含了初始值个数的元素，每个元素被赋予相应的初始值</span><br>vector&lt;T&gt; v5 = &#123;a, b, c...&#125; <span class="hljs-comment">//等价于v5&#123;a, b, c...&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>不同初始化方式的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//拷贝初始化和直接初始化不能等价的三个地方</span><br><span class="hljs-comment">//1. 使用拷贝初始化时，只能提供一个初始值。</span><br><span class="hljs-comment">//2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或者使用花括号的形式进行初始化。</span><br><span class="hljs-comment">//3. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。</span><br>vector&lt;string&gt; v1&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>&#125;;<span class="hljs-comment">//列表初始化</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>)</span></span>;<span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时vector会创建一个值初始化的元素初值，并把它赋值给容器中的所有元素。这个初值是由vector对象中元素的类型决定的。</p></li><li><p>如果vector对象的元素是内置类型，比如int，则元素初始值自动设置为0；如果元素是某种类型，比如string，则元素由类默认初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//10个元素，每个都初始化为0</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//10个元素，每个都是空string对象</span><br><span class="hljs-comment">//对这种初始化的方式有两个特殊限制。</span><br><span class="hljs-comment">//其一，有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化</span><br><span class="hljs-comment">//就必须提供初始的元素值</span><br><span class="hljs-comment">//对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。</span><br><span class="hljs-comment">//其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vi = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，必须使用直接初始化形式指定向量的大小</span><br></code></pre></td></tr></table></figure></li><li><p>在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//v1有10个元素，每个元素的值都是0</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v2&#123;<span class="hljs-number">10</span>&#125;; <span class="hljs-comment">//v2有一个元素，该元素的值是10</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//v3有10个元素，每个元素的值都是1</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v4&#123;<span class="hljs-number">10</span>, <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">//v4有两个元素，值分别是10和1</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.12 下列vector对象的定义有不正确的嘛？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//正确，定义了一个叫ivec的vector对象</span><br><span class="hljs-comment">//其中每个元素都是vector&lt;int&gt;对象</span><br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ivec;<br><span class="hljs-comment">//不正确，svec的元素类型是string，而ivec得元素类型是vector&lt;int&gt;，因此不能使用ivec初始化svec</span><br>vector&lt;string&gt; svec = ivec;<br><span class="hljs-comment">//正确</span><br><span class="hljs-comment">//该svec中含有10个元素，每个字符串都是null</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;null&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>练习3.13 下列vector对象各包含多少个元素？这些元素的值分别是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//元素数量为0</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br><span class="hljs-comment">//元素数量为10，每一个元素都被初始化为0</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">//元素数量为10，每一个元素都被初始化为42</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>;<br><span class="hljs-comment">//元素数量为1，元素的值为10</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v4&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-comment">//元素的数量为2，两个元素的值分别是10和42</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v5&#123;<span class="hljs-number">10</span>, <span class="hljs-number">42</span>&#125;;<br><span class="hljs-comment">//元素的数量为10，每一个元素都被初始化为空串</span><br>vector&lt;string&gt; v6&#123;<span class="hljs-number">10</span>&#125;;<br><span class="hljs-comment">//元素的数量为10，每一个元素都被初始化为&quot;hi&quot;</span><br>vector&lt;string&gt; v7&#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h4 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h4><ol><li><p>push_back负责把一个值当成vector对象的尾元素压入到vector对象的尾端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>cout &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>vector对象能高效增长</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//cpp标准要求vector应该能在运行时高效快速的添加元素</span><br><span class="hljs-comment">//因此既然vector对象能高效的增长，那么在定义vector对象的时候设定其大小也就没什么必要了</span><br><span class="hljs-comment">//事实上这么做性能可能会更差，只有一种例外情况，就是所有元素的值都一样</span><br><span class="hljs-comment">//一旦元素的值有所不同</span><br><span class="hljs-comment">//更有效的办法是先定义一个空vector对象，然后在运行时向其中添加具体值。</span><br></code></pre></td></tr></table></figure></li><li><p>使用vector编程的时候需要注意：如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环，因为范围for语句体内不应改变其所遍历序列的大小。</p></li><li><p>练习3.14 编写一段程序，用cin读入一组整数并把它们存入一个vector对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">int</span> i; <span class="hljs-comment">//记录用户的输入值</span><br><span class="hljs-keyword">char</span> cont = <span class="hljs-string">&#x27;y&#x27;</span>;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; i) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(i);<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续（y or no）&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; cont;<br><span class="hljs-keyword">if</span> (cont != <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : vInt) &#123;<br>cout &lt;&lt; num &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.15 改写上题的程序，不过这次读入的是字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;string&gt; vString;<br>string s;<br><span class="hljs-keyword">char</span> cont = <span class="hljs-string">&#x27;y&#x27;</span>;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>vString.<span class="hljs-built_in">push_back</span>(s);<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续（y or n）&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; cont;<br><span class="hljs-keyword">if</span> (cont != <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> str : vString) &#123;<br>cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h4><ol><li><p>vector提供的一些其它的重要操作，大多数都和string的相关操作类似</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> v.empty()：如果v中不含有任何元素，返回真，否则返回假<br><span class="hljs-bullet">2.</span> v.size()：返回v中元素的个数<br><span class="hljs-bullet">3.</span> v.push<span class="hljs-emphasis">_back(t)：向v的尾端添加一个值为t的元素</span><br><span class="hljs-emphasis">4. v[n]：返回v中第n个位置上的元素</span><br><span class="hljs-emphasis">5. v1 = v2：用v2中的元素的拷贝替换v1中的元素</span><br><span class="hljs-emphasis">6. v1 = &#123;a, b, c...&#125;：用列表中元素的拷贝替换v1中的元素</span><br><span class="hljs-emphasis">7. v1 == v2：v1和v2相等，当且仅当它们的元素数量相同且对应位置的元素值相同</span><br><span class="hljs-emphasis">8. v1 != v2;</span><br><span class="hljs-emphasis">9. &lt;, &lt;=, &gt;, &gt;= 以字典顺序进行比较</span><br></code></pre></td></tr></table></figure></li><li><p>size返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//要使用size_type，需要先指定它是由哪种类型定义的</span><br><span class="hljs-comment">//vector对象的类型总是包含着元素的类型</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt;::size_type <span class="hljs-comment">//正确</span><br>vector::size_type <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>相等性运算符和关系运算符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">只有当元素的值可比较的时候，vector对象才能被比较。<br>一些类，如string等，确实定义了自己的相等运算符和关系运算符。<br>另外一些，如Sales<span class="hljs-emphasis">_item类并不支持相等性判断和关系运算等操作，因此并不能比较两个vector<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Sales_item</span>&gt;</span></span>对象。</span><br></code></pre></td></tr></table></figure></li><li><p>使用vector内对象的索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用下标运算符能获取指定的元素</span><br><span class="hljs-comment">//下标的类型是相应的size_type类型</span><br><span class="hljs-comment">//只要vector对象不是一个常量，就能向下标运算符返回的元素赋值</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">unsigned</span>&gt; <span class="hljs-title">scores</span><span class="hljs-params">(<span class="hljs-number">11</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">unsigned</span> grade;<br><span class="hljs-keyword">while</span>(cin &gt;&gt; grade)&#123;<br>    <span class="hljs-keyword">if</span>(grade &gt;= <span class="hljs-number">0</span> &amp;&amp; grade &lt;= <span class="hljs-number">100</span>)&#123;<br>        scores[grade / <span class="hljs-number">10</span>]++；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>vector对象以及string对象的下标运算符可以用于访问已经存在的元素，而不能用于添加元素。</p></li><li><p>关于下标必须明确的一点是：只能对确知已存在的元素执行下标操作。试图用下标去访问一个不存在的元素会引发错误，这类错误通常被称为缓冲区溢出。</p></li><li><p>练习3.16 编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; v1;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v4&#123; <span class="hljs-number">10</span> &#125;;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v5&#123; <span class="hljs-number">10</span>, <span class="hljs-number">42</span> &#125;;<br>vector&lt;string&gt; v6&#123; <span class="hljs-number">10</span> &#125;;<br>vector&lt;string&gt; v7&#123; <span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span> &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1的元素个数是：&quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : v1) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v2的元素个数是：&quot;</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v2.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : v2) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v3的元素个数是：&quot;</span> &lt;&lt; v3.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v3.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : v3) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v4的元素个数是：&quot;</span> &lt;&lt; v4.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v4.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : v4) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v5的元素个数是：&quot;</span> &lt;&lt; v5.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v5.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : v5) &#123;<br>cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v6的元素个数是：&quot;</span> &lt;&lt; v6.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v6.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> str : v6) &#123;<br>cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;v7的元素个数是：&quot;</span> &lt;&lt; v7.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (v7.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> str : v7) &#123;<br>cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>练习3.17 从cin读入一组词并把它们存入一个vector对象，然后设法把所有的词改成大写形式。输出改变后的结果，每个词占一行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector &lt;string&gt; svec;<br>string s;<br><span class="hljs-keyword">char</span> cont = <span class="hljs-string">&#x27;y&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入第一个词：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>svec.<span class="hljs-built_in">push_back</span>(s);<br>cout &lt;&lt; <span class="hljs-string">&quot;是否继续（y or n）&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; cont;<br><span class="hljs-keyword">if</span> (cont != <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;修改之后的结果为：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : svec) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; ch : str) &#123;<br>ch = <span class="hljs-built_in">toupper</span>(ch);<br>&#125;<br>cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.18 下面的程序合法吗？如果不合法，你准备如何修改？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">int</span>&gt; ivec;<br>ivec[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>;<br><span class="hljs-comment">//该程序是非法的，因为ivec目前没有任何元素</span><br><span class="hljs-comment">//ivec[0]的形式是错误的，程序试图访问的元素根本不存在</span><br><span class="hljs-comment">//要想向vector对象中添加新元素，需要使用push_back函数</span><br></code></pre></td></tr></table></figure></li><li><p>练习3.19 如果向定义一个含有10个元素的vector对象，所有元素的值都是42，请列举出三种不同的实现方法，并说明这些方法之间的区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//思路一：先定义一个空vector对象，然后添加元素</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>    vInt.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);<br>&#125;<br><span class="hljs-comment">//思路二：列表初始化，罗列出全部10个元素的值</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt = &#123;<span class="hljs-comment">/*10个42*/</span>&#125;;<br><span class="hljs-comment">//思路三：用花括号给出所有元素的值，效果类似于思路二</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt&#123;<span class="hljs-comment">/*10个42*/</span>&#125;;<br><span class="hljs-comment">//思路四：定义的时候用参数指定元素的个数以及重复的值</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vInt</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">42</span>)</span></span>;<br><span class="hljs-comment">//思路五：先指定元素的个数然后用for循环依次为元素赋值</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vInt</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;num : vInt)&#123;<br>    num = <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习3.20 读入一组整数并且把它们存入vector对象，将每对相邻整数的和输出出来。然后改写你的程序，这次要求先输出第一个和最后一个元素的和，接着输出第二个和倒数第二个元素的和，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">int</span> iVal;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一组数字：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; iVal) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(iVal);<br>&#125;<br><span class="hljs-keyword">decltype</span>(vInt.<span class="hljs-built_in">size</span>()) len = vInt.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;向量中没有任何的元素&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//len = 7 i = 0 2 4 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">decltype</span>(len) i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i = i + <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">int</span> sum = vInt[i] + vInt[i + <span class="hljs-number">1</span>];<br>cout &lt;&lt; sum&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; vInt[len - <span class="hljs-number">1</span>];<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//求首尾元素和</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vInt;<br><span class="hljs-keyword">int</span> iVal;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一组数字：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; iVal) &#123;<br>vInt.<span class="hljs-built_in">push_back</span>(iVal);<br>&#125;<br><span class="hljs-keyword">decltype</span>(vInt.<span class="hljs-built_in">size</span>()) len = vInt.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;向量中没有任何的元素&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">decltype</span>(vInt.<span class="hljs-built_in">size</span>()) right = len - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">decltype</span>(vInt.<span class="hljs-built_in">size</span>()) left = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>cout &lt;&lt; vInt[left] + vInt[right]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>left++;<br>right--;<br>&#125;<br><span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; vInt[left];<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter3&lt;/p&gt;
&lt;p&gt;主要内容包括命名空间的using声明、标准库类型string和标准库类型vector&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_2_40</title>
    <link href="http://example.com/cpp-primer-2-40/"/>
    <id>http://example.com/cpp-primer-2-40/</id>
    <published>2021-05-22T01:31:33.000Z</published>
    <updated>2021-05-23T03:05:44.941Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer_5th_chapter2</p><span id="more"></span><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><ol><li><p>指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">//pi是一个常量，它的值不能改变</span><br><span class="hljs-keyword">double</span> *ptr = &amp;pi; <span class="hljs-comment">//错误，ptr是一个普通的指针</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;pi; <span class="hljs-comment">//正确，cptr可以指向一个双精度常量</span><br>*cptr = <span class="hljs-number">42</span>; <span class="hljs-comment">//错误，不能给*cptr赋值</span><br></code></pre></td></tr></table></figure></li><li><p>指针的类型必须与其所指对象的类型是一致的。（第一种例外情况）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//第一种例外情况是允许令一个指向常量的指针指向一个非常量对象</span><br><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br>cptr = &amp;dval; <span class="hljs-comment">//正确，但是不能通过cptr改变dval的值</span><br></code></pre></td></tr></table></figure></li><li><p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其它途径改变。</p></li><li><p>注意区别指向常量的指针和常量指针。</p></li><li><p>指针是一个对象，因此允许把指针本身定义为常量。</p></li><li><p>常量指针必须初始化，而且一旦初始化完成，存放在指针中的那个地址就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写隐含着一层意味，即不变的是指针本身的值而非指向的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> errNumb = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> curErr = &amp;errNumb; <span class="hljs-comment">//curErr将一直指向errNumb的地址</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14159</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *<span class="hljs-keyword">const</span> pip = &amp;pi; <span class="hljs-comment">//pip是一个指向常量对象的常量指针</span><br><span class="hljs-comment">//弄清楚声明的含义最行之有效的方法是从右向左阅读</span><br><span class="hljs-comment">//离curErr最近的符号是const，意味着curErr本身是一个常量对象</span><br><span class="hljs-comment">//对象的类型由声明符的其余部分确定</span><br><span class="hljs-comment">//声明符中的下一个符号是*，意思是curErr是一个常量指针</span><br><span class="hljs-comment">//最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象</span><br><span class="hljs-comment">//与此相似，pip是一个常量指针，它指向的对象是一个双精度浮点型常量</span><br></code></pre></td></tr></table></figure></li><li><p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。如上例中的pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。curErr指向的是一个一般的非整数常量，那么完全可以通过curErr去修改errNumb的值。</p></li><li><p>练习2.27 下面哪些初始化是合法的，请说明原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//非法的，非常量引用r不能引用字面值常量0</span><br><span class="hljs-comment">//int i = -1, &amp; r = 0;</span><br><span class="hljs-comment">//合法的，p2是一个常量指针，p2的值永不改变，即p2永远指向变量i2</span><br><span class="hljs-comment">//int* const p2 = &amp;i2;</span><br><span class="hljs-comment">//合法的，i是一个常量，r是一个常量引用，此时r可以永远绑定到字面值常量0</span><br><span class="hljs-comment">//const int i = -1, &amp; r = 0;</span><br><span class="hljs-comment">//合法的，p3是一个常量指针，p3的值永远指向i2</span><br><span class="hljs-comment">//同时p3指向的是常量，即不能通过p3改变所指对象的值</span><br><span class="hljs-comment">//const int* const p3 = &amp;i2;</span><br><span class="hljs-comment">//p1指向一个常量，即不能通过p1改变所指对象的值</span><br><span class="hljs-comment">//const int* p1 = &amp;i2;</span><br><span class="hljs-comment">//非法的，引用本身不是对象，因此不能让引用恒定不变</span><br><span class="hljs-comment">//const int&amp; const r2;</span><br><span class="hljs-comment">//合法的，i2是一个常量，r是一个常量引用</span><br><span class="hljs-comment">//const int i2 = i, &amp; r = i;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习2.28 说明下面这些定义是什么意思，挑出其中不合法的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//非法的，cp是一个常量指针，因为其值不能被改变，所以必须进行初始化。</span><br><span class="hljs-comment">//int i, * const cp;</span><br><span class="hljs-comment">//非法的，p2是一个常量指针，因为其值不能被改变，所以必须进行初始化。</span><br><span class="hljs-comment">//int* p1, * const p2;</span><br><span class="hljs-comment">//非法的，ic是一个常量，因其值不能被改变，所以必须进行初始化。</span><br><span class="hljs-comment">//const int ic, &amp; r = ic;</span><br><span class="hljs-comment">//p3是一个常量指针，因其值不能被改变，所以必须进行初始化。同时p3指向的是常量，即不能通过p3改变所指对象的值。</span><br><span class="hljs-comment">//const int* const p3;</span><br><span class="hljs-comment">//合法的，但是p没有指向任何实际的对象。</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>* p;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习2.29 假设已有2.28练习中定义的那些变量，则下面的那些语句是合法的？请说明原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a) i = ic; <span class="hljs-comment">//合法的，常量ic的值赋给了非常量i</span><br>(b) p1 = p3; <span class="hljs-comment">//非法的，普通指针p1指向了一个常量，从语法上来说，p1的值可以随意改变</span><br>(c) p1 = &amp;ic; <span class="hljs-comment">//非法的，普通指针指向了一个常量</span><br>(d)p3 = &amp;ic; <span class="hljs-comment">//p3是一个常量指针，不能被赋值</span><br>(e)p2 = p1; <span class="hljs-comment">//p2是一个常量指针，不能被赋值</span><br>(f) ic = *p3; <span class="hljs-comment">//非法的，ic是一个常量，不能被赋值</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h4><ol><li><p>指针本身是一个对象，它又可以指向另外一个对象，因此指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。</p></li><li><p>顶层const：指针本身是一个常量。</p></li><li><p>底层const：指针所指对象是一个常量。</p></li><li><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算数类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const，这一点和其它类型的的区别比较明显。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p1 = &amp;i; <span class="hljs-comment">//不能改变p1的值，这是一个顶层const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">42</span>; <span class="hljs-comment">//不能改变ci的值，这是一个顶层const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;ci; <span class="hljs-comment">//可以改变p2的值，这是一个底层const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = p2; <span class="hljs-comment">//靠右的是顶层const，靠左的是底层const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r = ci; <span class="hljs-comment">//用于声明引用的const都是底层const</span><br></code></pre></td></tr></table></figure></li><li><p>当执行对象的拷贝操作的时候，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = ci; <span class="hljs-comment">//正确，拷贝ci的值，ci是一个顶层const，对此操作无影响</span><br>p2 = p3; <span class="hljs-comment">//正确，p2和p3指向的对象类型相同，p3顶层const的部分不影响</span><br></code></pre></td></tr></table></figure></li><li><p>对于底层const，执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p = p3; <span class="hljs-comment">//错误，p3包含底层const的定义，而p没有</span><br>p2 = p3;<span class="hljs-comment">//正确，p2和p3都是底层const</span><br>p2 = &amp;i;<span class="hljs-comment">//正确，int*能转换成const int*</span><br><span class="hljs-keyword">int</span> &amp;r = ci;<span class="hljs-comment">//错误，普通的int&amp;不能绑定到int常量上</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">//正确，const int&amp;可以绑定到一个普通int上</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.30 对于下面这些语句，请说明对象被声明成了顶层const还是底层const?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> v2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> v1 = v2;<br><span class="hljs-keyword">int</span> *p1 = &amp;v1, &amp;r1 = v1;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = &amp;v2, *<span class="hljs-keyword">const</span> p3 = &amp;i, &amp;r2 = v2;<br><span class="hljs-comment">//v2和p3是顶层const，分别表示一个整型常量和一个整型常量指针</span><br><span class="hljs-comment">//p2和r2是底层const，分别表示它们所指（所引用）的对象是常量</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.31 假设已有上一个练习中所做的那些声明，则下面哪些语句是合法的？请说明顶层const和底层const在每个例子中有何体现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//合法，r1是一个非常量引用，v2是一个常量（顶层const）</span><br><span class="hljs-comment">//把v2的值拷贝给r1不会对v2有任何的影响</span><br>r1 = v2;<br><span class="hljs-comment">//非法，p1是普通指针，指向的对象可以是任何值，p2是指向常量的指针</span><br><span class="hljs-comment">//p1指向p2所指的内容，可能错误的改变常量的值</span><br>p1 = p2;<br><span class="hljs-comment">//合法</span><br><span class="hljs-comment">//p2可以指向一个非常量，不会通过p2更改它所指的值</span><br>p2 = p1;<br><span class="hljs-comment">//非法的</span><br><span class="hljs-comment">//p3既包含顶层const定义，又包含底层const定义</span><br><span class="hljs-comment">//所以不能把p3的值赋给普通指针</span><br>p1 = p3;<br><span class="hljs-comment">//p2与p3包含相同的底层const，p3的顶层const可以忽略不计</span><br>p2 = p3;<br></code></pre></td></tr></table></figure></li></ol><h4 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h4><ol><li><p>常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p></li><li><p>一个对象（或者表达式）是不是常量表达式由它的数据类型和初始值共同决定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>; <span class="hljs-comment">//max_files是常量表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files + <span class="hljs-number">1</span>; <span class="hljs-comment">//limit是常量表达式</span><br><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>; <span class="hljs-comment">//staff_size不是常量表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-built_in">get_size</span>(); <span class="hljs-comment">//sz不是常量表达式，因为具体值直到运行时才能获取到，所以也不是常量表达式</span><br></code></pre></td></tr></table></figure></li><li><p>constexpr：允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> mf = <span class="hljs-number">20</span>; <span class="hljs-comment">//20是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> limit = mf + <span class="hljs-number">1</span>; <span class="hljs-comment">//mf + 1是常量表达式</span><br><span class="hljs-comment">//只有当size是一个constexpr函数的时候才是一条正确的声明语句</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure></li><li><p>尽管不能使用普通函数作为constexpr变量的初始值，c++11允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。</p></li><li><p>常量表达式的值需要在编译的时候就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”。</p></li><li><p>算数类型、指针和引用都属于字面值类型。自定义类、IO库、string类型则不属于字面值类型。</p></li><li><p>尽管指针和引用都能定义成constexpr，但是它们的初始值会受到严格的限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//存储于某个固定地址中的对象<br><span class="hljs-bullet">1.</span> 函数体内定义的变量一般来说并非存放于固定地址中，因此constexpr并不能指向这样的变量。<br><span class="hljs-bullet">2.</span> 定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。<br><span class="hljs-bullet">3.</span> 函数可以定义一类特殊的变量，这类变量有效范围超出函数本身，所以和定义在函数体之外的变量一样也有固定的地址。因此constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。<br></code></pre></td></tr></table></figure></li><li><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，而与指针所指的对象无关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//p是一个指向整型常量的指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *q = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// q是一个指向整数的常量指针</span><br><span class="hljs-comment">//constexpr把它所定义的对象置为了顶层const</span><br></code></pre></td></tr></table></figure></li><li><p>与其它常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//np是一个指向整数的常量指针，其值为空</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *np = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>; <span class="hljs-comment">//i的类型是整型常量</span><br><span class="hljs-comment">//i和j都必须定义在函数体之外</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;i; <span class="hljs-comment">//p是常量指针，指向整数常量i</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *p1 = &amp;j; <span class="hljs-comment">//p1是常量指针，指向整数j</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.32 下面的代码是否合法？如果非法，请设法将其修改正确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> null = <span class="hljs-number">0</span>, *p = null;<br><span class="hljs-comment">//代码是非法的</span><br><span class="hljs-comment">//修改：</span><br><span class="hljs-keyword">int</span> null = <span class="hljs-number">0</span>, *p = &amp;null;<br><span class="hljs-comment">//或者使用nullptr</span><br><span class="hljs-keyword">int</span> null = <span class="hljs-number">0</span>, *p = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ol><li><p>类型别名的作用：让复杂的类型名字变得简单明了、易于理解和使用，有助于程序员清楚的知道使用该类型的真实目的。</p></li><li><p>定义类型别名的方法一：使用typedef</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages; <span class="hljs-comment">//wages是double的同义词</span><br><span class="hljs-keyword">typedef</span> wages base, *p; <span class="hljs-comment">//base是double的同义词，p是double*的同义词</span><br><span class="hljs-comment">//typedef作为声明语句中的基本数据类型的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。</span><br><span class="hljs-comment">//和之前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。</span><br></code></pre></td></tr></table></figure></li><li><p>定义类型别名的方法二：使用别名声明来定义类型的别名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> SI = Sales_item;<br></code></pre></td></tr></table></figure></li><li><p>如果某个类型别名指代的是复合类型或者常量，那么把它用到声明语句里就会产生意想不到的后果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>* pstring;<br><span class="hljs-keyword">const</span> pstring cstr = <span class="hljs-number">0</span>; <span class="hljs-comment">//cstr是指向char的常量指针</span><br><span class="hljs-keyword">const</span> pstring *ps; <span class="hljs-comment">//ps是一个指针，它的对象是指向char的常量指针</span><br></code></pre></td></tr></table></figure></li><li><p>易错点：遇到使用类型别名的语句，错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>* pstring;<br><span class="hljs-keyword">const</span> pstring cstr = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* cstr = <span class="hljs-number">0</span>; <br><span class="hljs-comment">//上面两句代码是完全不等价的</span><br><span class="hljs-comment">//当声明语句中用到pstring时，其基本数据类型是指针。</span><br><span class="hljs-comment">//当用char *重写了声明语句之后，数据类型就变成了char，*成为了声明符中的一部分。</span><br><span class="hljs-comment">//这样改写的结果是const char成了基本数据类型，使前后两种声明的含义截然不同。</span><br><span class="hljs-comment">//前者声明了指向char的常量指针</span><br><span class="hljs-comment">//改写后的形式则声明了一个指向const char的指针</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><ol><li><p>auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必然有初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//由val1和val2相加的结果可以推断出item的类型</span><br><span class="hljs-keyword">auto</span> item = val1 + val2; <span class="hljs-comment">//item初始化为val1和val2相加的结果</span><br></code></pre></td></tr></table></figure></li><li><p>使用auto也能在一条语句中声明多个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样</span><br><span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>, *p = &amp;i; <span class="hljs-comment">//正确，i是整数，p是整型指针</span><br><span class="hljs-keyword">auto</span> sz = <span class="hljs-number">0</span>, pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">//错误，sz和pi的类型不一致</span><br></code></pre></td></tr></table></figure></li><li><p>使用引用其实是使用引用的对象，特别是当引用被用作初始值的时候，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp;r = i;<br><span class="hljs-keyword">auto</span> a = r;<span class="hljs-comment">//a是一个整数，因为r是i的别名，而i是一个整数</span><br></code></pre></td></tr></table></figure></li><li><p>auto一般会忽略掉顶层const，同时底层const会被保留下来，比如当初始值是一个指向常量的指针时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp;cr = ci;<br><span class="hljs-comment">//b是一个整数，ci的顶层const特性被忽略掉了</span><br><span class="hljs-keyword">auto</span> b = ci;<br><span class="hljs-comment">//c是一个整数，cr是ci的别名，ci本身就是一个顶层的const</span><br><span class="hljs-keyword">auto</span> c = cr;<br><span class="hljs-comment">//d是一个整型指针</span><br><span class="hljs-keyword">auto</span> d = &amp;i;<br><span class="hljs-comment">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span><br><span class="hljs-keyword">auto</span> e = &amp;ci;<br></code></pre></td></tr></table></figure></li><li><p>如果希望推断出的auto类型是一个顶层const，则需要明确的指出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> f = ci; <span class="hljs-comment">//ci的推断类型是int ，f的类型为const int</span><br></code></pre></td></tr></table></figure></li><li><p>将引用类型设置为auto，此时原来的初始化规则仍然适用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> &amp;g = ci; <span class="hljs-comment">//g是一个整型常量引用，绑定到ci上</span><br><span class="hljs-keyword">auto</span> &amp;h = <span class="hljs-number">42</span>; <span class="hljs-comment">//错误，不能向非常量引用绑定字面值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;j = <span class="hljs-number">42</span>; <span class="hljs-comment">//正确，可以为常量引用绑定字面值</span><br></code></pre></td></tr></table></figure></li><li><p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。</p></li><li><p>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//k是整数，l是整型引用</span><br><span class="hljs-keyword">auto</span> k = ci, &amp;l = i;<br><span class="hljs-comment">//m是对整型常量的引用，p是指向整型常量的指针</span><br><span class="hljs-keyword">auto</span> &amp;m = ci, *p = &amp;ci;<br><span class="hljs-comment">//错误，n的类型是int，而&amp;ci的类型是const int</span><br><span class="hljs-keyword">auto</span> &amp;n = i, *p2 = &amp;ci;<br></code></pre></td></tr></table></figure></li><li><p>练习2.33 利用本节定义的变量，判断下列语句的运行成果</p></li><li><p>练习2.34 基于上一个练习中的变量和语句编写一段程序，输出赋值前后变量的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp; r = i;<br><span class="hljs-keyword">auto</span> a = r; <span class="hljs-comment">//a是一个int类型的整数，因为r是i的别名而i是一个整数</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = i, &amp; cr = ci; <br><span class="hljs-keyword">auto</span> b = ci; <span class="hljs-comment">//b是一个整数，因为ci的顶层const特性被忽略掉了</span><br><span class="hljs-keyword">auto</span> c = cr; <span class="hljs-comment">//c是一个整数，因为cr是ci的别名，ci本身的顶层consst特性被忽略掉了</span><br><span class="hljs-keyword">auto</span> d = &amp;i; <span class="hljs-comment">//d是一个整型指针</span><br><span class="hljs-keyword">auto</span> e = &amp;ci;<span class="hljs-comment">//e是一个指向整型常量的指针（对常量对象取地址是一种底层const）</span><br><span class="hljs-keyword">auto</span>&amp; g = ci;<span class="hljs-comment">//g是一个整型常量引用，绑定到ci（设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留）</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; g &lt;&lt; std::endl;<br>a = <span class="hljs-number">42</span>; <span class="hljs-comment">//合法</span><br>b = <span class="hljs-number">42</span>; <span class="hljs-comment">//合法</span><br>c = <span class="hljs-number">42</span>; <span class="hljs-comment">//合法</span><br>d = <span class="hljs-number">42</span>; <span class="hljs-comment">//不合法</span><br>e = <span class="hljs-number">42</span>; <span class="hljs-comment">//不合法</span><br>g = <span class="hljs-number">42</span>; <span class="hljs-comment">//不合法，g绑定到了整型常量，所以不能修改它的值</span><br>std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; g &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习2.35 判断下列定义推断出的类型是什么，然后编写程序进行验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">auto</span> j = i; <span class="hljs-comment">//忽略i的顶层const特性，所以j的类型为int</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; k = i; <span class="hljs-comment">//k是绑定到常量上的引用</span><br><span class="hljs-keyword">auto</span>* p = &amp;i; <span class="hljs-comment">//p是指向常量的指针，对常量对象取地址是一种底层const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> j2 = i, &amp; k2 = i; <span class="hljs-comment">//j2是常量， k2是绑定到常量上的引用</span><br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(i).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(j).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(k).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(p).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(j2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(k2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><ol><li><p>希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。</p></li><li><p>decltype：选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它们的类型，却不实际计算表达式的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) sum = x;<span class="hljs-comment">//sum的类型就是函数f的返回类型</span><br><span class="hljs-comment">//编译器并不实际调用函数f</span><br><span class="hljs-comment">//而是使用当调用发生时f的返回值类型作为sum的类型。</span><br><span class="hljs-comment">//换句话说，编译器为sum指定的类型就是假如f被调用的话将会返回的那个类型。</span><br></code></pre></td></tr></table></figure></li><li><p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>; <span class="hljs-comment">//x的类型是const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x; <span class="hljs-comment">//y的类型是const int &amp;，y绑定到变量x</span><br><span class="hljs-keyword">decltype</span>(cj) z; <span class="hljs-comment">//错误，z是一个引用，必须初始化</span><br></code></pre></td></tr></table></figure></li><li><p>引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。</p></li><li><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//decltype的结果可以是引用类型</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-comment">//正确，加法的结果是int，因此b是一个未初始化的int</span><br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;<br><span class="hljs-comment">//错误，c是int&amp;，必须初始化</span><br><span class="hljs-keyword">decltype</span>(*p) c;<br><span class="hljs-comment">//r是一个引用，因此decltype(r)的结果是引用类型</span><br><span class="hljs-comment">//如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r + 0</span><br><span class="hljs-comment">//显然这个表达式的结果是一个具体值而非引用</span><br><span class="hljs-comment">//如果表达式的内容是解引用操作，则decltype将得到引用类型</span><br><span class="hljs-comment">//因此decltype(*p)的结果类型就是int&amp;，而非int</span><br></code></pre></td></tr></table></figure></li><li><p>decltype和auto的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//decltype的结果类型与表达式密切相关</span><br><span class="hljs-comment">//有一种情况需要特别注意：</span><br><span class="hljs-comment">//如果变量名加上了一对括号，则得到的类型与不加括号时会有不同</span><br><span class="hljs-comment">//decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型</span><br><span class="hljs-comment">//decltype((variable))的结果永远是引用</span><br><span class="hljs-keyword">decltype</span>((i)) d; <span class="hljs-comment">//错误，d是int&amp;，必须进行初始化</span><br><span class="hljs-keyword">decltype</span>(i) e; <span class="hljs-comment">//正确，e是一个未初始化的int</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.36 关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">decltype</span>(a) c = a; <span class="hljs-comment">//等同于int c = a;</span><br><span class="hljs-keyword">decltype</span>((b)) d = a; <span class="hljs-comment">//等同于int &amp;d = a;</span><br>++c;<br>++d;<br><span class="hljs-comment">//综上，程序结束后a,b,c,d四个值都为4</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.37 赋值是会产生引用的一种典型的表达式，引用的类型就是左值的类型。也就是说，如果i是int，则表达式i = x的类型是int&amp;。根据这一特点，请指出下面的代码中每一个变量的值和类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">decltype</span>(a) c = a; <span class="hljs-comment">//int c = a;</span><br><span class="hljs-keyword">decltype</span>(a = b) d = a;  <span class="hljs-comment">//int &amp;d = a;</span><br><span class="hljs-comment">//注意，编译器分析表达式并得到它的类型作为d的推断类型，但是不实际计算该表达式，所以a的值没有发生改变</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.38 说明又decltype指定类型和由auto指定类型有何区别。请举出一个例子，decltype指定的类型与auto指定的类型一样；再举一个例子，decltype指定的类型与auto指定的类型不一样。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">auto和decltype的区别主要有三个方面<br><span class="hljs-bullet">1.</span> auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。<br><span class="hljs-bullet">2.</span> 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。<br><span class="hljs-bullet">3.</span> 与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有所不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或者多层括号，则编译器将推断得到引用类型。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">auto</span> c1 = a; <span class="hljs-comment">//c1的类型是int</span><br><span class="hljs-keyword">decltype</span>(a) c2 = a; <span class="hljs-comment">//c2的类型也是int</span><br><span class="hljs-keyword">decltype</span>((a)) c3 = a; <span class="hljs-comment">//c3是一个引用，指向a</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> f1 = d; <span class="hljs-comment">//auto忽略顶层const，所以f1的类型是int</span><br><span class="hljs-keyword">decltype</span>(d) f2 = d; <span class="hljs-comment">//f2的类型和d完全一致，所以是const int</span><br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(c1).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(c2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(c3).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(f1).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">typeid</span></span>(f2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>c1++;<br>c2++;<br>c3++;<br>f1++;<br><span class="hljs-comment">//f2++; //会报错</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="定义Sales-data类型"><a href="#定义Sales-data类型" class="headerlink" title="定义Sales_data类型"></a>定义Sales_data类型</h4><ol><li><p>cpp允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的。</p></li><li><p>一个类定义的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>    std::string bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;<br>&#125;;<br><span class="hljs-comment">//类内部的名字必须唯一，但是可以与类外部定义的名字重复。</span><br><span class="hljs-comment">//类右侧的表示结束的花括号后必须写一个分号，</span><br><span class="hljs-comment">//因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。</span><br></code></pre></td></tr></table></figure></li><li><p>类体定义类的成员，我们的类只有数据成员。类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其它的Sales_data的对象。</p></li><li><p>cpp11规定，可以为数据成员提供一个类内初始值。创建对象时，类内初始值用于初始化数据成员。没有初始值的成员将被默认初始化，因此当定义Sales_data的对象时，units_sold和revenue都将初始化为0，bookNo将初始化为空字符串。</p></li><li><p>例 2.39 注意一定要写类定义体后面的分号。</p></li><li><p>例 2.40 根据自己的理解写出Sales_data类，最好和书中的例子有所区别。</p></li></ol><h4 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h4><ol><li><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应该与类的名字一样。例如，库类型string在名为string的头文件中定义。又如，我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p></li><li><p>头文件通常包含那些只能被定义一次的实体，如类，const和constexpr变量等。头文件也经常用到其它头文件的功能，例如，Sales_data类中包含有一个string成员，所以Sales_data.h必须包含string.h头文件，同时，使用Sales_data类的程序为了能操作bookNo成员需要再一次包含string.h头文件。</p></li><li><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p></li><li><p>确保头文件多次包含仍能安全工作的常用技术是预处理器。预处理器是在编译之前执行的一段程序，可以部分的改变我们所写的程序。</p></li><li><p>#include就是一项预处理器功能，当预处理器看到#include标记时就会用指定的头文件的内容替代#include。</p></li><li><p>c++程序还会用到的一项预处理器功能是头文件保护符，头文件保护符依赖于预处理变量。</p></li><li><p>预处理变量有两种状态：已定义和未定义。</p></li><li><p>#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真；#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sales_data</span>&#123;</span><br>std::string bookNo;<br>    <span class="hljs-keyword">unsigned</span> units_sold = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> revenue = <span class="hljs-number">0.0</span>;   <br>&#125;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-comment">//使用上述功能就能有效地防止重复包含的发生。</span><br><span class="hljs-comment">//第一次包含Sales_data.h时，#ifndef的检查结果为真</span><br><span class="hljs-comment">//预处理器将顺序执行后面的操作直到遇到#endif为止。</span><br><span class="hljs-comment">//此时，预处理变量SALES_DATA_H的值将变成已定义</span><br><span class="hljs-comment">//Sales_data.h也会被拷贝到程序中来</span><br><span class="hljs-comment">//后面如果再一次包含Sales_data.h，则#ifndef的检查结果将为假</span><br><span class="hljs-comment">//编译器将忽略#ifndef到#endif之间的部分</span><br></code></pre></td></tr></table></figure></li><li><p>预处理变量无视cpp中关于作用域的规则。</p></li><li><p>整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其它实体发生名字冲突，一般把预处理变量的名字全部大写。</p></li></ol><h4 id="第二章总结"><a href="#第二章总结" class="headerlink" title="第二章总结"></a>第二章总结</h4><ol><li><p>类型是cpp编程的基础，类型规定了其对象的存储要求和所能执行的操作。</p></li><li><p>cpp语言提供了一套基础内置类型，如int和char等，这些类型与实现它们的机器硬件密切相关。</p></li><li><p>类型分为常量和非常量，一个常量对象必须进行初始化，而且一旦初始化其值就不能再改变。</p></li><li><p>指针和引用是复合类型，复合类型的定义以其它的类型为基础。</p></li><li><p>术语表整理：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 地址：根据地址可以找到内存中的一块区域，一般是按照字节寻址。<br><span class="hljs-bullet">2.</span> 别名声明：为另外一种类型定义一个同义词：使用&quot;名字 = 类型&quot;的格式将名字作为该类型的同义词。<br><span class="hljs-bullet">3.</span> 算数类型：布尔值、字符、整数和浮点数等内置类型。<br><span class="hljs-bullet">4.</span> 数组：一种数据结构，存放一组未命名的对象，可以按照索引访问这些对象。<br><span class="hljs-bullet">5.</span> auto：类型说明符，通过变量的初始值来推断变量的类型。<br><span class="hljs-bullet">6.</span> 基本类型：是类型说明符，可以用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。<br><span class="hljs-bullet">7.</span> 绑定：将某个名字与给定的实体关联在一起，使用该名字就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。<br><span class="hljs-bullet">8.</span> 字节：内存中可以寻址的最小单元，大多数机器的字节占8位。<br><span class="hljs-bullet">9.</span> 类成员：类的组成部分。<br><span class="hljs-bullet">10.</span> 复合类型：是一种类型，它的定义以其它的类型为基础。<br><span class="hljs-bullet">11.</span> const：一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须进行初始化。<br><span class="hljs-bullet">12.</span> 常量指针：是一种指针，它的值永不改变。<br><span class="hljs-bullet">13.</span> 常量引用：指向常量的引用。<br><span class="hljs-bullet">14.</span> 常量表达式：在编译时计算并获取结果的表达式。<br><span class="hljs-bullet">15.</span> constexpr：是一种函数，用于代替常量表达式。<br><span class="hljs-bullet">16.</span> 转换：一种类型的值转变成另一种类型值的过程。cpp语言支持内置类型的转换。<br><span class="hljs-bullet">17.</span> 数据成员：组成对象的数据元素，类的每个对象都有数据成员的一份拷贝。数据成员可以在类内部声明的同时进行初始化。<br><span class="hljs-bullet">18.</span> 声明：声称存在一个变量、函数或是别处定义的类型。名字必须在定义或者声明之后使用。<br><span class="hljs-bullet">19.</span> 声明符：是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。<br><span class="hljs-bullet">20.</span> decltype：是一个类型说明符，从变量或者表达式推断出类型。<br><span class="hljs-bullet">21.</span> 默认初始化：当对象未被显式的赋予初始值时执行的初始化行为。。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值。<br><span class="hljs-bullet">22.</span> 定义：为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或者声明之后才能使用。<br><span class="hljs-bullet">23.</span> 转义序列：字符特别是那些不可打印字符的替代形式。转义序列以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数字。<br><span class="hljs-bullet">24.</span> 全局作用域：位于其它所有作用域之外的作用域。<br><span class="hljs-bullet">25.</span> 头文件保护符：使用预处理变量以防止头文件被某个文件重复包含。<br><span class="hljs-bullet">26.</span> 标识符：组成名字的字符序列，标识符对大小写敏感。<br><span class="hljs-bullet">27.</span> 类内初始值：在声明类的数据成员时同时提供的初始值，必须置于等号右侧或者花括号内。<br><span class="hljs-bullet">28.</span> 在作用域内：名字在当前作用域内可见。<br><span class="hljs-bullet">29.</span> 被初始化：变量在定义的同时被赋予初始值，变量一般都应该被初始化。<br><span class="hljs-bullet">30.</span> 内层作用域：嵌套在其它作用域内的作用域。<br><span class="hljs-bullet">31.</span> 列表初始化：利用花括号把一个或多个初始值放在一起的初始化形式。<br><span class="hljs-bullet">32.</span> 字面值：是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。<br><span class="hljs-bullet">33.</span> 局部作用域：也可以被叫做块级作用域。<br><span class="hljs-bullet">34.</span> 底层const：一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略。<br><span class="hljs-bullet">35.</span> 成员：类的组成部分。<br><span class="hljs-bullet">36.</span> 不可打印字符：不具有可见形式的字符，如控制符、退格，换行符等。<br><span class="hljs-bullet">37.</span> 空指针：值为0的指针，空指针合法但是不指向任何对象。<br><span class="hljs-bullet">38.</span> 对象：内存中的一个区域，具有某种类型，变量是命名了的对象。<br><span class="hljs-bullet">39.</span> 外层作用域：嵌套着别的作用域的作用域。<br><span class="hljs-bullet">40.</span> 指针：是一个对象，存放着某个对象的地址，或者某个对象存储区域的下一个地址，或者0。<br><span class="hljs-bullet">41.</span> 指向常量的指针：是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。<br><span class="hljs-bullet">42.</span> 预处理器：cpp编译过程中执行的一段程序。<br><span class="hljs-bullet">43.</span> 预处理变量：由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。<br><span class="hljs-bullet">44.</span> 引用：某个对象的别名。<br><span class="hljs-bullet">45.</span> 对常量的引用：是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。<br><span class="hljs-bullet">46.</span> 作用域：程序的一部分，在其中某些名字有意义。cpp有几级作用域：<br><span class="hljs-code">（1）全局：名字定义在所有其它作用域之外。</span><br><span class="hljs-code">（2）类：名字定义在类内部。</span><br><span class="hljs-code">（3）命名空间：名字定义在命名空间内部。</span><br><span class="hljs-code">（4）块：名字定义在块内部。</span><br><span class="hljs-code">47. 分离式编译：把程序分割为多个单独的文件的能力。</span><br><span class="hljs-code">48. 带符号类型：保存正数、负数或者0的整型。</span><br><span class="hljs-code">49. 字符串：一种库类型，表示可变长字符序列。</span><br><span class="hljs-code">50. struct：可以用于定义类的一个关键字。</span><br><span class="hljs-code">51. 临时值：编译器在计算表达式结果时创建的无名对象。为某表达式创建一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。</span><br><span class="hljs-code">52. 顶层const：是一个const，规定某个对象的值不能改变。</span><br><span class="hljs-code">53. 类型别名：是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义。</span><br><span class="hljs-code">54. 类型检查：是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。</span><br><span class="hljs-code">55. 类型说明符：类型的名字。</span><br><span class="hljs-code">56. typedef：为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名。</span><br><span class="hljs-code">57. 未定义</span><br><span class="hljs-code">58. 未初始化：变量已经定义但是未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为。</span><br><span class="hljs-code">59. 无符号类型：保存大于等于0的整型。</span><br><span class="hljs-code">60. 变量：命名的对象或者引用。cpp要求变量要先声明后使用。</span><br><span class="hljs-code">61. void\*：可以指向任意非常量的指针类型，不能执行解引用操作。</span><br><span class="hljs-code">62. void类型：一种有着特殊用处的类型，既无操作也无值。不能定义一个void类型的变量。</span><br><span class="hljs-code">63. 字：在执行机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。</span><br><span class="hljs-code">64. &amp;运算符：取地址运算符。</span><br><span class="hljs-code">65. \*运算符：解引用运算符，解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。</span><br><span class="hljs-code">66. #define：一条预处理指令，用于定义一个预处理变量。</span><br><span class="hljs-code">67. #endif：预处理指令，用于结束一个#ifdef或者一个#ifndef</span><br><span class="hljs-code">68. #ifdef：一条预处理指令，用于判断给定的变量是否已经定义。</span><br><span class="hljs-code">69. #ifndef：一条预处理指令，用于判断给定的变量是否未定义。</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer_5th_chapter2&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>cpp_primer_1_40</title>
    <link href="http://example.com/cpp-primer-1-40/"/>
    <id>http://example.com/cpp-primer-1-40/</id>
    <published>2021-05-21T07:11:59.000Z</published>
    <updated>2021-05-21T15:52:40.812Z</updated>
    
    <content type="html"><![CDATA[<p>cpp_primer的读书笔记第一篇</p><p>主要内容包括变量、复合类型、const限定符</p><span id="more"></span><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ol><li><p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型的时候，程序会自动进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">bool</span> b = <span class="hljs-number">42</span>; <span class="hljs-comment">//b为真</span><br><span class="hljs-keyword">int</span> i = b; <span class="hljs-comment">//i == 1</span><br>i = <span class="hljs-number">3.14</span>; <span class="hljs-comment">//i == 3</span><br><span class="hljs-keyword">double</span> pi = i; <span class="hljs-comment">//pi == 3.0</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c = <span class="hljs-number">-1</span>; <span class="hljs-comment">//假设char占8比特，c == 255</span><br><span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span> c2 = <span class="hljs-number">256</span>; <span class="hljs-comment">//假设char占8比特，c2的值是未定义的</span><br></code></pre></td></tr></table></figure></li><li><p>类型所能表示的值的范围决定了转换的过程。</p></li><li><p>当给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。</p></li><li><p>当给带符号类型一个超出它表示范围的值时，结果是未定义的，此时程序可能继续工作，可能崩溃，也可能生成垃圾数据。</p></li><li><p>在一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。把int转换成无符号数的过程和把int直接赋给无符号变量一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> u = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">-42</span>;<br>std::cout&lt;&lt;i + i&lt;&lt;std::endl; <span class="hljs-comment">//-84</span><br>std::cout&lt;&lt;u + i&lt;&lt;std::endl; <span class="hljs-comment">//4294967264</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> u1 = <span class="hljs-number">42</span>, u2 = <span class="hljs-number">10</span>;<br>std::cout&lt;&lt;u1 - u2&lt;&lt;std::endl; <span class="hljs-comment">//32</span><br>std::cout&lt;&lt;u2 - u1&lt;&lt;std::endl; <span class="hljs-comment">//4294967264</span><br></code></pre></td></tr></table></figure></li><li><p>综上，避免出现错误的一个方式就是不要混用带符号类型和无符号类型。</p></li><li><p>练习2.3 2.4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">unsigned</span> u = <span class="hljs-number">10</span>, u2 = <span class="hljs-number">42</span>;<br>std::cout &lt;&lt; u2 - u &lt;&lt; std::endl; <span class="hljs-comment">//32</span><br>std::cout &lt;&lt; u - u2 &lt;&lt; std::endl; <span class="hljs-comment">//4294967264</span><br><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>, i2 = <span class="hljs-number">42</span>;<br>std::cout &lt;&lt; i2 - i &lt;&lt; std::endl; <span class="hljs-comment">//32</span><br>std::cout &lt;&lt; i - i2 &lt;&lt; std::endl; <span class="hljs-comment">//-32</span><br>std::cout &lt;&lt; i - u &lt;&lt; std::endl; <span class="hljs-comment">//0</span><br>std::cout &lt;&lt; u - i &lt;&lt; std::endl; <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h4><ol><li><p>每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p></li><li><p>可以将整型字面量写作十进制、八进制数或者十六进制数的形式。以0开头的整数表示8进制数，以0x或者0X开头的表示十六进制数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">20</span>;<span class="hljs-comment">//十进制</span><br><span class="hljs-number">024</span>；<span class="hljs-comment">//八进制</span><br><span class="hljs-number">0x14</span>;<span class="hljs-comment">//十六进制</span><br></code></pre></td></tr></table></figure></li><li><p>整型字面值具体的数据类型由它的值和符号确定。默认情况下，十进制字面值常量是带符号数，八进制和十六进制字面值即可能是带符号的也可能是无符号的。</p></li><li><p>十进制字面值常量的类型是int、long、long long中尺寸最小的那个，当然前提是这种类型要能容纳下当前的值。</p></li><li><p>八进制和十六进制的字面值常量的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸的最小者。</p></li><li><p>如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。</p></li><li><p>类型short没有对应的字面值。</p></li><li><p>浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中的指数以E或者e标识。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3.14159</span>;<br><span class="hljs-number">3.14159e0</span>;<br><span class="hljs-number">3.14159E0</span>;<br><span class="hljs-number">0.</span>;<br><span class="hljs-number">0e0</span>;<br><span class="hljs-number">.001</span>;<br></code></pre></td></tr></table></figure></li><li><p>由单引号括起来的一个字符称为char类型字面值，双引号括起来的零个或者多个字符则构成字符串类型字面值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//字符字面值</span><br><span class="hljs-string">&quot;hello world！&quot;</span>;<span class="hljs-comment">//字符串字面值</span><br></code></pre></td></tr></table></figure></li><li><p>字符串字面值类型实际上是由常量字符构成的数组。</p></li><li><p>编译器在每个字符串的结尾处添加一个空字符(‘\0’)，因此，字符串字面值的实际长度要比它的内容多1。</p></li><li><p>字面值’A’表示的就是单独的字符’A’，而字符串“A”则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符。</p></li><li><p>字符串字面值可以分多行书写，它们实际上是一个整体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout&lt;&lt;<span class="hljs-string">&quot;line first&quot;</span><br>       <span class="hljs-string">&quot;line second&quot;</span>&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure></li><li><p>转义序列主要用于表示一些不可打印的字符或者在cpp语言中有特殊含义的字符，转义序列均以” \ “作为开始。常见的需要转义的字符包括单引号，双引号，问号，反斜线。在程序中，转义序列被当作一个字符使用。</p></li><li><p>泛化的转义序列，其形式是\x之后跟一个或者多个十六进制数字，或者\后面跟1个、2个或者3个八进制数字，其中数字部分表示的是字符对应的数值。</p></li><li><p>如果\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。例如，”\1234”表示两个字符，即八进制数123对应的字符以及字符4。</p></li><li><p>\x要用到后面跟着的所有数字，例如，”\x1234”表示一个16位的字符，该字符由这4个16进制数所对应的比特唯一确定。</p></li><li><p>通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p></li><li><p>true和false是布尔类型的字面值。</p></li><li><p>nullptr是指针字面值。</p></li><li><p>练习2.5，指出下属字面值的数据类型并说明每一组内几种字面值的区别；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a)<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">L&#x27;a&#x27;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">L&quot;a&quot;</span><br>    <span class="hljs-string">&#x27;a&#x27;</span>表示字符a<br>    <span class="hljs-string">L&#x27;a&#x27;</span>表示宽字符型字面值a，且类型是<span class="hljs-keyword">wchar_t</span><br>    <span class="hljs-string">&quot;a&quot;</span>表示字符串a<br>    <span class="hljs-string">L&quot;a&quot;</span>表示宽字符型字符串<span class="hljs-built_in">a</span><br>(b)<span class="hljs-number">10</span>, <span class="hljs-number">10u</span>, <span class="hljs-number">10L</span>, <span class="hljs-number">10uL</span>, <span class="hljs-number">012</span>, <span class="hljs-number">0xc</span><br>    <span class="hljs-number">10</span>表示普通的整数类型字面值<br>    <span class="hljs-number">10u</span>表示一个无符号数<br>    <span class="hljs-number">10L</span>表示一个长整型数<br>    <span class="hljs-number">10uL</span>表示一个无符号长整型数<br>    <span class="hljs-number">012</span>是一个八进制数<br>    <span class="hljs-number">0xc</span>是一个十六进制数<br>(c)<span class="hljs-number">3.14</span>, <span class="hljs-number">3.14f</span>, <span class="hljs-number">3.14L</span><br>    <span class="hljs-number">3.14</span>是一个普通的浮点类型字面值<br>    <span class="hljs-number">3.14f</span>表示一个<span class="hljs-keyword">float</span>类型的单精度浮点数<br>    <span class="hljs-number">3.14L</span>表示一个<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>类型的扩展精度浮点数<br>(d)<span class="hljs-number">10</span>, <span class="hljs-number">10u</span>, <span class="hljs-number">10.</span>, <span class="hljs-number">10e-2</span><br>    <span class="hljs-number">10</span>是一个整数<br>    <span class="hljs-number">10u</span>是一个无符号整数<br>    <span class="hljs-number">10.</span>是一个浮点数<br>    <span class="hljs-number">10e-2</span>是一个科学计数法表示的浮点数<br></code></pre></td></tr></table></figure></li><li><p>练习2.6，下面两组定义是否有区别，如果有，请叙述之；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> month = <span class="hljs-number">9</span>, day = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> month = <span class="hljs-number">09</span>, day = <span class="hljs-number">07</span>;<br>第二组编译的时候会报错。因为以<span class="hljs-number">0</span>开头的是八进制数，而数字<span class="hljs-number">9</span>显然超出了八进制数所能表示的范围，所以第二组定义无法被编译通过。<br></code></pre></td></tr></table></figure></li><li><p>练习2.7，下述字面值表示何种含义？他们各自的数据类型是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a)<span class="hljs-string">&quot;Who goes with F\145rugs?\012&quot;</span><br>    字符串，包含两个转义字符。\<span class="hljs-number">145</span>表示<span class="hljs-string">&#x27;e&#x27;</span>,\<span class="hljs-number">012</span>表示<span class="hljs-string">&#x27;\n&#x27;</span><br>    因此该字符串的输出结果为<span class="hljs-string">&quot;Who goes with Ferugs?&quot;</span><br>(b)<span class="hljs-number">3.14e1</span>L<br>    科学计数法表示的扩展精度浮点数，大小为<span class="hljs-number">3.14</span> * <span class="hljs-number">10</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">31.4</span><br>(c)<span class="hljs-number">1024f</span><br>    试图表示一个单精度浮点数，但是在某些编译器中会报错，因为后缀f直接跟在了整数<span class="hljs-number">1024</span>后面<br>    建议修改成<span class="hljs-number">1024.f</span><br>(d)<span class="hljs-number">3.14L</span><br>    扩展精度浮点数，类型为<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>，大小为<span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.8，请用转义序列编写一段程序，要求先输出2M，然后转到新一行。修改程序使其先输出2，然后输出制表符，再输出M，最后转到新一行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;2\x4d\012&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;2\tM\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><ol><li><p>变量能提供一个具名的、可供程序操作的存储空间。cpp中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围以及变量能参与的运算。</p></li><li><p>在cpp中，”变量”和”对象”一般可以互换使用。</p></li><li><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p></li><li><p>初始化的多种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> b = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">int</span> c&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用花括号来进行初始化被称为列表初始化。当用于内置类型的变量的时候，列表初始化有一种重要的特点，如果使用列表初始化且初始值存在丢失信息的风险的时候，编译器会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> id = <span class="hljs-number">3.1415926536</span>;<br><span class="hljs-keyword">int</span> a = &#123; id &#125;;<br><span class="hljs-keyword">int</span> b&#123; id &#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">c</span><span class="hljs-params">(id)</span></span>;<br><span class="hljs-keyword">int</span> d = id;<br><span class="hljs-comment">//C4244“初始化”: 从“long double”转换到“int”，可能丢失数据</span><br></code></pre></td></tr></table></figure></li><li><p>如果定义变量的时候没有指定初值，则变量被默认初始化，此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p></li><li><p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或者以其它的形式访问此类型的值将引发错误。</p></li><li><p>每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。</p></li><li><p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。比如string类规定如果没有指定初值则生成一个空串。</p></li><li><p>综上，定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式的初始化，则其值由类决定。所以为了保证程序的安全，建议初始化每一个内置类型的变量。</p></li><li><p>练习2.9 解释下列定义的含义，对于非法的定义，请说明错在何处并将其改正。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-comment">//std::cin &gt;&gt; int a;</span><br><span class="hljs-comment">//错误，输入运算符右侧的右侧需要一个明确的变量名称，而非定义变量的语句</span><br><span class="hljs-comment">//int i = &#123; 3.14 &#125;;</span><br><span class="hljs-comment">//错误，将浮点数3.14赋值给一个整型变量i，这样做将导致小数部分丢失，是一种不建议的窄化操作。</span><br><span class="hljs-comment">//double salary = wage = 9999.99;</span><br><span class="hljs-comment">//错误，在声明语句中声明多个变量时需要用逗号将变量名隔开，而不能直接用赋值运算符连接</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">3.14</span>;<br><span class="hljs-comment">//不会报错，这样做将造成小数部分的丢失，是一种不建议的窄化操作</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.10 下列变量的初值分别是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string global_str;<br><span class="hljs-keyword">int</span> global_int;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::string local_str;<br><span class="hljs-keyword">int</span> local_int;<br><span class="hljs-comment">//对于string类型的变量来说</span><br><span class="hljs-comment">//string类型本身接受无参数的初始化方式，所以不论变量定义在函数内部还是函数外部都默认初始化为空串</span><br><span class="hljs-comment">//对于内置类型int来说</span><br><span class="hljs-comment">//global_int定义在所有函数体之外，所以其默认初始化为0</span><br><span class="hljs-comment">//local_int定义在main函数的内部，将不被初始化，如果程序试图拷贝或者输出未初始化的变量，将遇到一个未定义的奇异值</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="变量声明与定义的关系"><a href="#变量声明与定义的关系" class="headerlink" title="变量声明与定义的关系"></a>变量声明与定义的关系</h4><ol><li><p>为了允许把程序拆分成多个逻辑部分来编写，cpp支持分离式编译机制，该机制允许将程序分割为若干个文件，每个文件可以被独立编译。为了支持分离式编译，cpp语言将变量声明和变量定义区分开来。</p></li><li><p>变量声明：使得名字为程序所知，一个文件如果想使用别处定义的变量则必须包含对那个名字的声明。</p></li><li><p>变量定义：负责创建与名字关联的实体。</p></li><li><p>声明和定义的区别：变量声明规定了变量的类型和名字，这一点上与变量定义相同。但是除此之外，定义还申请存储空间，也可能会为变量指定一个初值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//声明i而非定义i</span><br><span class="hljs-keyword">int</span> j; <span class="hljs-comment">//声明并定义j</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>任何包含了显式初始化的声明即成为定义。extern语句如果包含初始值就不再是声明，而是定义了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li><li><p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p></li><li><p>变量只能被定义一次，但是可以多次被声明。</p></li><li><p>如果要在多个文件中使用同一个变量，就必须将变量的声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其它用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p></li><li><p>练习2.11 指出下面的语句是声明还是定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> ix = <span class="hljs-number">1024</span>; <span class="hljs-comment">//定义了变量ix</span><br><span class="hljs-keyword">int</span> iy; <span class="hljs-comment">//声明并定义了变量iy</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> iz; <span class="hljs-comment">//声明了变量iz</span><br></code></pre></td></tr></table></figure></li><li><p>静态类型：cpp是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查。</p></li><li><p>对象的类型决定了对象所能参与的运算。在cpp语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。这就要求我们在使用某个变量之前必须声明其类型。</p></li></ol><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ol><li><p>练习2.12 请指出下面的名字中哪些是非法的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> <span class="hljs-keyword">double</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">int</span> _;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">catch</span><span class="hljs-number">-22</span>;<br><span class="hljs-keyword">int</span> <span class="hljs-number">1</span>_or_2 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">double</span> Double = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h4><ol><li><p>作用域是程序的一部分，在其中名字有其特定的含义。cpp语言中大多数作用域都以花括号分隔。</p></li><li><p>同一个名字在不同的作用的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p></li><li><p>作用域可以分为全局作用域和块作用域。</p></li><li><p>全局作用域：定义在函数体之外。一旦声明之后，全局作用域内的名字在整个程序的范围内都可以使用。</p></li><li><p>作用域能彼此包含，被包含的作用域称为内层作用域，包含着别的作用域的作用域称为外层作用域。</p></li><li><p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内存作用域中重新定义外层作用域已有的名字。</p></li><li><p>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> reused = <span class="hljs-number">42</span>; <span class="hljs-comment">//reused拥有全局作用域</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> unique = <span class="hljs-number">0</span>; <span class="hljs-comment">//unique拥有块作用域</span><br><span class="hljs-comment">//此时使用的是全局变量reused</span><br>std::cout &lt;&lt; reused &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<br><span class="hljs-keyword">int</span> reused = <span class="hljs-number">0</span>;<span class="hljs-comment">//新建局部变量reused，覆盖了全局变量reused</span><br><span class="hljs-comment">//此时使用的是局部变量reused</span><br>std::cout &lt;&lt; reused &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<br><span class="hljs-comment">//显式的访问全局变量reused</span><br>    <span class="hljs-comment">//使用作用域操作符::来覆盖默认的作用域规则</span><br>    <span class="hljs-comment">//因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时</span><br>    <span class="hljs-comment">//向全局作用域发出请求获取作用域操作符右侧名字对应的变量</span><br>std::cout &lt;&lt; ::reused &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习2.13  下面程序中j的值是多少？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">int</span> j = i; <span class="hljs-comment">//100</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>练习2.14  下面的程序合法嘛？如果合法，它将输出什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;<br>    sum += i;<br>&#125;<br>std::cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;sum&lt;&lt;std::endl;<br><span class="hljs-comment">//合法，输出100 45</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ol><li><p>复合类型是基于其它类型定义的类型，引用和指针就是两种复合类型。</p></li><li><p>一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。</p></li><li><p>在这里，我们使用术语”引用”，指的其实是左值引用。</p></li><li><p>引用为对象起了另一个名字，引用类型引用另一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">int</span> &amp;refVal = ival; <span class="hljs-comment">//refVal指向ival（是ival的另一个名字）</span><br><span class="hljs-keyword">int</span> &amp;refVal2; <span class="hljs-comment">//报错：引用必须被初始化</span><br></code></pre></td></tr></table></figure></li><li><p>一般在初始化变量时，初始值会被拷贝到新建的对象中。</p></li><li><p>在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。</p></li><li><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">relVal = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> li = relVal;<br></code></pre></td></tr></table></figure></li><li><p>因为引用本身不是一个对象，所以不能定义引用的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//正确：relVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上</span><br><span class="hljs-keyword">int</span> &amp;relVal = refVal;<br><span class="hljs-comment">//正确，i被初始化为refVal的值</span><br><span class="hljs-keyword">int</span> i = refVal;<br></code></pre></td></tr></table></figure></li><li><p>引用的类型要和与之绑定的对象严格匹配。（存在两种例外情况，后面说明）</p></li><li><p>引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//错误：引用类型的初始值必须是一个对象</span><br><span class="hljs-keyword">int</span> &amp;refVal = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-comment">//错误：此处引用类型的初始值必须是int型对象</span><br><span class="hljs-keyword">int</span> &amp;refVal = dval;<br></code></pre></td></tr></table></figure></li><li><p>练习2.15 下面的哪个定义是不合法的？为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1.01</span>; <span class="hljs-comment">//会被窄化，但是合法</span><br><span class="hljs-keyword">int</span>&amp; rval1 = <span class="hljs-number">1.01</span>; <span class="hljs-comment">//非法，引用必须指向一个实际存在的对象而非字面值常量</span><br><span class="hljs-keyword">int</span>&amp; rval2 = ival; <span class="hljs-comment">//合法</span><br><span class="hljs-keyword">int</span>&amp; rval3; <span class="hljs-comment">//因为无法令引用重新绑定到另一个对象，所以引用必须进行初始化</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.16 考查下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值是合法的？它们执行了什么样的操作？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, &amp; r1 = i;<br><span class="hljs-keyword">double</span> d = <span class="hljs-number">0</span>, &amp; r2 = d;<br>r2 = <span class="hljs-number">3.14159</span>; <span class="hljs-comment">//合法的，为引用赋值实际上是把值赋给了与引用绑定的对象，在这里是把3.14159赋值给了变量d</span><br>r2 = r1; <span class="hljs-comment">//合法的，以引用作为初始值实际上是以引用绑定的对象作为初始值，在这里是把i的值赋值给了变量d</span><br>i = r2;<span class="hljs-comment">//把d的值赋值给了变量i，因为d是双精度浮点数而i是整数，所以该语句实际上执行了窄化操作。</span><br>r1 = d;<span class="hljs-comment">//合法，把d的值赋值给了变量i，与上一条语句一样执行了窄化操作。</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.17 执行下面的代码段将输出什么结果？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i, &amp; ri = i;<br>i = <span class="hljs-number">5</span>;<br>ri = <span class="hljs-number">10</span>;<br>std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ri &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li></ol><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ol><li><p>指针是”指向”另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。</p></li><li><p>指针与引用是不同的。</p></li><li><p>指针本身就是一个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期中它可以先后指向几个不同的对象。</p></li><li><p>指针无需在定义时赋初值，和其它内置类型一样，在块作用域内定义的指针如果没有进行初始化，也将拥有一个不确定的值。</p></li><li><p>定义指针的方法是将声明符写成*d的形式，其中d是变量名。</p></li><li><p>指针存放某个对象的地址，想要获取该地址，需要使用取地址符（操作符&amp;）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> *p = &amp;ival;<br><span class="hljs-comment">//p存放变量ival的地址</span><br></code></pre></td></tr></table></figure></li><li><p>引用不是对象，没有实际的地址，所以不能定义指向引用的指针。</p></li><li><p>指针的类型要和它指向的对象进行严格匹配。（存在两种例外情况）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> dval;<br><span class="hljs-keyword">double</span> *pd = &amp;dval;<span class="hljs-comment">//正确，初始值是double型对象的地址</span><br><span class="hljs-keyword">double</span> *pd2 = pd;<span class="hljs-comment">//正确，初始值是指向double对象的指针</span><br><br><span class="hljs-keyword">int</span> *pi = pd; <span class="hljs-comment">//错误，指针Pi的类型和指针pd的类型不匹配</span><br>pi = &amp;dval; <span class="hljs-comment">//错误，试图把double型对象的地址赋值给int类型的指针</span><br></code></pre></td></tr></table></figure></li><li><p>指针的值（地址）应属于下列四种状态之一：（1）指向一个对象（2）指向紧邻对象所占空间的下一个位置（3）空指针，意味着指针没有指向任何对象（4）无效指针，也就是上述情况之外的其它值。</p></li><li><p>如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象。解引用操作只适用于那些确实指向了某个对象的有效指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> *p = &amp;ival; <span class="hljs-comment">//p存放着ival的指针</span><br>cout &lt;&lt; *p; <span class="hljs-comment">//由*得到指针p所指的对象，输出42</span><br><br><span class="hljs-comment">//对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值</span><br>*p = <span class="hljs-number">0</span>;<br>cout &lt;&lt; ival;<br></code></pre></td></tr></table></figure></li><li><p>&amp;和*两个符号，在作为声明的一部分出现或者用作表达式里的操作符含义是截然不同的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span>* p = &amp;i; <span class="hljs-comment">//*紧随类型名出现，说明p是一个指针；&amp;出现在表达式中，表示取地址符</span><br><span class="hljs-keyword">int</span>&amp; r = *p; <span class="hljs-comment">//&amp;紧随类型名出现，说明r是一个引用；*出现在表达式中，表示解引用符</span><br>r = <span class="hljs-number">50</span>;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li><li><p>空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空，以下列出几个生成空指针的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> cstdlib</span><br><span class="hljs-keyword">int</span> *p3 = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//NULL是一个预处理变量，这个变量在头文件cstdlib中定义，它的值就是0。</span><br><span class="hljs-comment">//预处理器是运行于编译过程之前的一段程序。</span><br><span class="hljs-comment">//预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须再前面加上std::。</span><br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//把int变量直接赋值给指针是错误的操作，即使int变量的值恰好等于0也不行</span><br><span class="hljs-keyword">int</span> zero = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *p = zero; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>建议初始化所有的指针，如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0。</p></li><li><p>指针和引用都能提供对其它对象的间接访问。</p></li><li><p>引用本身并非一个对象，一旦定义了一个引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p></li><li><p>指针和它存放的地址之间就没有这些限制了，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。</p></li><li><p>只要指针拥有一个合法值，就能将它用在条件表达式中。如果指针的值是0，条件取false。任何非0指针对应的条件值都是true。</p></li><li><p>对于两个类型相同的合法指针，可以使用相等操作符(==)或者不相等操作符(!=)来比较它们，比较的结果是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。</p></li><li><p>两个指针存放的地址值相同有三种可能：（1）都为空（2）都指向同一个对象（3）都指向同一个对象的下一个地址。需要注意的是，一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</p></li><li><p>void*是一种特殊的指针类型，可以用于存放任意类型的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> obj = <span class="hljs-number">3.14</span>, *pd = &amp;obj;<br><span class="hljs-keyword">void</span>* pv = &amp;obj;<br>pv = pd;<br></code></pre></td></tr></table></figure></li><li><p>void*指针可以进行的操作：（1）拿它和别的指针比较（2）作为函数的输入输出（3）赋值给另一个void * 类型的指针。</p></li><li><p>void*指针不能进行的操作：不能直接操作void *指针指向的对象，因为并不知道这个对象到底是什么类型，也就无法确定能在这个对象上进行哪些操作。</p></li><li><p>练习2.18 编写代码分别更改指针的值和指针所指对象的值。</p></li><li><p>练习2.19 说明指针和引用的主要区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//相同点：指针指向内存中的某个对象，而引用绑定到内存中的某个对象，它们都实现了对其它对象的间接访问。</span><br><span class="hljs-comment">//不同点</span><br><span class="hljs-comment">//（1）指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；</span><br><span class="hljs-comment">//引用不是一个对象，无法令引用重新绑定到另外一个对象。</span><br><span class="hljs-comment">//（2）指针无须在定义时赋初值，和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</span><br><span class="hljs-comment">//引用必须在定义的时候赋初值。</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.20 请叙述下面这段代码的作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> *p1 = &amp;i;<br>*p1 = *p1 * *p1;<br><span class="hljs-comment">//作用 i = i * i; </span><br></code></pre></td></tr></table></figure></li><li><p>练习2.21 请解释下述定义。这些定义中有非法的嘛？如果有，为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//非法的，dp是一个double指针，而i是一个int变量，类型不匹配</span><br><span class="hljs-keyword">double</span>* dp = &amp;i; <br><span class="hljs-comment">//非法的，不能直接把int变量赋给int指针</span><br><span class="hljs-keyword">int</span>* ip = i;<br><span class="hljs-comment">//合法的</span><br><span class="hljs-keyword">int</span>* p = &amp;i;<br></code></pre></td></tr></table></figure></li><li><p>练习2.22 假设p是一个int型指针，请说明下述代码的含义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(p) <span class="hljs-comment">//...</span><br><span class="hljs-comment">//指针p作为条件的时候，实际上检验的就是指针本身的值，即指针所指的地址值；</span><br><span class="hljs-comment">//如果指针指向一个真实存在的变量，则其值必不为0，此时条件为真；</span><br><span class="hljs-comment">//p为空指针，条件为假；</span><br><span class="hljs-comment">//如果指针没有指向任何对象或者是无效指针，则对p的使用将引发不可预计的结果。</span><br><span class="hljs-keyword">if</span>(*p) <span class="hljs-comment">//...</span><br><span class="hljs-comment">// *p == 0条件为假</span><br><span class="hljs-comment">// *p != 0条件为真</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.23 给定指针p，你能知道它是否指向了一个合法的对象嘛？如果能，叙述判断的思路；如不能，说明原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在cpp程序中，应该尽量初始化所有的指针，并且尽可能等定义了对象之后再定义指向它的指针。</span><br><span class="hljs-comment">//如果实在不清楚指针应该指向何处，就把他初始化为nullptr或者0。</span><br><span class="hljs-comment">//nullptr是一个特殊字面值，它可以转换成任意其它的指针类型。</span><br><span class="hljs-comment">//在上述条件下，判断p是否指向合法的对象，只需要把p作为if语句的条件即可。</span><br><br><span class="hljs-comment">//如果不注意初始化所有指针而贸然判断指针的值，则有可能引发不可预知的结果。</span><br><span class="hljs-comment">//一种处理的办法是把if(p)置于try结构中，当程序块顺利执行时，表示p指向了合法的对象；</span><br><span class="hljs-comment">//当程序块出错跳转到catch语句时，表示p没有指向合法的对象。</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.24 在下面这段代码中，为什么p合法而lp非法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">void</span>* p = &amp;i;<br><span class="hljs-keyword">long</span>* lp = &amp;i;<br><span class="hljs-comment">//void* 是一种特殊的指针类型，可以用于存放任意对象的地址。</span><br><span class="hljs-comment">//lp不合法的原因时两者的类型不匹配。</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h4><ol><li><p>变量的定义包括一个基本数据类型和一组声明符，其中类型修饰符是声明符的一部分，基本数据类型和类型修饰符并没有耦合关系。</p></li><li><p>声明符中修饰符的个数并没有限制。以指针为例，指针是内存中的对象，像其它对象一样也有自己的地址，因此可以把指针的地址再存放到另一个指针中。</p></li><li><p>通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针，***表示指向指针的指针的指针，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> ival = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">int</span> *pi = &amp;ival; <span class="hljs-comment">//pi指向一个int型的数</span><br><span class="hljs-keyword">int</span> **ppi = &amp;pi; <span class="hljs-comment">//ppi指向一个int型的指针</span><br></code></pre></td></tr></table></figure></li><li><p>“int **” 类型的值不能用于初始化 “int *” 类型的实体。</p></li><li><p>引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span>* p; <span class="hljs-comment">//p是一个int类型的指针</span><br><span class="hljs-keyword">int</span>*&amp; r = p; <span class="hljs-comment">//r是一个对指针p的引用</span><br>r = &amp;i;<br>*r = <span class="hljs-number">0</span>;<br>std::cout &lt;&lt; i &lt;&lt; std::endl; <span class="hljs-comment">//0</span><br>&#125;<br><span class="hljs-comment">//要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义</span><br><span class="hljs-comment">//离变量名最近的符号对变量的类型有最直接的影响</span><br><span class="hljs-comment">//r是一个引用</span><br><span class="hljs-comment">//声明符的其余部分用以确定r引用的类型是什么</span><br><span class="hljs-comment">//此例中的符号*说明r引用的是一个指针</span><br><span class="hljs-comment">//最后声明的基本数据类型指出r引用的是一个int类型的指针</span><br></code></pre></td></tr></table></figure></li><li><p>练习2.25 说明下列变量的类型和值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> * ip, i, &amp;r = i;<br><span class="hljs-keyword">int</span> i, *ip = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *ip, ip2;<br></code></pre></td></tr></table></figure></li></ol><h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><ol><li><p>定义变量时使用const，变量的值不能被改变。</p></li><li><p>const对象必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">get_size</span>(); <span class="hljs-comment">//正确，运行时初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">42</span>;<span class="hljs-comment">//正确，编译时初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k; <span class="hljs-comment">//错误，k是一个未经初始化的常量</span><br></code></pre></td></tr></table></figure></li><li><p>默认状态下，const对象仅在文件内有效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以编译时初始化的方式定义一个const对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-number">512</span>;<br><span class="hljs-comment">//编译器在编译的过程中将用到该变量的地方都替换成对应的值。</span><br><span class="hljs-comment">//也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。</span><br><span class="hljs-comment">//为了执行替换，编译器必须知道变量的初始值。</span><br><span class="hljs-comment">//如果程序包含多个文件，则每个用了const对象的文件都必须能访问到它的初始值才行。</span><br><span class="hljs-comment">//要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。</span><br><span class="hljs-comment">//为了支持这一用法，同时避免对同一变量的重复定义，</span><br><span class="hljs-comment">//默认情况下，const对象被设定为仅在当前文件中有效。</span><br><span class="hljs-comment">//当多个文件中出现了同名的const变量时，其实等同于在不同的文件中分别定义了独立的变量。</span><br></code></pre></td></tr></table></figure></li><li><p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，又确实有必要在文件中共享，这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反我们想让这类const对象像其它对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并且使用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//解决的办法：对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就可以了。</span><br><span class="hljs-comment">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSize = <span class="hljs-built_in">func</span>();<br><span class="hljs-comment">//file_1.h头文件</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> bufSzie;<br></code></pre></td></tr></table></figure></li><li><p>综上，如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p></li><li><p>练习2.26 下面哪些句子是合法的？如果有不合法的句子，请说明是为什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> buf; <span class="hljs-comment">//非法的，const对象没有初始化</span><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = cnt;<br>++cnt; <br>++sz;<span class="hljs-comment">//非法，const对象其值不能被改变，也不能执行自增操作。</span><br></code></pre></td></tr></table></figure></li><li><p>常量引用：对const的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = ci; <span class="hljs-comment">//引用及其对应的对象都是常量</span><br>r1 = <span class="hljs-number">42</span>; <span class="hljs-comment">//错误操作，因为r1是对常量的引用</span><br><span class="hljs-keyword">int</span> &amp;r2 = ci; <span class="hljs-comment">//错误，试图让一个非常量引用指向一个常量对象</span><br></code></pre></td></tr></table></figure></li><li><p>引用的类型必须与其所引用对象的类型保持一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//例外情况1</span><br><span class="hljs-comment">//初始化常量引用时允许用任意表达式作为初始值</span><br><span class="hljs-comment">//只要该表达式的结果能转换成引用的类型即可。</span><br><span class="hljs-comment">//尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般的表达式</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">//正确，常量引用绑定到普通的int对象上</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>; <span class="hljs-comment">//正确，常量引用绑定到字面值上</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">//正确，r3是一个常量引用</span><br><span class="hljs-keyword">int</span> &amp;r4 = r1 * <span class="hljs-number">2</span>; <span class="hljs-comment">//错误，r4是一个普通的非常量引用</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = dval;<br><br><span class="hljs-comment">//编译器把上述代码变成了如下形式：</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> temp = dval; <span class="hljs-comment">//让双精度浮点数生成一个临时的整型常量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = temp; <span class="hljs-comment">//让r1绑定这个临时量</span><br></code></pre></td></tr></table></figure></li><li><p>常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> &amp;r1 = i; <span class="hljs-comment">//引用r1绑定对象i</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = i; <span class="hljs-comment">//r2也绑定对象i，但是不允许通过r2修改i的值</span><br>r1 = <span class="hljs-number">0</span>;<span class="hljs-comment">//r1并非常量，i的值修改为0</span><br>r2 = <span class="hljs-number">0</span>;<span class="hljs-comment">//错误，r2是一个常量引用</span><br></code></pre></td></tr></table></figure></li></ol><p>​    </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp_primer的读书笔记第一篇&lt;/p&gt;
&lt;p&gt;主要内容包括变量、复合类型、const限定符&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/hello-world/"/>
    <id>http://example.com/hello-world/</id>
    <published>2021-05-18T14:12:02.847Z</published>
    <updated>2021-05-18T14:12:02.847Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
